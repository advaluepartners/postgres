The below represents the folders and files from the root paths:
- /Users/barneycook/Desktop/code/ProjectRef/postgres/.github

Each file is separated by '''--- followed by the file path and ending with ---.
File content begins immediately after its path and extends until the next '''---


*Directory: .github*
Total words: 4095

File structure:

.github/
    CODEOWNERS
    pull_request_template.md
workflows/
    ami-release-nix.yml
    check-shellscripts.yml
    ci.yml
    dockerhub-release-matrix.yml
    mirror-postgrest.yml
    mirror.yml
    nix-build.yml
    publish-migrations.yml
    publish-nix-pgupgrade-bin-flake-version.yml
    publish-nix-pgupgrade-scripts.yml
    test.yml
    testinfra-nix.yml
PULL_REQUEST_TEMPLATE/
    default.md
    extension_upgrade.md

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/.github/CODEOWNERS ---
* @supabase/backend
migrations/ @supabase/cli @supabase/backend
docker/orioledb @supabase/postgres @supabase/backend
common.vars.pkr.hcl @supabase/postgres @supabase/backend

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/.github/pull_request_template.md ---
Please go the the `Preview` tab and select the appropriate sub-template:

* [Default](?expand=1&template=default.md)
* [Extension Upgrade](?expand=1&template=extension_upgrade.md)
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/.github/workflows/ami-release-nix.yml ---
name: Release AMI Nix

on:
  push:
    branches:
      - develop
      - release/*
    paths:
      - '.github/workflows/ami-release-nix.yml'
      - 'common-nix.vars.pkr.hcl'
      - 'ansible/vars.yml'
  workflow_dispatch:

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      postgres_versions: ${{ steps.set-versions.outputs.postgres_versions }}
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v3
      
      - uses: DeterminateSystems/nix-installer-action@main

      - name: Set PostgreSQL versions
        id: set-versions
        run: |
          VERSIONS=$(nix run nixpkgs#yq --  '.postgres_major[]' ansible/vars.yml | nix run nixpkgs#jq -- -R -s -c 'split("\n")[:-1]')
          echo "postgres_versions=$VERSIONS" >> $GITHUB_OUTPUT

  build:
    needs: prepare
    strategy:
      matrix:
        postgres_version: ${{ fromJson(needs.prepare.outputs.postgres_versions) }}
        include:
          - runner: arm-runner
            arch: arm64
            ubuntu_release: focal
            ubuntu_version: 20.04
            mcpu: neoverse-n1
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 150
    permissions:
      contents: write
      packages: write
      id-token: write

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v3

      - uses: DeterminateSystems/nix-installer-action@main

      - name: Run checks if triggered manually
        if: ${{ github.event_name == 'workflow_dispatch' }}
        run: |
          SUFFIX=$(sudo nix run nixpkgs#yq -- ".postgres_release[\"postgres${{ matrix.postgres_version }}\"]" ansible/vars.yml | sed -E 's/[0-9\.]+(.*)$/\1/')
          if [[ -z $SUFFIX ]] ; then
            echo "Version must include non-numeric characters if built manually."
            exit 1
          fi

      - name: Set PostgreSQL version environment variable
        run: echo "POSTGRES_MAJOR_VERSION=${{ matrix.postgres_version }}" >> $GITHUB_ENV

      - name: Generate common-nix.vars.pkr.hcl
        run: |
          PG_VERSION=$(sudo nix run nixpkgs#yq -- '.postgres_release["postgres'${{ matrix.postgres_version }}'"]' ansible/vars.yml)
          PG_VERSION=$(echo $PG_VERSION | tr -d '"')  # Remove any surrounding quotes
          echo 'postgres-version = "'$PG_VERSION'"' > common-nix.vars.pkr.hcl
          # Ensure there's a newline at the end of the file
          echo "" >> common-nix.vars.pkr.hcl

      - name: Build AMI stage 1
        env:
          POSTGRES_MAJOR_VERSION: ${{ env.POSTGRES_MAJOR_VERSION }}
        run: |
          packer init amazon-arm64-nix.pkr.hcl
          GIT_SHA=${{github.sha}}
          packer build -var "git-head-version=${GIT_SHA}" -var "packer-execution-id=${GITHUB_RUN_ID}"  -var-file="development-arm.vars.pkr.hcl" -var-file="common-nix.vars.pkr.hcl" -var "ansible_arguments=-e postgresql_major=${POSTGRES_MAJOR_VERSION}"  amazon-arm64-nix.pkr.hcl

      - name: Build AMI stage 2
        env:
          POSTGRES_MAJOR_VERSION: ${{ env.POSTGRES_MAJOR_VERSION }}
        run: |
          packer init stage2-nix-psql.pkr.hcl
          GIT_SHA=${{github.sha}}
          POSTGRES_MAJOR_VERSION=${{ env.POSTGRES_MAJOR_VERSION }}
          packer build -var "git_sha=${GIT_SHA}" -var "git-head-version=${GIT_SHA}" -var "packer-execution-id=${GITHUB_RUN_ID}" -var "postgres_major_version=${POSTGRES_MAJOR_VERSION}" -var-file="development-arm.vars.pkr.hcl" -var-file="common-nix.vars.pkr.hcl" stage2-nix-psql.pkr.hcl

      - name: Grab release version
        id: process_release_version
        run: |
          VERSION=$(cat common-nix.vars.pkr.hcl | sed -e 's/postgres-version = "\(.*\)"/\1/g')
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Create nix flake revision tarball
        run: |
          GIT_SHA=${{github.sha}}
          MAJOR_VERSION=${{ env.POSTGRES_MAJOR_VERSION }}

          mkdir -p "/tmp/pg_upgrade_bin/${MAJOR_VERSION}"
          echo "$GIT_SHA" >> "/tmp/pg_upgrade_bin/${MAJOR_VERSION}/nix_flake_version"
          tar -czf "/tmp/pg_binaries.tar.gz" -C "/tmp/pg_upgrade_bin" .

      - name: configure aws credentials - staging
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.DEV_AWS_ROLE }}
          aws-region: "us-east-1"

      - name: Upload software manifest to s3 staging
        run: |
          cd ansible
          ansible-playbook -i localhost \
            -e "ami_release_version=${{ steps.process_release_version.outputs.version }}" \
            -e "internal_artifacts_bucket=${{ secrets.ARTIFACTS_BUCKET }}" \
            -e "postgres_major_version=${{ env.POSTGRES_MAJOR_VERSION }}" \
            manifest-playbook.yml

      - name: Upload nix flake revision to s3 staging
        run: |
          aws s3 cp /tmp/pg_binaries.tar.gz s3://${{ secrets.ARTIFACTS_BUCKET }}/upgrades/postgres/supabase-postgres-${{ steps.process_release_version.outputs.version }}/20.04.tar.gz

      - name: configure aws credentials - prod
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.PROD_AWS_ROLE }}
          aws-region: "us-east-1"

      - name: Upload software manifest to s3 prod
        run: |
          cd ansible
          ansible-playbook -i localhost \
            -e "ami_release_version=${{ steps.process_release_version.outputs.version }}" \
            -e "internal_artifacts_bucket=${{ secrets.PROD_ARTIFACTS_BUCKET }}" \
            -e "postgres_major_version=${{ env.POSTGRES_MAJOR_VERSION }}" \
            manifest-playbook.yml
    
      - name: Upload nix flake revision to s3 prod
        run: |
          aws s3 cp /tmp/pg_binaries.tar.gz s3://${{ secrets.PROD_ARTIFACTS_BUCKET }}/upgrades/postgres/supabase-postgres-${{ steps.process_release_version.outputs.version }}/20.04.tar.gz

      - name: Create release
        uses: softprops/action-gh-release@v1
        with:
          name: ${{ steps.process_release_version.outputs.version }}
          tag_name: ${{ steps.process_release_version.outputs.version }}
          target_commitish: ${{github.sha}}

      - name: Slack Notification on Failure
        if: ${{ failure() }}
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_NOTIFICATIONS_WEBHOOK }}
          SLACK_USERNAME: 'gha-failures-notifier'
          SLACK_COLOR: 'danger'
          SLACK_MESSAGE: 'Building Postgres AMI failed'
          SLACK_FOOTER: ''

      - name: Cleanup resources after build
        if: ${{ always() }}
        run: |
          aws ec2 describe-instances --filters "Name=tag:packerExecutionId,Values=${GITHUB_RUN_ID}" --query "Reservations[].Instances[].InstanceId" --output text | xargs -r aws ec2 terminate-instances --instance-ids

      - name: Cleanup resources on build cancellation
        if: ${{ cancelled() }}
        run: |
          aws ec2 describe-instances --filters "Name=tag:packerExecutionId,Values=${GITHUB_RUN_ID}" --query "Reservations[].Instances[].InstanceId" --output text | xargs -r aws ec2 terminate-instances --instance-ids

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/.github/workflows/mirror.yml ---
name: Mirror Image

on:
  workflow_call:
    inputs:
      version:
        required: true
        type: string
  workflow_dispatch:
    inputs:
      version:
        description: "Image tag"
        required: true
        type: string

jobs:
  mirror:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
    steps:
      - name: configure aws credentials
        uses: aws-actions/configure-aws-credentials@v2.2.0
        with:
          role-to-assume: ${{ secrets.PROD_AWS_ROLE }}
          aws-region: us-east-1
      - uses: docker/login-action@v2
        with:
          registry: public.ecr.aws
      - uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - uses: akhilerm/tag-push-action@v2.1.0
        with:
          src: docker.io/supabase/postgres:${{ inputs.version }}
          dst: |
            public.ecr.aws/supabase/postgres:${{ inputs.version }}
            ghcr.io/supabase/postgres:${{ inputs.version }}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/.github/workflows/mirror-postgrest.yml ---
name: Mirror PostgREST

on:
  push:
    branches:
      - develop
    paths:
      - ".github/workflows/mirror-postgrest.yml"
      - "common.vars*"

jobs:
  version:
    runs-on: ubuntu-latest
    outputs:
      postgrest_release: ${{ steps.args.outputs.result }}
    steps:
      - uses: actions/checkout@v4
      - id: args
        uses: mikefarah/yq@master
        with:
          cmd: yq '.postgrest_release' 'ansible/vars.yml'

  mirror:
    needs:
      - version
    permissions:
      contents: read
      packages: write
      id-token: write
    uses: supabase/cli/.github/workflows/mirror-image.yml@main
    with:
      image: postgrest/postgrest:v${{ needs.version.outputs.postgrest_release }}
    secrets: inherit

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/.github/workflows/publish-nix-pgupgrade-bin-flake-version.yml ---
name: Publish nix pg_upgrade_bin flake version

on:
  workflow_dispatch:
    inputs:
      postgresVersion:
        description: 'Optional. Postgres version to publish against, i.e. 15.1.1.78'
        required: false

permissions:
  id-token: write
    
jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      postgres_versions: ${{ steps.set-versions.outputs.postgres_versions }}
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v3
      
      - uses: DeterminateSystems/nix-installer-action@main

      - name: Set PostgreSQL versions
        id: set-versions
        run: |
          VERSIONS=$(nix run nixpkgs#yq --  '.postgres_major[]' ansible/vars.yml | nix run nixpkgs#jq -- -R -s -c 'split("\n")[:-1]')
          echo "postgres_versions=$VERSIONS" >> $GITHUB_OUTPUT

  publish-staging:
    needs: prepare
    runs-on: ubuntu-latest
    strategy:
      matrix:
        postgres_version: ${{ fromJson(needs.prepare.outputs.postgres_versions) }}

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v3
      
      - uses: DeterminateSystems/nix-installer-action@main  

      - name: Grab release version
        id: process_release_version
        run: |
          VERSION=$(nix run nixpkgs#yq -- '.postgres_release["postgres'${{ matrix.postgres_version }}'"]' ansible/vars.yml)
          VERSION=$(echo $VERSION | tr -d '"')  # Remove any surrounding quotes
          if [[ "${{ inputs.postgresVersion }}" != "" ]]; then
            VERSION=${{ inputs.postgresVersion }}
          fi
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "major_version=$(echo $VERSION | cut -d'.' -f1)" >> "$GITHUB_OUTPUT"

      - name: Create a tarball containing the latest nix flake version
        working-directory: /tmp/
        run: |
          mkdir -p ${{ steps.process_release_version.outputs.major_version }}
          echo $GITHUB_SHA > ${{ steps.process_release_version.outputs.major_version }}/nix_flake_version
          tar -czvf pg_upgrade_bin.tar.gz ${{ steps.process_release_version.outputs.major_version }}

      - name: configure aws credentials - staging
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: ${{ secrets.DEV_AWS_ROLE }}
          aws-region: "us-east-1"

      - name: Upload pg_upgrade scripts to s3 staging
        run: |
          aws s3 cp /tmp/pg_upgrade_bin.tar.gz s3://${{ secrets.ARTIFACTS_BUCKET }}/upgrades/postgres/supabase-postgres-${{ steps.process_release_version.outputs.version }}/20.04.tar.gz

      - name: Slack Notification on Failure
        if: ${{ failure() }}
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_NOTIFICATIONS_WEBHOOK }}
          SLACK_USERNAME: 'gha-failures-notifier'
          SLACK_COLOR: 'danger'
          SLACK_MESSAGE: 'Publishing pg_upgrade binaries flake version failed'
          SLACK_FOOTER: ''

  publish-prod:
    runs-on: ubuntu-latest
    if: github.ref_name == 'develop' || contains( github.ref, 'release' )
    needs: prepare
    strategy:
      matrix:
        postgres_version: ${{ fromJson(needs.prepare.outputs.postgres_versions) }}

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v3

      - name: Grab release version
        id: process_release_version
        run: |
          VERSION=$(sudo nix run nixpkgs#yq -- '.postgres_release["postgres'${{ matrix.postgres_version }}'"]' ansible/vars.yml)
          VERSION=$(echo $VERSION | tr -d '"')  # Remove any surrounding quotes
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "major_version=$(echo $VERSION | cut -d'.' -f1)" >> "$GITHUB_OUTPUT"

      - name: Create a tarball containing the latest nix flake version
        working-directory: /tmp/
        run: |
          mkdir -p ${{ steps.process_release_version.outputs.major_version }}
          echo $GITHUB_SHA > ${{ steps.process_release_version.outputs.major_version }}/nix_flake_version
          tar -czvf pg_upgrade_bin.tar.gz ${{ steps.process_release_version.outputs.major_version }}

      - name: configure aws credentials - prod
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: ${{ secrets.PROD_AWS_ROLE }}
          aws-region: "us-east-1"
  
      - name: Upload pg_upgrade scripts to s3 prod
        run: |
          aws s3 cp /tmp/pg_upgrade_bin.tar.gz s3://${{ secrets.PROD_ARTIFACTS_BUCKET }}/upgrades/postgres/supabase-postgres-${{ steps.process_release_version.outputs.version }}/20.04.tar.gz

      - name: Slack Notification on Failure
        if: ${{ failure() }}
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_NOTIFICATIONS_WEBHOOK }}
          SLACK_USERNAME: 'gha-failures-notifier'
          SLACK_COLOR: 'danger'
          SLACK_MESSAGE: 'Publishing pg_upgrade binaries flake version failed'
          SLACK_FOOTER: ''

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/.github/workflows/test.yml ---
name: Test Database
on:
  push:
    branches:
      - develop
  pull_request:
  workflow_dispatch:
jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      postgres_versions: ${{ steps.set-versions.outputs.postgres_versions }}
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Clear Nix cache
        run: |
          sudo rm -rf /home/runner/.cache/nix

      - uses: DeterminateSystems/nix-installer-action@main
        with:
          extra-conf: |
            substituters = https://cache.nixos.org https://nix-postgres-artifacts.s3.amazonaws.com
            trusted-public-keys = nix-postgres-artifacts:dGZlQOvKcNEjvT7QEAJbcV6b6uk7VF/hWMjhYleiaLI=% cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY=
      - name: Set PostgreSQL versions
        id: set-versions
        run: |
          VERSIONS=$(nix run nixpkgs#yq -- '.postgres_major[]' ansible/vars.yml | nix run nixpkgs#jq -- -R -s -c "split(\"\n\")[:-1]")
          echo "postgres_versions=$VERSIONS" >> $GITHUB_OUTPUT
  build:
    needs: prepare
    strategy:
      matrix:
        postgres_version: ${{ fromJson(needs.prepare.outputs.postgres_versions) }}
        include:
          - runner: ubuntu-22.04
            arch: amd64
          - runner: ubuntu-22.04
            arch: arm64
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 180
    env:
      POSTGRES_PORT: 5478
      POSTGRES_PASSWORD: password
    steps:
      - uses: actions/checkout@v4
      - name: Clear Nix cache
        run: |
          sudo rm -rf /home/runner/.cache/nix
      - uses: DeterminateSystems/nix-installer-action@main
        with:
          extra-conf: |
            substituters = https://cache.nixos.org https://nix-postgres-artifacts.s3.amazonaws.com
            trusted-public-keys = nix-postgres-artifacts:dGZlQOvKcNEjvT7QEAJbcV6b6uk7VF/hWMjhYleiaLI=% cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY=
      - name: Set PostgreSQL version environment variable
        run: echo "POSTGRES_MAJOR_VERSION=${{ matrix.postgres_version }}" >> $GITHUB_ENV
      - name: Strip quotes from pg major and set env var
        run: |
          stripped_version=$(echo ${{ matrix.postgres_version }} | sed 's/^"\(.*\)"$/\1/')
          echo "PGMAJOR=$stripped_version" >> $GITHUB_ENV
      - name: Generate common-nix.vars.pkr.hcl
        run: |
          PG_VERSION=$(nix run nixpkgs#yq -- '.postgres_release["postgres'${{ matrix.postgres_version }}'"]' ansible/vars.yml)
          PG_VERSION=$(echo $PG_VERSION | tr -d '"')  # Remove any surrounding quotes
          echo 'postgres-version = "'$PG_VERSION'"' > common-nix.vars.pkr.hcl
          echo "" >> common-nix.vars.pkr.hcl
      - id: settings
        run: sed -r 's/(\s|\")+//g' common-nix.vars.pkr.hcl >> $GITHUB_OUTPUT
      - name: Generate args
        id: args
        run: |
          ARGS=$(nix run nixpkgs#yq -- 'to_entries | map(select(.value|type == "!!str")) | map(.key + "=" + .value) | join("\n")' ansible/vars.yml)
          echo "result<<EOF" >> $GITHUB_OUTPUT
          echo "$ARGS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - name: verify schema.sql is committed
        run: |
          nix run github:supabase/postgres/${{ github.sha }}#dbmate-tool -- --version ${{ env.PGMAJOR }}
          if ! git diff --exit-code --quiet migrations/schema-${{ env.PGMAJOR }}.sql; then
            echo "Detected changes in schema.sql:"
            git diff migrations/schema-${{ env.PGMAJOR }}.sql
            exit 1
          fi
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/.github/workflows/testinfra-nix.yml ---
name: Testinfra Integration Tests Nix

on:
  pull_request:
  workflow_dispatch:

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      postgres_versions: ${{ steps.set-versions.outputs.postgres_versions }}
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4
      
      - uses: DeterminateSystems/nix-installer-action@main

      - name: Set PostgreSQL versions
        id: set-versions
        run: |
          VERSIONS=$(nix run nixpkgs#yq --  '.postgres_major[]' ansible/vars.yml | nix run nixpkgs#jq --  -R -s -c 'split("\n")[:-1]')
          echo "postgres_versions=$VERSIONS" >> $GITHUB_OUTPUT

  test-ami-nix:
    needs: prepare
    strategy:
      fail-fast: false
      matrix:
        postgres_version: ${{ fromJson(needs.prepare.outputs.postgres_versions) }}
        include:
          - runner: arm-runner
            arch: arm64
            ubuntu_release: focal
            ubuntu_version: 20.04
            mcpu: neoverse-n1
    runs-on: ${{ matrix.runner }}    
    timeout-minutes: 150
    permissions:
      contents: write
      packages: write
      id-token: write

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - id: args
        uses: mikefarah/yq@master
        with:
          cmd: yq 'to_entries | map(select(.value|type == "!!str")) |  map(.key + "=" + .value) | join("\n")' 'ansible/vars.yml'

      - run: docker context create builders

      - uses: docker/setup-buildx-action@v3
        with:
          endpoint: builders

      - name: Generate random string
        id: random
        run: echo "random_string=$(openssl rand -hex 8)" >> $GITHUB_OUTPUT

      - name: Set PostgreSQL version environment variable
        run: echo "POSTGRES_MAJOR_VERSION=${{ matrix.postgres_version }}" >> $GITHUB_ENV
      

      - name: Generate common-nix.vars.pkr.hcl
        run: |
          PG_VERSION=$(sudo nix run nixpkgs#yq -- '.postgres_release["postgres'${{ matrix.postgres_version }}'"]' ansible/vars.yml)
          PG_VERSION=$(echo $PG_VERSION | tr -d '"')  # Remove any surrounding quotes
          echo 'postgres-version = "'$PG_VERSION'"' > common-nix.vars.pkr.hcl
          # Ensure there's a newline at the end of the file
          echo "" >> common-nix.vars.pkr.hcl
  
      - name: Build AMI stage 1
        run: |
          packer init amazon-arm64-nix.pkr.hcl
          GIT_SHA=${{github.sha}}
          packer build -var "git-head-version=${GIT_SHA}" -var "packer-execution-id=${GITHUB_RUN_ID}" -var-file="development-arm.vars.pkr.hcl" -var-file="common-nix.vars.pkr.hcl" -var "ansible_arguments=" -var "postgres-version=${{ steps.random.outputs.random_string }}" -var "region=ap-southeast-1" -var 'ami_regions=["ap-southeast-1"]' -var "force-deregister=true" -var "ansible_arguments=-e postgresql_major=${POSTGRES_MAJOR_VERSION}" amazon-arm64-nix.pkr.hcl
      
      - name: Build AMI stage 2
        run: |
          packer init stage2-nix-psql.pkr.hcl
          GIT_SHA=${{github.sha}}
          packer build -var "git-head-version=${GIT_SHA}" -var "packer-execution-id=${GITHUB_RUN_ID}" -var "postgres_major_version=${POSTGRES_MAJOR_VERSION}" -var-file="development-arm.vars.pkr.hcl" -var-file="common-nix.vars.pkr.hcl"  -var "postgres-version=${{ steps.random.outputs.random_string }}" -var "region=ap-southeast-1" -var 'ami_regions=["ap-southeast-1"]' -var "force-deregister=true" -var "git_sha=${GITHUB_SHA}"  stage2-nix-psql.pkr.hcl 

      - name: Run tests
        timeout-minutes: 10
        env:
          AMI_NAME: "supabase-postgres-${{ steps.random.outputs.random_string }}"
        run: |
          # TODO: use poetry for pkg mgmt
          pip3 install boto3 boto3-stubs[essential] docker ec2instanceconnectcli pytest pytest-testinfra[paramiko,docker] requests
          pytest -vv -s testinfra/test_ami_nix.py 
      
      - name: Cleanup resources on build cancellation
        if: ${{ cancelled() }}
        run: |
          aws ec2 --region ap-southeast-1 describe-instances --filters "Name=tag:packerExecutionId,Values=${GITHUB_RUN_ID}" --query "Reservations[].Instances[].InstanceId" --output text | xargs -r aws ec2 terminate-instances --region ap-southeast-1 --instance-ids

      - name: Cleanup resources after build
        if: ${{ always() }}
        run: |
          aws ec2 --region ap-southeast-1 describe-instances --filters "Name=tag:testinfra-run-id,Values=${GITHUB_RUN_ID}" --query "Reservations[].Instances[].InstanceId" --output text | xargs -r aws ec2 terminate-instances --region ap-southeast-1 --instance-ids || true

      - name: Cleanup AMIs
        if: always()
        run: |
          # Define AMI name patterns
          STAGE1_AMI_NAME="supabase-postgres-ci-ami-test-stage-1"
          STAGE2_AMI_NAME="${{ steps.random.outputs.random_string }}"
          
          # Function to deregister AMIs by name pattern
          deregister_ami_by_name() {
            local ami_name_pattern=$1
            local ami_ids=$(aws ec2 describe-images --region ap-southeast-1 --owners self --filters "Name=name,Values=${ami_name_pattern}" --query 'Images[*].ImageId' --output text)
            for ami_id in $ami_ids; do
              echo "Deregistering AMI: $ami_id"
              aws ec2 deregister-image --region ap-southeast-1 --image-id $ami_id
            done
          }
          
          # Deregister AMIs
          deregister_ami_by_name "$STAGE1_AMI_NAME"
          deregister_ami_by_name "$STAGE2_AMI_NAME"

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/.github/workflows/publish-migrations.yml ---
name: Release Migrations

on:
  push:
    branches:
      - develop

jobs:
  build:
    runs-on: [self-hosted, linux]
    timeout-minutes: 15
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v2

      - name: Merging migration files
        run: cat $(ls -1) > ../migration-output.sql
        working-directory: ${{ github.workspace }}/migrations/db/migrations

      - name: configure aws credentials - staging
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: ${{ secrets.DEV_AWS_ROLE }}
          aws-region: "ap-southeast-1"

      - name: Deploy to S3 staging
        shell: bash
        run: aws s3 sync migrations/db s3://$AWS_S3_BUCKET/migrations/db --delete
        env:
          AWS_S3_BUCKET: ${{ secrets.PG_INIT_SCRIPT_S3_BUCKET_STAGING }}

      - name: configure aws credentials - prod
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: ${{ secrets.PROD_AWS_ROLE }}
          aws-region: "ap-southeast-1"

      - name: Deploy to S3 prod
        shell: bash
        run: aws s3 sync migrations/db s3://$AWS_S3_BUCKET/migrations/db --delete
        env:
          AWS_S3_BUCKET: ${{ secrets.PG_INIT_SCRIPT_S3_BUCKET_PROD }}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/.github/workflows/nix-build.yml ---
name: Nix CI

on:
  push:
    branches:
      - develop
      - release/*
  pull_request:
  workflow_dispatch:

permissions:
  contents: read
  id-token: write    
    
jobs:
  build-run-image:
    strategy:
      fail-fast: false
      matrix:
        include:
          - runner: larger-runner-4cpu
            arch: amd64
          - runner: arm-runner
            arch: arm64
          - runner: macos-latest
            arch: arm64
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 180
    steps:

      - name: Check out code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref || github.ref }}
          fetch-depth: 0
          fetch-tags: true
      - name: aws-creds
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.DEV_AWS_ROLE }}
          aws-region: "us-east-1"
          output-credentials: true
          role-duration-seconds: 7200
      - name: write secret key
        # use python so we don't interpolate the secret into the workflow logs, in case of bugs
        run: |
          python -c "import os; file = open('nix-secret-key', 'w'); file.write(os.environ['NIX_SIGN_SECRET_KEY']); file.close()"
        env:
          NIX_SIGN_SECRET_KEY: ${{ secrets.NIX_SIGN_SECRET_KEY }}
      - name: Log in to Docker Hub
        if: matrix.runner != 'macos-latest' && matrix.runner != 'macos-13'
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      - name: Build psql bundle with nix
        if: matrix.runner != 'macos-latest' && matrix.runner != 'macos-13'
        run: docker build -t base_nix -f docker/nix/Dockerfile .
      - name: Run build psql bundle
        if: matrix.runner != 'macos-latest' && matrix.runner != 'macos-13'
        run:  |
          docker run -e AWS_ACCESS_KEY_ID=${{ env.AWS_ACCESS_KEY_ID }} \
                    -e AWS_SECRET_ACCESS_KEY=${{ env.AWS_SECRET_ACCESS_KEY }} \
                    -e AWS_SESSION_TOKEN=${{ env.AWS_SESSION_TOKEN }} \
                    base_nix bash -c "./workspace/docker/nix/build_nix.sh"
      - name: Build psql bundle on macos
        if: matrix.runner == 'macos-latest' || matrix.runner == 'macos-13'
        run: |
          curl --proto '=https' --tlsv1.2 -sSf -L https://install.determinate.systems/nix | sh -s -- install --no-confirm \
          --extra-conf "substituters = https://cache.nixos.org https://nix-postgres-artifacts.s3.amazonaws.com" \
          --extra-conf "trusted-public-keys = nix-postgres-artifacts:dGZlQOvKcNEjvT7QEAJbcV6b6uk7VF/hWMjhYleiaLI=% cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY="
          . /nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh
          cp ./docker/nix/build_nix.sh ./build_nix.sh
          sed -i '' '1s|^#!/bin/env bash|#!/usr/bin/env bash|' ./build_nix.sh
          chmod +x ./build_nix.sh
          ./build_nix.sh
        env:
          AWS_ACCESS_KEY_ID: ${{ env.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ env.AWS_SECRET_ACCESS_KEY }}
          AWS_SESSION_TOKEN: ${{ env.AWS_SESSION_TOKEN }}

    name: build psql bundle on ${{ matrix.arch }}
    

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/.github/workflows/check-shellscripts.yml ---
name: Check shell scripts

on:
  push:
    branches:
      - develop
  pull_request:
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Run ShellCheck
      uses: ludeeus/action-shellcheck@master
      env:
        SHELLCHECK_OPTS: -e SC2001 -e SC2002 -e SC2143
      with:
        scandir: './ansible/files/admin_api_scripts'

    - name: Run ShellCheck on pg_upgrade scripts
      uses: ludeeus/action-shellcheck@master
      env:
        SHELLCHECK_OPTS: -e SC2001 -e SC2002 -e SC2143
      with:
        scandir: './ansible/files/admin_api_scripts/pg_upgrade_scripts'

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/.github/workflows/dockerhub-release-matrix.yml ---
name: Release all major versions on Dockerhub

on:
  push:
    branches:
      - develop
      - release/*
    paths:
      - ".github/workflows/dockerhub-release-matrix.yml"
      - "ansible/vars.yml"
  workflow_dispatch:
 
jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      matrix_config: ${{ steps.set-matrix.outputs.matrix_config }}
    steps:
      - uses: DeterminateSystems/nix-installer-action@main
      - name: Checkout Repo
        uses: actions/checkout@v3
      - name: Generate build matrix
        id: set-matrix
        run: |
          nix run nixpkgs#nushell -- -c 'let versions = (open ansible/vars.yml | get postgres_major)
          let matrix = ($versions | each { |ver|
            let version = ($ver | str trim)
            let dockerfile = $"Dockerfile-($version)"
            if ($dockerfile | path exists) {
              {
                version: $version,
                dockerfile: $dockerfile
              }
            } else {
              null
            }
          } | compact)

          let matrix_config = {
            include: $matrix
          }

          $"matrix_config=($matrix_config | to json -r)" | save --append $env.GITHUB_OUTPUT'
  build:
    needs: prepare
    strategy:
      matrix: ${{ fromJson(needs.prepare.outputs.matrix_config) }}
    runs-on: ubuntu-latest
    outputs:
      build_args: ${{ steps.args.outputs.result }}
    steps:
      - uses: actions/checkout@v3
      - uses: DeterminateSystems/nix-installer-action@main
      - name: Set PostgreSQL version environment variable
        run: echo "POSTGRES_MAJOR_VERSION=${{ matrix.version }}" >> $GITHUB_ENV
      
      - id: args
        run: |
          nix run nixpkgs#nushell -- -c '
            open ansible/vars.yml 
            | items { |key value| {name: $key, item: $value} } 
            | where { |it| ($it.item | describe) == "string" } 
            | each { |it| $"($it.name)=($it.item)" } 
            | str join "\n" 
            | save --append $env.GITHUB_OUTPUT
          '    
  build_release_image:
    needs: [prepare, build]
    strategy:
      matrix:
        postgres: ${{ fromJson(needs.prepare.outputs.matrix_config).include }}
        arch: [amd64, arm64]
    runs-on: ${{ matrix.arch == 'amd64' && 'ubuntu-latest' || 'arm-runner' }}
    timeout-minutes: 180
    steps:
      - uses: actions/checkout@v3
      - uses: DeterminateSystems/nix-installer-action@main
      - run: docker context create builders
      - uses: docker/setup-buildx-action@v3
        with:
          endpoint: builders
      - uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      - name: Get image tag
        id: image
        run: |
          if [[ "${{ matrix.arch }}" == "arm64" ]]; then
            pg_version=$(sudo nix run nixpkgs#nushell -- -c '
              let version = "${{ matrix.postgres.version }}"
              let release_key = if ($version | str contains "orioledb") {
                $"postgresorioledb-17"
              } else {
                $"postgres($version)"
              }
              open ansible/vars.yml | get postgres_release | get $release_key | str trim
            ')
            echo "pg_version=supabase/postgres:$pg_version" >> $GITHUB_OUTPUT
          else
            pg_version=$(nix run nixpkgs#nushell -- -c '
              let version = "${{ matrix.postgres.version }}"
              let release_key = if ($version | str contains "orioledb") {
                $"postgresorioledb-17"
              } else {
                $"postgres($version)"
              }
              open ansible/vars.yml | get postgres_release | get $release_key | str trim
            ')
            echo "pg_version=supabase/postgres:$pg_version" >> $GITHUB_OUTPUT
          fi
      - id: build
        uses: docker/build-push-action@v5
        with:
          push: true
          build-args: |
            ${{ needs.build.outputs.build_args }}
          target: production
          tags: ${{ steps.image.outputs.pg_version }}_${{ matrix.arch }}
          platforms: linux/${{ matrix.arch }}
          cache-from: type=gha,scope=${{ github.ref_name }}-latest-${{ matrix.arch }}
          cache-to: type=gha,mode=max,scope=${{ github.ref_name }}-latest-${{ matrix.arch }}
          file: ${{ matrix.postgres.dockerfile }}
  merge_manifest:
    needs: [prepare, build, build_release_image]
    strategy:
      matrix:
        include: ${{ fromJson(needs.prepare.outputs.matrix_config).include }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: DeterminateSystems/nix-installer-action@main
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      - name: Get image tag
        id: get_version
        run: |
          nix run nixpkgs#nushell -- -c '
            let version = "${{ matrix.version }}"
            let release_key = if ($version | str contains "orioledb") {
              $"postgresorioledb-17"
            } else {
              $"postgres($version)"
            }
            let pg_version = (open ansible/vars.yml | get postgres_release | get $release_key | str trim)
            $"pg_version=supabase/postgres:($pg_version)" | save --append $env.GITHUB_OUTPUT
          '
      - name: Output version
        id: output_version
        run: |
          echo "result=${{ steps.get_version.outputs.pg_version }}" >> $GITHUB_OUTPUT
      - name: Collect versions
        id: collect_versions
        run: |
          echo "${{ steps.output_version.outputs.result }}" >> results.txt  # Append results
      - name: Upload Results Artifact
        uses: actions/upload-artifact@v4
        with:
          name: merge_results-${{ matrix.version }}
          path: results.txt
          if-no-files-found: warn
      - name: Merge multi-arch manifests
        run: |
          docker buildx imagetools create -t ${{ steps.get_version.outputs.pg_version }} \
          ${{ steps.get_version.outputs.pg_version }}_amd64 \
          ${{ steps.get_version.outputs.pg_version }}_arm64
  combine_results:
    needs: [prepare, merge_manifest]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: DeterminateSystems/nix-installer-action@main

      - name: Debug Input from Prepare
        run: |
          echo "Raw matrix_config output:"
          echo "${{ needs.prepare.outputs.matrix_config }}"
      - name: Get Versions from Matrix Config
        id: get_versions
        run: |
          nix run nixpkgs#nushell -- -c '
            # Parse the matrix configuration directly
            let matrix_config = (${{ toJson(needs.prepare.outputs.matrix_config) }} | from json)
      
            # Get versions directly from include array
            let versions = ($matrix_config.include | get version)
      
            echo "Versions: $versions"
      
            # Convert the versions to a comma-separated string
            let versions_str = ($versions | str join ",")
            $"versions=$versions_str" | save --append $env.GITHUB_ENV
          '
      - name: Download Results Artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: merge_results-*
      - name: Combine Results
        id: combine
        run: |
          nix run nixpkgs#nushell -- -c '
            # Get all results files and process them in one go
            let files = (ls **/results.txt | get name)
            echo $"Found files: ($files)"
            
            let matrix = {
              include: (
                $files
                | each { |file| open $file }          # Open each file
                | each { |content| $content | lines }  # Split into lines
                | flatten                             # Flatten the nested lists
                | where { |line| $line != "" }        # Filter empty lines
                | each { |line| 
                    # Extract just the version part after the last colon
                    let version = ($line | parse "supabase/postgres:{version}" | get version.0)
                    {version: $version}
                }
              )
            }
            
            let json_output = ($matrix | to json -r)  # -r for raw output
            echo $"Debug output: ($json_output)"
            
            $"matrix=($json_output)" | save --append $env.GITHUB_OUTPUT
          '
      - name: Debug Combined Results
        run: |
          echo "Combined Results: '${{ steps.combine.outputs.matrix }}'"
    outputs:
      matrix: ${{ steps.combine.outputs.matrix }}
  publish:
      needs: combine_results
      strategy:
        matrix: ${{ fromJson(needs.combine_results.outputs.matrix) }}
      uses: ./.github/workflows/mirror.yml
      with:
        version: ${{ matrix.version }}
      secrets: inherit

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/.github/workflows/ci.yml ---
name: Check merge requirements

on:
  pull_request:

jobs:
  check-release-version:
    timeout-minutes: 5
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v3

      - name: Load postgres_release values
        id: load_postgres_release
        uses: mikefarah/yq@master
        with:
          args: eval '.postgres_release' ansible/vars.yml
        # The output will be available as steps.load_postgres_release.outputs.stdout

      - name: Run checks
        run: |
          POSTGRES_RELEASES="${{ steps.load_postgres_release.outputs.stdout }}"

          # Iterate through each release
          for release in $(echo "$POSTGRES_RELEASES" | yq eval 'keys | .[]' -); do
            VERSION=$(echo "$POSTGRES_RELEASES" | yq eval ".\"$release\"" -)
            if [[ "$release" == "postgresorioledb-17" ]]; then
              # Check for suffix after -orioledb
              if [[ "$VERSION" =~ -orioledb(.*) ]]; then
                SUFFIX="${BASH_REMATCH[1]}"
                if [[ -n "$SUFFIX" ]]; then
                  echo "We no longer allow merging versions with suffixes after -orioledb."
                  exit 1
                fi
              fi
            else
              # Check for suffix after version digits
              if [[ "$VERSION" =~ ([0-9]+\.[0-9]+\.[0-9]+)(.*) ]]; then
                SUFFIX="${BASH_REMATCH[2]}"
                if [[ -n "$SUFFIX" ]]; then
                  echo "We no longer allow merging versions with suffixes after version $VERSION."
                  exit 1
                fi
              fi
            fi
          done

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/.github/workflows/publish-nix-pgupgrade-scripts.yml ---
name: Publish nix pg_upgrade_scripts

on:
  push:
    branches:
      - develop
      - release/*
    paths:
      - '.github/workflows/publish-nix-pgupgrade-scripts.yml'
      - 'ansible/vars.yml'
  workflow_dispatch:
    inputs:
      postgresVersion:
        description: 'Optional. Postgres version to publish against, i.e. 15.1.1.78'
        required: false

permissions:
  id-token: write
    
jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      postgres_versions: ${{ steps.set-versions.outputs.postgres_versions }}
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v3
      
      - uses: DeterminateSystems/nix-installer-action@main

      - name: Set PostgreSQL versions
        id: set-versions
        run: |
          VERSIONS=$(nix run nixpkgs#yq --  '.postgres_major[]' ansible/vars.yml | nix run nixpkgs#jq -- -R -s -c 'split("\n")[:-1]')
          echo "postgres_versions=$VERSIONS" >> $GITHUB_OUTPUT

  publish-staging:
    needs: prepare
    runs-on: ubuntu-latest
    strategy:
      matrix:
        postgres_version: ${{ fromJson(needs.prepare.outputs.postgres_versions) }}

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v3

      - uses: DeterminateSystems/nix-installer-action@main

      - name: Grab release version
        id: process_release_version
        run: |
          VERSION=$(nix run nixpkgs#yq -- '.postgres_release["postgres'${{ matrix.postgres_version }}'"]' ansible/vars.yml)
          VERSION=$(echo $VERSION | tr -d '"')  # Remove any surrounding quotes
          if [[ "${{ inputs.postgresVersion }}" != "" ]]; then
            VERSION=${{ inputs.postgresVersion }}
          fi
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"

      - name: Create a tarball containing pg_upgrade scripts
        run: |
          mkdir -p /tmp/pg_upgrade_scripts
          cp -r ansible/files/admin_api_scripts/pg_upgrade_scripts/* /tmp/pg_upgrade_scripts
          tar -czvf /tmp/pg_upgrade_scripts.tar.gz -C /tmp/ pg_upgrade_scripts

      - name: configure aws credentials - staging
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: ${{ secrets.DEV_AWS_ROLE }}
          aws-region: "us-east-1"

      - name: Upload pg_upgrade scripts to s3 staging
        run: |
          aws s3 cp /tmp/pg_upgrade_scripts.tar.gz s3://${{ secrets.ARTIFACTS_BUCKET }}/upgrades/postgres/supabase-postgres-${{ steps.process_release_version.outputs.version }}/pg_upgrade_scripts.tar.gz

      - name: Slack Notification on Failure
        if: ${{ failure() }}
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_NOTIFICATIONS_WEBHOOK }}
          SLACK_USERNAME: 'gha-failures-notifier'
          SLACK_COLOR: 'danger'
          SLACK_MESSAGE: 'Publishing pg_upgrade scripts failed'
          SLACK_FOOTER: ''
  publish-prod:
    needs: prepare
    runs-on: ubuntu-latest
    if: github.ref_name == 'develop' || contains( github.ref, 'release' )

    strategy:
      matrix:
        postgres_version: ${{ fromJson(needs.prepare.outputs.postgres_versions) }}


    steps:
      - name: Checkout Repo
        uses: actions/checkout@v3
      
      - uses: DeterminateSystems/nix-installer-action@main
  
      - name: Grab release version
        id: process_release_version
        run: |
          VERSION=$(nix run nixpkgs#yq -- '.postgres_release["postgres'${{ matrix.postgres_version }}'"]' ansible/vars.yml)
          VERSION=$(echo $VERSION | tr -d '"')  # Remove any surrounding quotes
          if [[ "${{ inputs.postgresVersion }}" != "" ]]; then
            VERSION=${{ inputs.postgresVersion }}
          fi
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"

      - name: Create a tarball containing pg_upgrade scripts
        run: |
          mkdir -p /tmp/pg_upgrade_scripts
          cp -r ansible/files/admin_api_scripts/pg_upgrade_scripts/* /tmp/pg_upgrade_scripts
          tar -czvf /tmp/pg_upgrade_scripts.tar.gz -C /tmp/ pg_upgrade_scripts

      - name: configure aws credentials - prod
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: ${{ secrets.PROD_AWS_ROLE }}
          aws-region: "us-east-1"
  
      - name: Upload pg_upgrade scripts to s3 prod
        run: |
          aws s3 cp /tmp/pg_upgrade_scripts.tar.gz s3://${{ secrets.PROD_ARTIFACTS_BUCKET }}/upgrades/postgres/supabase-postgres-${{ steps.process_release_version.outputs.version }}/pg_upgrade_scripts.tar.gz

      - name: Slack Notification on Failure
        if: ${{ failure() }}
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_NOTIFICATIONS_WEBHOOK }}
          SLACK_USERNAME: 'gha-failures-notifier'
          SLACK_COLOR: 'danger'
          SLACK_MESSAGE: 'Publishing pg_upgrade scripts failed'
          SLACK_FOOTER: ''

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/.github/PULL_REQUEST_TEMPLATE/extension_upgrade.md ---
## What kind of change does this PR introduce?

- upgrade _extension_ from _v0.0.0_ to _v0.0.0_

## Additional context

Add any other context or screenshots.

## Action Items

- [ ] **New extension releases** were Checked for any breaking changes
- [ ] **Extensions compatibility** Checked
    * Proceed to [extensions compatibility testing](#extensions-compatibility-testing), mark as done after everything is completed
- [ ] **Backup and Restore** Checked
    * Proceed to [backup testing](#backup-testing) while extensions are enabled
        - After every restore, re-run the tests specified at point [3.1](#extensions-compatibility-testing)

### Extensions compatibility testing

1. Enable every extension
    1. Check Postgres’ log output for any error messages while doing so
        1. This might unearth incompatibilities due to unsupported internal functions, missing libraries, or missing permissions
2. Disable every extension
    1. Check Postgres’ log output for any cleanup-related error messages
3. Re-enable each extension
    1. Run basic tests against the features they offer, e.g.:
        1. `pg_net` - execute HTTP requests
        2. `pg_graphql` - execute queries and mutations
        3. …to be filled in

### Backup Testing

Follow the testing steps steps for all the following cases:

- Pause on new Postgres version, restore on new Postgres version
- Pause on older Postgres version, restore on new Postgres version
- Run a single-file backup backup, restore the backup

#### Testing steps

1. Generate dummy data 
    * the ‘Countries’ or ‘Slack clone’ SQL editor snippets are decent datasets to work with, albeit limited
2. Save a db stats snapshot file
    * Do this by running `supa db-stats gather -p <project_ref>`
3. Backup the database, through pausing the project, or otherwise
4. Restore the backup, through unpausing the project or cli
5. Check the data has been recovered successfully
    1. Visual checks/navigating through the tables works
    2. Run `supa db-stats verify` against the project and the previously saved file
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/.github/PULL_REQUEST_TEMPLATE/default.md ---
## What kind of change does this PR introduce?

Bug fix, feature, docs update, ...

## What is the current behavior?

Please link any relevant issues here.

## What is the new behavior?

Feel free to include screenshots if it includes visual changes.

## Additional context

Add any other context or screenshots.
'''

