The below represents the folders and files from the root paths:
- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix

Each file is separated by '''--- followed by the file path and ending with ---.
File content begins immediately after its path and extends until the next '''---


*Directory: nix*
Total words: 21463

File structure:

nix/
    do-not-use-vendored-libraries.patch
    fix-cmake-install-path.patch
    init.sh
    nix.txt
    supabase-groonga.nix
    wal-g.nix
postgresql/
    15.nix
    16.nix
    17.nix
    default.nix
    generic.nix
    orioledb-16.nix
    orioledb-17.nix
    patches/
        less-is-more.patch
        locale-binary-path.patch
        paths-for-split-outputs.patch
        paths-with-postgresql-suffix.patch
        relative-to-symlinks-16+.patch
        relative-to-symlinks.patch
        socketdir-in-run-13+.patch
        socketdir-in-run.patch
        specify_pkglibdir_at_runtime.patch
tools/
    README.md
    dbmate-tool.sh.in
    local-infra-bootstrap.sh.in
    migrate-tool.sh.in
    postgresql_schema.sql
    run-client.sh.in
    run-replica.sh.in
    run-restore.sh.in
    run-server.sh.in
    sync-exts-versions.sh.in
docker/
    init.sh.in
overlays/
    cargo-pgrx-0-11-3.nix
    psql_16-oriole.nix
ext/
    0001-build-Allow-using-V8-from-system.patch
    age.nix
    gdal.nix
    hypopg.nix
    index_advisor.nix
    orioledb.nix
    pg-safeupdate.nix
    pg_backtrace.nix
    pg_cron.nix
    pg_graphql.nix
    pg_hashids.nix
    pg_jsonschema.nix
    pg_net.nix
    pg_partman.nix
    pg_plan_filter.nix
    pg_regress.nix
    pg_repack.nix
    pg_stat_monitor.nix
    pg_tle.nix
    pgaudit.nix
    pgjwt.nix
    pgmq.nix
    pgroonga.nix
    pgrouting.nix
    pgsodium.nix
    pgsql-http.nix
    pgtap.nix
    pgvector.nix
    pljava.nix
    plpgsql-check.nix
    plv8.nix
    postgis.nix
    rum.nix
    supautils.nix
    timescaledb-2.9.1.nix
    timescaledb.nix
    use-system-groonga.patch
    vault.nix
    wal2json.nix
    wrappers/
        default.nix
    mecab-naist-jdic/
        default.nix
    sfcgal/
        sfcgal.nix
docs/
    README.md
    adding-new-package.md
    adding-tests.md
    build-postgres.md
    docker.md
    migration-tests.md
    new-major-postgres.md
    nix-overlays.md
    receipt-files.md
    references.md
    start-client-server.md
    start-here.md
    update-extension.md
    use-direnv.md
cargo-pgrx/
    buildPgrxExtension.nix
    default.nix

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/init.sh ---
#!/bin/bash
# shellcheck shell=bash

export PGUSER=supabase_admin
export PGDATA=$PWD/postgres_data
export PGHOST=$PWD/postgres
export PGPORT=5432
export PGPASS=postgres
export LOG_PATH=$PGHOST/LOG
export PGDATABASE=testdb
export DATABASE_URL="postgresql:///$PGDATABASE?host=$PGHOST&port=$PGPORT"
mkdir -p $PGHOST
if [ ! -d $PGDATA ]; then
    echo 'Initializing postgresql database...'
    initdb $PGDATA --locale=C --username $PGUSER -A md5 --pwfile=<(echo $PGPASS) --auth=trust
    echo "listen_addresses='*'" >> $PGDATA/postgresql.conf
    echo "unix_socket_directories='$PGHOST'" >> $PGDATA/postgresql.conf
    echo "unix_socket_permissions=0700" >> $PGDATA/postgresql.conf
fi
chmod o-rwx $PGDATA

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/do-not-use-vendored-libraries.patch ---
Do not use vendored libraries

--- a/vendor/CMakeLists.txt
+++ b/vendor/CMakeLists.txt
@@ -14,10 +14,7 @@
 # License along with this library; if not, write to the Free Software
 # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 
 add_subdirectory(onigmo)
-add_subdirectory(mruby)
-add_subdirectory(mecab)
-add_subdirectory(message_pack)
 if(GRN_WITH_MRUBY)
   add_subdirectory(groonga-log)
 endif()
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/fix-cmake-install-path.patch ---
Fix CMake install path

--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1141,11 +1141,11 @@
 
 set(prefix "${CMAKE_INSTALL_PREFIX}")
 set(exec_prefix "\${prefix}")
-set(bindir "\${exec_prefix}/${CMAKE_INSTALL_BINDIR}")
-set(sbindir "\${exec_prefix}/${CMAKE_INSTALL_SBINDIR}")
-set(libdir "\${prefix}/${CMAKE_INSTALL_LIBDIR}")
-set(includedir "\${prefix}/${CMAKE_INSTALL_INCLUDEDIR}")
-set(datarootdir "\${prefix}/${CMAKE_INSTALL_DATAROOTDIR}")
+set(bindir "${CMAKE_INSTALL_FULL_BINDIR}")
+set(sbindir "${CMAKE_INSTALL_FULL_SBINDIR}")
+set(libdir "${CMAKE_INSTALL_FULL_LIBDIR}")
+set(includedir "${CMAKE_INSTALL_FULL_INCLUDEDIR}")
+set(datarootdir "${CMAKE_INSTALL_FULL_DATAROOTDIR}")
 set(datadir "\${datarootdir}")
 set(expanded_pluginsdir "${GRN_PLUGINS_DIR}")
 set(GRN_EXPANDED_DEFAULT_DOCUMENT_ROOT "${GRN_DEFAULT_DOCUMENT_ROOT}")
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/supabase-groonga.nix ---
{ lib, stdenv, cmake, fetchurl, kytea, msgpack-c, mecab, pkg-config, rapidjson
, testers, xxHash, zstd, postgresqlPackages, makeWrapper, suggestSupport ? false
, zeromq, libevent, openssl, lz4Support ? false, lz4, zlibSupport ? true, zlib
, writeShellScriptBin, callPackage }:
let mecab-naist-jdic = callPackage ./ext/mecab-naist-jdic { };
in stdenv.mkDerivation (finalAttrs: {
  pname = "supabase-groonga";
  version = "14.0.5";
  src = fetchurl {
    url =
      "https://packages.groonga.org/source/groonga/groonga-${finalAttrs.version}.tar.gz";
    hash = "sha256-y4UGnv8kK0z+br8wXpPf57NMXkdEJHcLCuTvYiubnIc=";
  };
  patches =
    [ ./fix-cmake-install-path.patch ./do-not-use-vendored-libraries.patch ];
  nativeBuildInputs = [ cmake pkg-config makeWrapper ];
  buildInputs = [ rapidjson xxHash zstd mecab kytea msgpack-c ]
    ++ lib.optionals lz4Support [ lz4 ] ++ lib.optional zlibSupport [ zlib ]
    ++ lib.optionals suggestSupport [ zeromq libevent ];
  cmakeFlags = [
    "-DWITH_MECAB=ON"
    "-DMECAB_DICDIR=${mecab-naist-jdic}/lib/mecab/dic/naist-jdic"
    "-DMECAB_CONFIG=${mecab}/bin/mecab-config"
    "-DENABLE_MECAB_TOKENIZER=ON"
    "-DMECAB_INCLUDE_DIR=${mecab}/include"
    "-DMECAB_LIBRARY=${mecab}/lib/libmecab.so"
    "-DGROONGA_ENABLE_TOKENIZER_MECAB=YES"
    "-DGRN_WITH_MECAB=YES"
  ];
  preConfigure = ''
    export MECAB_DICDIR=${mecab-naist-jdic}/lib/mecab/dic/naist-jdic
    echo "MeCab dictionary directory is: $MECAB_DICDIR"
  '';
  buildPhase = ''
    cmake --build . -- VERBOSE=1
    grep -i mecab CMakeCache.txt || (echo "MeCab not detected in CMake cache" && exit 1)
    echo "CMake cache contents related to MeCab:"
    grep -i mecab CMakeCache.txt
  '';

  # installPhase = ''
  #   mkdir -p $out/bin $out/lib/groonga/plugins
  #   cp -r lib/groonga/plugins/* $out/lib/groonga/plugins
  #   cp -r bin/* $out/bin
  #   echo "Installed Groonga plugins:"
  #   ls -l $out/lib/groonga/plugins
  # '';

  postInstall = ''
    echo "Searching for MeCab-related files:"
    find $out -name "*mecab*"

    echo "Checking Groonga plugins directory:"
    ls -l $out/lib/groonga/plugins

    echo "Wrapping Groonga binary:"
    wrapProgram $out/bin/groonga \
      --set GRN_PLUGINS_DIR $out/lib/groonga/plugins 

  '';
  env.NIX_CFLAGS_COMPILE =
    lib.optionalString zlibSupport "-I${zlib.dev}/include";

  meta = with lib; {
    homepage = "https://groonga.org/";
    description = "Open-source fulltext search engine and column store";
    license = licenses.lgpl21;
    platforms = platforms.all;
    longDescription = ''
      Groonga is an open-source fulltext search engine and column store.
      It lets you write high-performance applications that requires fulltext search.
    '';
  };
})
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/wal-g.nix ---
{ lib
, buildGoModule
, fetchFromGitHub
, brotli
, libsodium
, installShellFiles
,
}:

let
  walGCommon = { version, vendorHash, sha256, majorVersion }:
    buildGoModule rec {
      pname = "wal-g-${majorVersion}";
      inherit version;

      src = fetchFromGitHub {
        owner = "wal-g";
        repo = "wal-g";
        rev = "v${version}";
        inherit sha256;
      };

      inherit vendorHash;

      nativeBuildInputs = [ installShellFiles ];

      buildInputs = [
        brotli
        libsodium
      ];

      subPackages = [ "main/pg" ];

      tags = [
        "brotli"
        "libsodium"
      ];

      ldflags = [
        "-s"
        "-w"
        "-X github.com/wal-g/wal-g/cmd/pg.walgVersion=${version}"
        "-X github.com/wal-g/wal-g/cmd/pg.gitRevision=${src.rev}"
      ];

      postInstall = ''
        mv $out/bin/pg $out/bin/wal-g-${majorVersion}
        
        # Create version-specific completions
        mkdir -p $out/share/bash-completion/completions
        $out/bin/wal-g-${majorVersion} completion bash > $out/share/bash-completion/completions/wal-g-${majorVersion}
        
        mkdir -p $out/share/zsh/site-functions
        $out/bin/wal-g-${majorVersion} completion zsh > $out/share/zsh/site-functions/_wal-g-${majorVersion}
        
      '';

      meta = with lib; {
        homepage = "https://github.com/wal-g/wal-g";
        license = licenses.asl20;
        description = "Archival restoration tool for PostgreSQL";
        mainProgram = "wal-g-${majorVersion}";
      };
    };
in
{
  # wal-g v2.0.1
  wal-g-2 = walGCommon {
    version = "2.0.1";
    sha256 = "sha256-5mwA55aAHwEFabGZ6c3pi8NLcYofvoe4bb/cFj7NWok=";
    vendorHash = "sha256-BbQuY6r30AkxlCZjY8JizaOrqEBdv7rIQet9KQwYB/g=";
    majorVersion = "2";
  };

  # wal-g v3.0.5
  wal-g-3 = walGCommon {
    version = "3.0.5";
    sha256 = "sha256-wVr0L2ZXMuEo6tc2ajNzPinVQ8ZVzNOSoaHZ4oFsA+U=";
    vendorHash = "sha256-YDLAmRfDl9TgbabXj/1rxVQ052NZDg3IagXVTe5i9dw=";
    majorVersion = "3";
  };
}
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/16.nix ---
import ./generic.nix {
  version = "16.3";
  hash = "sha256-Mxlj1dPcTK9CFqBJ+kC2bWvLjHMGFYWUEblRh2TmBYU=";
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/17.nix ---
import ./generic.nix {
  version = "17.4";
  hash = "sha256-xGBbc/6hGWNAZpn5Sblm5dFzp+4Myu+JON7AyoqZX+c=";
}
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/15.nix ---
import ./generic.nix {
  version = "15.8";
  hash = "sha256-RANRX5pp7rPv68mPMLjGlhIr/fiV6Ss7I/W452nty2o=";
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/orioledb-16.nix ---
import ./generic.nix {
  version = "16_31";
  hash = "sha256-29uHUACwZKh8e4zJ9tWzEhLNjEuh6P31KbpxnMEhtuI=";
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/orioledb-17.nix ---
import ./generic.nix {
  version = "17_5";
  hash = "sha256-OgXLpFanNp+ngPFKyCEDUFvIEWQ9nK/1csUO9lVTXaQ=";
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/default.nix ---
self:
let
  versions = {
    postgresql_15 = ./15.nix;
    postgresql_16 = ./16.nix;
    postgresql_17 = ./17.nix;
    postgresql_orioledb-16 = ./orioledb-16.nix;
    postgresql_orioledb-17 = ./orioledb-17.nix;
  };
  mkAttributes = jitSupport:
    self.lib.mapAttrs' (version: path:
      let
        attrName = if jitSupport then "${version}_jit" else version;
      in
      self.lib.nameValuePair attrName (import path {
        inherit jitSupport self;
      })
    ) versions;
in
# variations without and with JIT
(mkAttributes false) // (mkAttributes true)

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/generic.nix ---
let

  generic =
      # adapted from the nixpkgs postgresql package
      # dependencies
      { stdenv, lib, fetchurl, fetchpatch, makeWrapper
      , glibc, zlib, readline, openssl, icu, lz4, zstd, systemd, libossp_uuid
      , pkg-config, libxml2, tzdata, libkrb5, substituteAll, darwin
      , linux-pam
      #orioledb specific
      , perl, bison, flex, docbook_xsl, docbook_xml_dtd_45, docbook_xsl_ns, libxslt

      # This is important to obtain a version of `libpq` that does not depend on systemd.
      , systemdSupport ? lib.meta.availableOn stdenv.hostPlatform systemd && !stdenv.hostPlatform.isStatic
      , enableSystemd ? null
      , gssSupport ? with stdenv.hostPlatform; !isWindows && !isStatic

      # for postgresql.pkgs
      , self, newScope, buildEnv

      # source specification
      , version, hash, muslPatches ? {}

      # for tests
      , testers

      # JIT
      , jitSupport
      , nukeReferences, patchelf, llvmPackages

      # PL/Python
      , pythonSupport ? false
      , python3

      # detection of crypt fails when using llvm stdenv, so we add it manually
      # for <13 (where it got removed: https://github.com/postgres/postgres/commit/c45643d618e35ec2fe91438df15abd4f3c0d85ca)
      , libxcrypt
    } @args:
  let
    atLeast = lib.versionAtLeast version;
    olderThan = lib.versionOlder version;
    lz4Enabled = atLeast "14";
    zstdEnabled = atLeast "15";

    systemdSupport' = if enableSystemd == null then systemdSupport else (lib.warn "postgresql: argument enableSystemd is deprecated, please use systemdSupport instead." enableSystemd);

    pname = "postgresql";

    stdenv' = if jitSupport then llvmPackages.stdenv else stdenv;
  in stdenv'.mkDerivation (finalAttrs: {
    inherit version;
    pname = pname + lib.optionalString jitSupport "-jit";

    src = if (builtins.match "[0-9][0-9]_.*" version != null) then
      fetchurl {
        url = "https://github.com/orioledb/postgres/archive/refs/tags/patches${version}.tar.gz";
        inherit hash;
      }
    else
      fetchurl {
        url = "mirror://postgresql/source/v${version}/${pname}-${version}.tar.bz2";
        inherit hash;
      };

    hardeningEnable = lib.optionals (!stdenv'.cc.isClang) [ "pie" ];

    outputs = [ "out" "lib" ];
    setOutputFlags = false; # $out retains configureFlags :-/

    buildInputs = [
      zlib
      readline
      openssl
      (libxml2.override {python = python3;})
      icu
    ]
      ++ lib.optionals (olderThan "13") [ libxcrypt ]
      ++ lib.optionals jitSupport [ llvmPackages.llvm ]
      ++ lib.optionals lz4Enabled [ lz4 ]
      ++ lib.optionals zstdEnabled [ zstd ]
      ++ lib.optionals systemdSupport' [ systemd ]
      ++ lib.optionals pythonSupport [ python3 ]
      ++ lib.optionals gssSupport [ libkrb5 ]
      ++ lib.optionals stdenv'.isLinux [ linux-pam ]
      ++ lib.optionals (!stdenv'.isDarwin) [ libossp_uuid ]
      ++ lib.optionals (builtins.match "[0-9][0-9]_.*" version != null) [ 
        perl bison flex docbook_xsl docbook_xml_dtd_45 docbook_xsl_ns libxslt
      ];

    nativeBuildInputs = [
      makeWrapper
      pkg-config
    ]
      ++ lib.optionals jitSupport [ llvmPackages.llvm.dev nukeReferences patchelf ];

    enableParallelBuilding = true;

    separateDebugInfo = true;

    buildFlags = [ "world-bin" ];

    # Makes cross-compiling work when xml2-config can't be executed on the host.
    # Fixed upstream in https://github.com/postgres/postgres/commit/0bc8cebdb889368abdf224aeac8bc197fe4c9ae6
    env.NIX_CFLAGS_COMPILE = lib.optionalString (olderThan "13") "-I${libxml2.dev}/include/libxml2";

    configureFlags = [
      "--with-openssl"
      "--with-libxml"
      "--with-icu"
      "--sysconfdir=/etc"
      "--libdir=$(lib)/lib"
      "--with-system-tzdata=${tzdata}/share/zoneinfo"
      "--enable-debug"
      (lib.optionalString systemdSupport' "--with-systemd")
      (if stdenv'.isDarwin then "--with-uuid=e2fs" else "--with-ossp-uuid")
    ] ++ lib.optionals lz4Enabled [ "--with-lz4" ]
      ++ lib.optionals zstdEnabled [ "--with-zstd" ]
      ++ lib.optionals gssSupport [ "--with-gssapi" ]
      ++ lib.optionals pythonSupport [ "--with-python" ]
      ++ lib.optionals jitSupport [ "--with-llvm" ]
      ++ lib.optionals stdenv'.isLinux [ "--with-pam" ];

    patches = [
      (if atLeast "16" then ./patches/relative-to-symlinks-16+.patch else ./patches/relative-to-symlinks.patch)
      ./patches/less-is-more.patch
      ./patches/paths-for-split-outputs.patch
      ./patches/specify_pkglibdir_at_runtime.patch
      ./patches/paths-with-postgresql-suffix.patch

      (substituteAll {
        src = ./patches/locale-binary-path.patch;
        locale = "${if stdenv.isDarwin then darwin.adv_cmds else lib.getBin stdenv.cc.libc}/bin/locale";
      })
    ] ++ lib.optionals stdenv'.hostPlatform.isMusl (
      # Using fetchurl instead of fetchpatch on purpose: https://github.com/NixOS/nixpkgs/issues/240141
      map fetchurl (lib.attrValues muslPatches)
    ) ++ lib.optionals stdenv'.isLinux  [
      (if atLeast "13" then ./patches/socketdir-in-run-13+.patch else ./patches/socketdir-in-run.patch)
    ];

    installTargets = [ "install-world-bin" ];

    postPatch = ''
      # Hardcode the path to pgxs so pg_config returns the path in $out
      substituteInPlace "src/common/config_info.c" --subst-var out
    '' + lib.optionalString jitSupport ''
        # Force lookup of jit stuff in $out instead of $lib
        substituteInPlace src/backend/jit/jit.c --replace pkglib_path \"$out/lib\"
        substituteInPlace src/backend/jit/llvm/llvmjit.c --replace pkglib_path \"$out/lib\"
        substituteInPlace src/backend/jit/llvm/llvmjit_inline.cpp --replace pkglib_path \"$out/lib\"
    '';

    postInstall =
      ''
        moveToOutput "lib/pgxs" "$out" # looks strange, but not deleting it
        moveToOutput "lib/libpgcommon*.a" "$out"
        moveToOutput "lib/libpgport*.a" "$out"
        moveToOutput "lib/libecpg*" "$out"

        # Prevent a retained dependency on gcc-wrapper.
        substituteInPlace "$out/lib/pgxs/src/Makefile.global" --replace ${stdenv'.cc}/bin/ld ld

        if [ -z "''${dontDisableStatic:-}" ]; then
          # Remove static libraries in case dynamic are available.
          for i in $out/lib/*.a $lib/lib/*.a; do
            name="$(basename "$i")"
            ext="${stdenv'.hostPlatform.extensions.sharedLibrary}"
            if [ -e "$lib/lib/''${name%.a}$ext" ] || [ -e "''${i%.a}$ext" ]; then
              rm "$i"
            fi
          done
        fi
      '' + lib.optionalString jitSupport ''
        # Move the bitcode and libllvmjit.so library out of $lib; otherwise, every client that
        # depends on libpq.so will also have libLLVM.so in its closure too, bloating it
        moveToOutput "lib/bitcode" "$out"
        moveToOutput "lib/llvmjit*" "$out"

        # In the case of JIT support, prevent a retained dependency on clang-wrapper
        substituteInPlace "$out/lib/pgxs/src/Makefile.global" --replace ${stdenv'.cc}/bin/clang clang
        nuke-refs $out/lib/llvmjit_types.bc $(find $out/lib/bitcode -type f)

        # Stop out depending on the default output of llvm
        substituteInPlace $out/lib/pgxs/src/Makefile.global \
          --replace ${llvmPackages.llvm.out}/bin "" \
          --replace '$(LLVM_BINPATH)/' ""

        # Stop out depending on the -dev output of llvm
        substituteInPlace $out/lib/pgxs/src/Makefile.global \
          --replace ${llvmPackages.llvm.dev}/bin/llvm-config llvm-config \
          --replace -I${llvmPackages.llvm.dev}/include ""

        ${lib.optionalString (!stdenv'.isDarwin) ''
          # Stop lib depending on the -dev output of llvm
          rpath=$(patchelf --print-rpath $out/lib/llvmjit.so)
          nuke-refs -e $out $out/lib/llvmjit.so
          # Restore the correct rpath
          patchelf $out/lib/llvmjit.so --set-rpath "$rpath"
        ''}
      '';

    postFixup = lib.optionalString (!stdenv'.isDarwin && stdenv'.hostPlatform.libc == "glibc")
      ''
        # initdb needs access to "locale" command from glibc.
        wrapProgram $out/bin/initdb --prefix PATH ":" ${glibc.bin}/bin
      '';

    doCheck = !stdenv'.isDarwin;
    # autodetection doesn't seem to able to find this, but it's there.
    checkTarget = "check";

    disallowedReferences = [ stdenv'.cc ];

    passthru = let
      this = self.callPackage generic args;
      jitToggle = this.override {
        jitSupport = !jitSupport;
      };
    in
    {
      psqlSchema = lib.versions.major version;

      withJIT = if jitSupport then this else jitToggle;
      withoutJIT = if jitSupport then jitToggle else this;

      dlSuffix = if olderThan "16" then ".so" else stdenv.hostPlatform.extensions.sharedLibrary;

      pkgs = let
        scope = {
          inherit jitSupport;
          inherit (llvmPackages) llvm;
          postgresql = this;
          stdenv = stdenv';
        };
        newSelf = self // scope;
        newSuper = { callPackage = newScope (scope // this.pkgs); };
      in import ./ext newSelf newSuper;

      withPackages = postgresqlWithPackages {
                       inherit makeWrapper buildEnv;
                       postgresql = this;
                     }
                     this.pkgs;

      tests = {
        postgresql-wal-receiver = import ../../../../nixos/tests/postgresql-wal-receiver.nix {
          inherit (stdenv) system;
          pkgs = self;
          package = this;
        };
        pkg-config = testers.testMetaPkgConfig finalAttrs.finalPackage;
      } // lib.optionalAttrs jitSupport {
        postgresql-jit = import ../../../../nixos/tests/postgresql-jit.nix {
          inherit (stdenv) system;
          pkgs = self;
          package = this;
        };
      };
    };

    meta = with lib; {
      homepage    = "https://www.postgresql.org";
      description = "Powerful, open source object-relational database system";
      license     = licenses.postgresql;
      changelog   = "https://www.postgresql.org/docs/release/${finalAttrs.version}/";
      maintainers = with maintainers; [ thoughtpolice danbst globin ivan ma27 wolfgangwalther ];
      pkgConfigModules = [ "libecpg" "libecpg_compat" "libpgtypes" "libpq" ];
      platforms   = platforms.unix;

      # JIT support doesn't work with cross-compilation. It is attempted to build LLVM-bytecode
      # (`%.bc` is the corresponding `make(1)`-rule) for each sub-directory in `backend/` for
      # the JIT apparently, but with a $(CLANG) that can produce binaries for the build, not the
      # host-platform.
      #
      # I managed to get a cross-build with JIT support working with
      # `depsBuildBuild = [ llvmPackages.clang ] ++ buildInputs`, but considering that the
      # resulting LLVM IR isn't platform-independent this doesn't give you much.
      # In fact, I tried to test the result in a VM-test, but as soon as JIT was used to optimize
      # a query, postgres would coredump with `Illegal instruction`.
      broken = (jitSupport && stdenv.hostPlatform != stdenv.buildPlatform)
        # Allmost all tests fail FATAL errors for v12 and v13
        || (jitSupport && stdenv.hostPlatform.isMusl && olderThan "14");
    };
  });

  postgresqlWithPackages = { postgresql, makeWrapper, buildEnv }: pkgs: f: buildEnv {
    name = "postgresql-and-plugins-${postgresql.version}";
    paths = f pkgs ++ [
        postgresql
        postgresql.lib
        #TODO RM postgresql.man   # in case user installs this into environment
    ];
    nativeBuildInputs = [ makeWrapper ];


    # We include /bin to ensure the $out/bin directory is created, which is
    # needed because we'll be removing the files from that directory in postBuild
    # below. See #22653
    pathsToLink = ["/" "/bin"];

    # Note: the duplication of executables is about 4MB size.
    # So a nicer solution was patching postgresql to allow setting the
    # libdir explicitly.
    postBuild = ''
      mkdir -p $out/bin
      rm $out/bin/{pg_config,postgres,pg_ctl}
      cp --target-directory=$out/bin ${postgresql}/bin/{postgres,pg_config,pg_ctl}
      wrapProgram $out/bin/postgres --set NIX_PGLIBDIR $out/lib
    '';

    passthru.version = postgresql.version;
    passthru.psqlSchema = postgresql.psqlSchema;
  };

in
# passed by <major>.nix
versionArgs:
# passed by default.nix
{ self, ... } @defaultArgs:
self.callPackage generic (defaultArgs // versionArgs)

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/patches/paths-with-postgresql-suffix.patch ---
Nix outputs put the `name' in each store path like
/nix/store/...-<name>. This was confusing the Postgres make script
because it thought its data directory already had postgresql in its
directory. This lead to Postgres installing all of its fils in
$out/share. To fix this, we just look for postgres or psql in the part
after the / using make's notdir.

---
--- a/src/Makefile.global.in
+++ b/src/Makefile.global.in
@@ -102,15 +102,15 @@ datarootdir := @datarootdir@
 bindir := @bindir@
 
 datadir := @datadir@
-ifeq "$(findstring pgsql, $(datadir))" ""
-ifeq "$(findstring postgres, $(datadir))" ""
+ifeq "$(findstring pgsql, $(notdir $(datadir)))" ""
+ifeq "$(findstring postgres, $(notdir $(datadir)))" ""
 override datadir := $(datadir)/postgresql
 endif
 endif
 
 sysconfdir := @sysconfdir@
-ifeq "$(findstring pgsql, $(sysconfdir))" ""
-ifeq "$(findstring postgres, $(sysconfdir))" ""
+ifeq "$(findstring pgsql, $(notdir $(sysconfdir)))" ""
+ifeq "$(findstring postgres, $(notdir $(sysconfdir)))" ""
 override sysconfdir := $(sysconfdir)/postgresql
 endif
 endif
@@ -136,8 +136,8 @@ endif
 mandir := @mandir@
 
 docdir := @docdir@
-ifeq "$(findstring pgsql, $(docdir))" ""
-ifeq "$(findstring postgres, $(docdir))" ""
+ifeq "$(findstring pgsql, $(notdir $(docdir)))" ""
+ifeq "$(findstring postgres, $(notdir $(docdir)))" ""
 override docdir := $(docdir)/postgresql
 endif
 endif

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/patches/less-is-more.patch ---
--- a/src/include/fe_utils/print.h
+++ b/src/include/fe_utils/print.h
@@ -18,7 +18,7 @@
 
 /* This is not a particularly great place for this ... */
 #ifndef __CYGWIN__
-#define DEFAULT_PAGER "more"
+#define DEFAULT_PAGER "less"
 #else
 #define DEFAULT_PAGER "less"
 #endif

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/patches/paths-for-split-outputs.patch ---
--- a/src/common/config_info.c
+++ b/src/common/config_info.c
@@ -118,7 +118,7 @@
 	i++;

 	configdata[i].name = pstrdup("PGXS");
+	strlcpy(path, "@out@/lib", sizeof(path));
-	get_pkglib_path(my_exec_path, path);
 	strlcat(path, "/pgxs/src/makefiles/pgxs.mk", sizeof(path));
 	cleanup_path(path);
 	configdata[i].setting = pstrdup(path);

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/patches/relative-to-symlinks.patch ---
On NixOS we *want* stuff relative to symlinks.
---
--- a/src/common/exec.c
+++ b/src/common/exec.c
@@ -218,6 +218,8 @@
 static int
 resolve_symlinks(char *path)
 {
+	return 0;
+
 #ifdef HAVE_READLINK
 	struct stat buf;
 	char		orig_wd[MAXPGPATH],

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/patches/socketdir-in-run-13+.patch ---
--- a/src/include/pg_config_manual.h
+++ b/src/include/pg_config_manual.h
@@ -201,7 +201,7 @@
  * support them yet.
  */
 #ifndef WIN32
-#define DEFAULT_PGSOCKET_DIR  "/tmp"
+#define DEFAULT_PGSOCKET_DIR  "/run/postgresql"
 #else
 #define DEFAULT_PGSOCKET_DIR ""
 #endif

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/patches/specify_pkglibdir_at_runtime.patch ---
--- a/src/port/path.c
+++ b/src/port/path.c
@@ -714,7 +714,11 @@
 void
 get_lib_path(const char *my_exec_path, char *ret_path)
 {
-	make_relative_path(ret_path, LIBDIR, PGBINDIR, my_exec_path);
+	char const * const nix_pglibdir = getenv("NIX_PGLIBDIR");
+	if(nix_pglibdir == NULL)
+		make_relative_path(ret_path, LIBDIR, PGBINDIR, my_exec_path);
+	else
+		make_relative_path(ret_path, nix_pglibdir, PGBINDIR, my_exec_path);
 }
 
 /*
@@ -723,7 +727,11 @@
 void
 get_pkglib_path(const char *my_exec_path, char *ret_path)
 {
-	make_relative_path(ret_path, PKGLIBDIR, PGBINDIR, my_exec_path);
+	char const * const nix_pglibdir = getenv("NIX_PGLIBDIR");
+	if(nix_pglibdir == NULL)
+		make_relative_path(ret_path, PKGLIBDIR, PGBINDIR, my_exec_path);
+	else
+		make_relative_path(ret_path, nix_pglibdir, PGBINDIR, my_exec_path);
 }
 
 /*

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/patches/relative-to-symlinks-16+.patch ---
On NixOS we *want* stuff relative to symlinks.
---
--- a/src/common/exec.c
+++ b/src/common/exec.c
@@ -238,6 +238,8 @@
 static int
 normalize_exec_path(char *path)
 {
+	return 0;
+
 	/*
 	 * We used to do a lot of work ourselves here, but now we just let
 	 * realpath(3) do all the heavy lifting.

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/patches/socketdir-in-run.patch ---
--- a/src/include/pg_config_manual.h
+++ b/src/include/pg_config_manual.h
@@ -179,7 +179,7 @@
  * here's where to twiddle it.  You can also override this at runtime
  * with the postmaster's -k switch.
  */
-#define DEFAULT_PGSOCKET_DIR  "/tmp"
+#define DEFAULT_PGSOCKET_DIR  "/run/postgresql"
 
 /*
  * This is the default event source for Windows event log.

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/patches/locale-binary-path.patch ---
--- a/src/backend/commands/collationcmds.c
+++ b/src/backend/commands/collationcmds.c
@@ -611,7 +611,7 @@ pg_import_system_collations(PG_FUNCTION_ARGS)
 		aliases = (CollAliasData *) palloc(maxaliases * sizeof(CollAliasData));
 		naliases = 0;
 
-		locale_a_handle = OpenPipeStream("locale -a", "r");
+		locale_a_handle = OpenPipeStream("@locale@ -a", "r");
 		if (locale_a_handle == NULL)
 			ereport(ERROR,
 					(errcode_for_file_access(),

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/tools/run-replica.sh.in ---
#!/usr/bin/env bash
# shellcheck shell=bash

[ ! -z "$DEBUG" ] && set -x

# first argument should be '15' or '16' for the version
if [ "$1" == "15" ]; then
    echo "Starting server for PSQL 15"
    PSQL15=@PSQL15_BINDIR@
    BINDIR="$PSQL15"
elif [ "$1" == "16" ]; then
    echo "Starting server for PSQL 16"
    PSQL16=@PSQL16_BINDIR@
    BINDIR="$PSQL16"
elif [ "$1" == "orioledb-16" ]; then
    echo "Starting server for PSQL ORIOLEDB 16"
    PSQLORIOLEDB16=@PSQLORIOLEDB16_BINDIR@
    BINDIR="$PSQLORIOLEDB16"
else
    echo "Please provide a valid Postgres version (15, 16 or orioledb-16)"
    exit 1
fi

export PATH=$BINDIR/bin:$PATH

PGSQL_SUPERUSER=@PGSQL_SUPERUSER@
MASTER_PORTNO="$2"
REPLICA_PORTNO="$3"
REPLICA_SLOT="replica_$RANDOM"
DATDIR=$(mktemp -d)
mkdir -p "$DATDIR"

echo "NOTE: runing pg_basebackup for server on port $MASTER_PORTNO"
echo "NOTE: using replica slot $REPLICA_SLOT"

pg_basebackup -p "$MASTER_PORTNO" -h localhost -U "${PGSQL_SUPERUSER}" -X stream -C -S "$REPLICA_SLOT" -v -R -D "$DATDIR"

echo "NOTE: using port $REPLICA_PORTNO for replica"
echo "NOTE: using temporary directory $DATDIR for data, which will not be removed"
echo "NOTE: you are free to re-use this data directory at will"
echo

exec postgres -p "$REPLICA_PORTNO" -D "$DATDIR" -k /tmp

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/tools/run-server.sh.in ---
#!@SHELL_PATH@
# shellcheck shell=bash
[ ! -z "$DEBUG" ] && set -x

# Default values
SKIP_MIGRATIONS=false
PSQL_USER="postgres"
MIGRATION_FILE=""
DAEMONIZE=false
GETKEY_SCRIPT=""

# Function to display help
print_help() {
    echo "Usage: start-postgres-server [options] VERSION [PORT]"
    echo
    echo "Options:"
    echo "  --skip-migrations        Skip running migrations and SQL statements"
    echo "  --migration-file FILE    Provide a custom migration script"
    echo "  --user USER             Specify the user/role to use (default: postgres)"
    echo "  --getkey-script SCRIPT   Provide a custom path to the PGSODIUM_GETKEY_SCRIPT"
    echo "  -h, --help              Show this help message"
    echo
    echo "VERSION must be one of: 15, orioledb-17"
    echo "PORT is optional (default: @PGSQL_DEFAULT_PORT@)"
}

start_postgres() {
    local mode=$1
    local LOG_DIR="${DATDIR}_logs"
    mkdir -p "$LOG_DIR"
    local LOG_FILE="$LOG_DIR/postgres.log"
    touch "$LOG_FILE"
    if [ "$mode" = "daemon" ]; then
        # Start the server
        pg_ctl start -D "$DATDIR" -l "$LOG_FILE" \
            -o "--config-file=$DATDIR/postgresql.conf -p $PORTNO -k $DATDIR/tmp"
            
        # Give it a moment to write logs
        sleep 1
        
        # Check server status and logs
        if ! pg_ctl status -D "$DATDIR"; then
            echo "PostgreSQL failed to start. Full logs:"
            cat "$LOG_FILE"
            # You might also want to see the postmaster.pid if it exists
            if [ -f "$DATDIR/postmaster.pid" ]; then
                echo "postmaster.pid contents:"
                cat "$DATDIR/postmaster.pid"
            fi
            return 1
        fi
    else
        # Foreground mode
        exec postgres --config-file="$DATDIR/postgresql.conf" -p "$PORTNO" -D "$DATDIR" -k "/tmp" -F
    fi
}

stop_postgres() {
    pg_ctl stop -D "$DATDIR" -m fast
}

trap 'stop_postgres' SIGINT SIGTERM

# Parse arguments
# Parse arguments
while [[ "$#" -gt 0 ]]; do
    case "$1" in
        --skip-migrations)
            SKIP_MIGRATIONS=true
            shift
            ;;
        --migration-file)
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                MIGRATION_FILE="$2"
                shift 2
            else
                echo "Error: --migration-file requires a filename"
                exit 1
            fi
            ;;
        --user)
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                PSQL_USER="$2"
                shift 2
            else
                echo "Error: --user requires an argument"
                exit 1
            fi
            ;;
        --getkey-script)
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                GETKEY_SCRIPT="$2"
                shift 2
            else
                echo "Error: --getkey-script requires a script path"
                exit 1
            fi
            ;;
        --daemonize)
            DAEMONIZE=true
            shift
            ;;
        -h|--help)
            print_help
            exit 0
            ;;
        *)
            if [[ "$1" =~ ^- ]]; then
                echo "Unknown option: $1"
                print_help
                exit 1
            elif [[ -z "$VERSION" ]]; then
                VERSION="$1"
                shift
            elif [[ -z "$PORTNO" ]]; then
                PORTNO="$1"
                shift
            else
                echo "Error: Unexpected argument: $1"
                print_help
                exit 1
            fi
            ;;
    esac
done
if [[ -n "${GETKEY_SCRIPT:-}" ]]; then
    export PGSODIUM_GETKEY_SCRIPT="$GETKEY_SCRIPT"
else
    PGSODIUM_GETKEY_SCRIPT="${PGSODIUM_GETKEY_SCRIPT:-@PGSODIUM_GETKEY@}"
fi
# Verify version and set binary directory
if [ "$VERSION" == "15" ]; then
    echo "Starting server for PSQL 15"
    PSQL15=@PSQL15_BINDIR@
    BINDIR="$PSQL15"
elif [ "$VERSION" == "orioledb-17" ]; then
    echo "Starting server for PSQL ORIOLEDB 17"
    PSQLORIOLEDB17=@PSQLORIOLEDB17_BINDIR@
    BINDIR="$PSQLORIOLEDB17"
else
    echo "Please provide a valid Postgres version (15, orioledb-17)"
    exit 1
fi

# Set environment variables and paths
export PATH=$BINDIR/bin:$PATH
PGSQL_SUPERUSER=@PGSQL_SUPERUSER@
PSQL_CONF_FILE=@PSQL_CONF_FILE@
PORTNO="${PORTNO:-@PGSQL_DEFAULT_PORT@}"
SUPAUTILS_CONFIG_FILE=@SUPAUTILS_CONF_FILE@
LOGGING_CONFIG_FILE=@LOGGING_CONF_FILE@
READREPL_CONFIG_FILE=@READREPL_CONF_FILE@
PG_HBA_FILE=@PG_HBA@
PG_IDENT_FILE=@PG_IDENT@
EXTENSION_CUSTOM_SCRIPTS=@EXTENSION_CUSTOM_SCRIPTS_DIR@
GROONGA=@GROONGA_DIR@
MIGRATIONS_DIR=@MIGRATIONS_DIR@
POSTGRESQL_SCHEMA_SQL=@POSTGRESQL_SCHEMA_SQL@
PGBOUNCER_AUTH_SCHEMA_SQL=@PGBOUNCER_AUTH_SCHEMA_SQL@
STAT_EXTENSION_SQL=@STAT_EXTENSION_SQL@
MECAB_LIB=@MECAB_LIB@

# Setup directories and locale settings
DATDIR=$(mktemp -d)
LOCALE_ARCHIVE=@LOCALES@
CURRENT_SYSTEM=@CURRENT_SYSTEM@

# Set locale environment
export LOCALE_ARCHIVE
#export LANG=en_US.UTF-8
#export LANGUAGE=en_US.UTF-8
#export LC_ALL=en_US.UTF-8
#export LC_CTYPE=en_US.UTF-8
# Set locale environment
export LOCALE_ARCHIVE
export LANG=C
export LANGUAGE=C
export LC_ALL=C
export LC_CTYPE=C
export KEY_FILE="$DATDIR/pgsodium.key"
echo "KEY_FILE: $KEY_FILE"
echo "KEY_FILE contents:"
cat "$KEY_FILE" 

echo "PGSODIUM_GETKEY_SCRIPT: $PGSODIUM_GETKEY_SCRIPT"
echo "NOTE: using port $PORTNO for server"
echo "NOTE: using temporary directory $DATDIR for data"
echo "NOTE: you are free to re-use this data directory at will"

# Initialize database
if [ "$VERSION" = "orioledb-17" ]; then
    initdb -D "$DATDIR" \
        --allow-group-access \
        --username="$PGSQL_SUPERUSER" \
        #--locale-provider=icu \
        #--encoding=UTF-8 \
        #--icu-locale=en_US.UTF-8
        --locale=C \
        --encoding=UTF-8
else
    #initdb -U "$PGSQL_SUPERUSER" -D "$DATDIR"
    initdb -U "$PGSQL_SUPERUSER" -D "$DATDIR" --locale=C --encoding=UTF8
fi

# Copy configuration files
echo "NOTE: patching postgresql.conf files"
cp "$PG_HBA_FILE" "$DATDIR/pg_hba.conf"
cp "$PG_IDENT_FILE" "$DATDIR/pg_ident.conf"
cp "$READREPL_CONFIG_FILE" "$DATDIR/read-replica.conf"
mkdir -p "$DATDIR/extension-custom-scripts"
cp -r "$EXTENSION_CUSTOM_SCRIPTS"/* "$DATDIR/extension-custom-scripts"

# Configure supautils
sed "s|supautils.privileged_extensions_custom_scripts_path = '/etc/postgresql-custom/extension-custom-scripts'|supautils.privileged_extensions_custom_scripts_path = '$DATDIR/extension-custom-scripts'|" "$SUPAUTILS_CONFIG_FILE" > "$DATDIR/supautils.conf"

# Configure PostgreSQL
sed -e "1i\\
include = '$DATDIR/supautils.conf'" \
-e "\$a\\
pgsodium.getkey_script = '$PGSODIUM_GETKEY_SCRIPT'" \
-e "s|data_directory = '/var/lib/postgresql/data'|data_directory = '$DATDIR'|" \
-e "s|hba_file = '/etc/postgresql/pg_hba.conf'|hba_file = '$DATDIR/pg_hba.conf'|" \
-e "s|ident_file = '/etc/postgresql/pg_ident.conf'|ident_file = '$DATDIR/pg_ident.conf'|" \
-e "s|include = '/etc/postgresql/logging.conf'|#&|" \
-e "s|include = '/etc/postgresql-custom/read-replica.conf'|include = '$DATDIR/read-replica.conf'|" \
-e "\$a\\
session_preload_libraries = 'supautils'" \
"$PSQL_CONF_FILE" > "$DATDIR/postgresql.conf"

# Function to configure OrioleDB specific settings
orioledb_config_items() {
    if [[ "$1" = "orioledb-17" && "$CURRENT_SYSTEM" != "aarch64-darwin" ]]; then
        # Remove items from postgresql.conf
        echo "non-macos oriole conf"
        sed -i 's/ timescaledb,//g;' "$DATDIR/postgresql.conf"
        sed -i 's/db_user_namespace = off/#db_user_namespace = off/g;' "$DATDIR/postgresql.conf"
        sed -i 's/ timescaledb,//g; s/ plv8,//g; s/ postgis,//g; s/ pgrouting,//g' "$DATDIR/supautils.conf"
        sed -i 's/\(shared_preload_libraries.*\)'\''\(.*\)$/\1, orioledb'\''\2/' "$DATDIR/postgresql.conf"
        echo "default_table_access_method = 'orioledb'" >> "$DATDIR/postgresql.conf"
    elif [[ "$1" = "orioledb-17" && "$CURRENT_SYSTEM" = "aarch64-darwin" ]]; then
        # macOS specific configuration
        echo "macOS detected, applying macOS specific configuration"
        ls -la "$DATDIR"
        
        # Use perl instead of sed for macOS
        perl -pi -e 's/ timescaledb,//g' "$DATDIR/postgresql.conf"
        perl -pi -e 's/db_user_namespace = off/#db_user_namespace = off/g' "$DATDIR/postgresql.conf"
        
        perl -pi -e 's/ timescaledb,//g' "$DATDIR/supautils.conf"
        perl -pi -e 's/ plv8,//g' "$DATDIR/supautils.conf"
        perl -pi -e 's/ postgis,//g' "$DATDIR/supautils.conf"
        perl -pi -e 's/ pgrouting,//g' "$DATDIR/supautils.conf"
        
        perl -pi -e 's/(shared_preload_libraries\s*=\s*'\''.*?)'\''/\1, orioledb'\''/' "$DATDIR/postgresql.conf"
        
        echo "default_table_access_method = 'orioledb'" >> "$DATDIR/postgresql.conf"
    fi
}

# Apply OrioleDB configuration if needed
orioledb_config_items "$VERSION"
# Configure Groonga
export GRN_PLUGINS_DIR=$GROONGA/lib/groonga/plugins

# Start postgres
mkdir -p "$DATDIR/tmp"
chmod 1777 "$DATDIR/tmp"  
start_postgres "daemon"

# Wait for PostgreSQL to start
for i in {1..60}; do
    if pg_isready -h localhost -p "$PORTNO" -q; then
        echo "PostgreSQL is ready"
        break
    fi
    sleep 1
    if [ $i -eq 60 ]; then
        echo "PostgreSQL failed to start"
        'stop_postgres' 1
    fi
done

# Create orioledb extension if needed
if [ "$VERSION" = "orioledb-17" ]; then
    psql -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U "$PGSQL_SUPERUSER" -p "$PORTNO" -h localhost -d postgres -c "CREATE EXTENSION IF NOT EXISTS orioledb;"
fi

# Skip migrations if requested
if [ "$SKIP_MIGRATIONS" = false ]; then
    # Create postgres role and set ownership
    if ! psql -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U "$PGSQL_SUPERUSER" -p "$PORTNO" -h localhost -d postgres <<-EOSQL
        create role postgres superuser login password '$PGPASSWORD';
        alter database postgres owner to postgres;
EOSQL
    then
        'stop_postgres' 1
    fi

    if [ -n "$MIGRATION_FILE" ]; then
        echo "Running user-provided migration file $MIGRATION_FILE"
        if ! psql -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U "$PGSQL_SUPERUSER" -p "$PORTNO" -h localhost -f "$MIGRATION_FILE" postgres; then
            'stop_postgres' 1
        fi
    else
        # Run default init scripts
        for sql in "$MIGRATIONS_DIR"/init-scripts/*.sql; do
            echo "Running $sql"
            if ! psql -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U "$PSQL_USER" -p "$PORTNO" -h localhost -f "$sql" postgres; then
                'stop_postgres' 1
            fi
        done

        # Set superuser password
        if ! psql -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U "$PSQL_USER" -p "$PORTNO" -h localhost -c "ALTER USER supabase_admin WITH PASSWORD '$PGPASSWORD'"; then
            'stop_postgres' 1
        fi

        # Run additional schema files
        if ! psql -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U "$PSQL_USER" -p "$PORTNO" -h localhost -d postgres -f "$PGBOUNCER_AUTH_SCHEMA_SQL"; then
            'stop_postgres' 1
        fi
        if ! psql -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U "$PSQL_USER" -p "$PORTNO" -h localhost -d postgres -f "$STAT_EXTENSION_SQL"; then
            'stop_postgres' 1
        fi

        # Run migrations as superuser
        for sql in "$MIGRATIONS_DIR"/migrations/*.sql; do
            echo "Running $sql"
            if ! psql -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U "$PGSQL_SUPERUSER" -p "$PORTNO" -h localhost -f "$sql" postgres; then
                'stop_postgres' 1
            fi
        done

        # Run PostgreSQL schema
        if ! psql -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U "$PGSQL_SUPERUSER" -p "$PORTNO" -h localhost -f "$POSTGRESQL_SCHEMA_SQL" postgres; then
            'stop_postgres' 1
        fi
    fi
fi
echo "Shutting down PostgreSQL..."
stop_postgres

# Step 4: Restart PostgreSQL in the foreground (with log output visible) or as a daemon
if [ "$DAEMONIZE" = true ]; then
    start_postgres "daemon"
else 
    start_postgres "foreground"
fi

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/tools/local-infra-bootstrap.sh.in ---
#!/usr/bin/env bash
# shellcheck shell=bash

[ ! -z "$DEBUG" ] && set -x

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color
BOLD='\033[1m'

INFRA_REPO_DIR=""
SUPABASE_REPO=""
SETUP_FLAG=false
NODE_VERSION="20"  # Default Node.js version

print_help() {
    echo "Usage: nix run .#local-infra-bootstrap -- [options]"
    echo
    echo "Options:"
    echo "  -h, --help                        Show this help message"
    echo "  -s, --setup                       Setup the local infrastructure for development NOTE: Requires --infrastructure-repo and --supabase-repo"
    echo "  --infrastructure-repo <path>           Full path to infrastructure repository directory"
    echo "  --supabase-repo <path>            Full path to Supabase repository directory"
    echo "  --aws-yubikey-setup               Install AWS CLI tools with YubiKey support"
    echo "  --aws-yubikey-setup-no-key        Install AWS CLI tools without YubiKey"
    echo "  --node-version <version>          Specify Node.js version to install/use (default: $NODE_VERSION)"
    echo
    echo "Description:"
    echo "  Bootstrap the local infrastructure for development."
    echo "  This tool wraps homebrew and other tools to install the necessary dependencies."
    echo
    echo "Examples:"
    echo "  nix run .#local-infra-bootstrap -- --setup --infrastructure-repo /path/to/infrastructure --supabase-repo /path/to/supabase"
    echo "  nix run .#local-infra-bootstrap -- --aws-yubikey-setup"
    echo "  nix run .#local-infra-bootstrap -- --setup --node-version 18"
}

check_brew() {
    if command -v brew >/dev/null 2>&1; then
        echo "Homebrew is installed."
        echo "Version: $(brew --version)"
    else
        echo "Homebrew is not installed."
        echo "To install Homebrew, run the following command:"
        echo
        echo '/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"'
        echo
        echo "After installation, you may need to add Homebrew to your PATH:"
        echo
        echo "For Intel Macs:"
        echo 'echo '\''eval "$(/usr/local/bin/brew shellenv)"'\'' >> ~/.zprofile'
        echo 'eval "$(/usr/local/bin/brew shellenv)"'
        echo
        echo "For Apple Silicon Macs (M1/M2/M3):"
        echo 'echo '\''eval "$(/opt/homebrew/bin/brew shellenv)"'\'' >> ~/.zprofile'
        echo 'eval "$(/opt/homebrew/bin/brew shellenv)"'
        exit 1
    fi
}

check_and_setup_node() {
    echo -e "\n${BOLD}Checking Node.js installation...${NC}"
    
    # Check if the specified node version is installed
    if ! brew list "node@$NODE_VERSION" &>/dev/null; then
        echo "Node.js $NODE_VERSION is not installed. Installing..."
        brew install "node@$NODE_VERSION"
    fi
    
    # Unlink any existing node version
    brew unlink node@* 2>/dev/null || true
    
    # Link the desired version with overwrite
    echo "Linking Node.js $NODE_VERSION..."
    brew link --overwrite --force "node@$NODE_VERSION"
    
    # Verify installation
    if ! command -v node &>/dev/null; then
        echo -e "${RED}❌ Failed to install Node.js $NODE_VERSION${NC}"
        return 1
    fi
    
    current_version=$(node -v | cut -d 'v' -f2 | cut -d '.' -f1)
    if [ "$current_version" = "$NODE_VERSION" ]; then
        echo -e "${GREEN}✅ Node.js $NODE_VERSION is now active${NC}"
        return 0
    else
        echo -e "${RED}❌ Failed to switch to Node.js $NODE_VERSION${NC}"
        return 1
    fi
}

configure_ngrok() {
    echo -e "\n${BOLD}Configuring ngrok settings...${NC}"
    
    if [ -z "$INFRA_REPO_DIR" ]; then
        echo -e "${RED}Error: Infrastructure repository directory not specified${NC}"
        return 1
    fi
    
    local env_file="$INFRA_REPO_DIR/.local.env"
    mkdir -p "$INFRA_REPO_DIR"
    
    read -p "Enter your ngrok static domain (example.ngrok-free.app): " static_domain
    read -p "Enter your ngrok auth token: " auth_token
    
    if [[ -z "$static_domain" || -z "$auth_token" ]]; then
        echo -e "${RED}Error: Both static domain and auth token are required${NC}"
        return 1
    fi
    
    cat > "$env_file" << EOF
EXTERNAL_SUPABASE_API_URL=http://${static_domain}
NGROK_AUTHTOKEN=${auth_token}
NGROK_STATIC_DOMAIN=${static_domain}
WARP_ALWAYS_ENABLED=true
SUPABASE_PATH=${SUPABASE_REPO}
EOF
    
    echo -e "${GREEN}✅ ngrok configuration saved to ${env_file}${NC}"
}

check_app() {
    local brew_name=$1
    local check_command=$2

    echo "Checking $brew_name..."
    
    # Special case for OrbStack
    if [ "$brew_name" = "orbstack" ]; then
        if [ -d "/Applications/OrbStack.app" ]; then
            echo "✅ $brew_name is installed"
            return 0
        else
            echo "❌ $brew_name is not installed"
            return 1
        fi
    fi

    # Standard command check
    if command -v "$check_command" >/dev/null 2>&1; then
        echo "✅ $brew_name is installed"
        return 0
    else
        echo "❌ $brew_name is not installed"
        return 1
    fi
}

install_app() {
    local app=$1
    echo "Installing $app..."
    
    case "$app" in
        "orbstack")
            brew install --cask "$app"
            if [ -d "/Applications/OrbStack.app" ]; then
                echo "✅ OrbStack installed successfully"
                echo "⚠️  Important: Please open OrbStack.app to complete the setup"
                return 0
            fi
            ;;
        "aws-vault")
            brew install --cask "$app"
            # Give the system a moment to complete the linking
            sleep 1
            if [ -f "/opt/homebrew/bin/aws-vault" ] || [ -f "/usr/local/bin/aws-vault" ]; then
                echo "✅ aws-vault installed successfully"
                return 0
            fi
            ;;
        "awscli")
            brew install "$app"
            # Reload shell environment to ensure AWS CLI is in PATH
            eval "$(/opt/homebrew/bin/brew shellenv)"
            if command -v aws >/dev/null 2>&1; then
                echo "✅ $app installed successfully"
                return 0
            fi
            ;;
        "dbmate"|*)
            brew install "$app"
            if command -v "$app" >/dev/null 2>&1; then
                echo "✅ $app installed successfully"
                return 0
            fi
            ;;
    esac

    echo "❌ Failed to install $app"
    return 1
}

check_corepack_pnpm() {
    echo -e "\nChecking Corepack PNPM setup..."
    
    # First check if pnpm binary exists in common locations
    if [ -f "$(which pnpm 2>/dev/null)" ]; then
        # Try to get version without executing pnpm
        echo -e "${GREEN}✅ PNPM is enabled${NC}"
        return 0
    else
        echo -e "${RED}❌ PNPM is not installed${NC}"
        return 1
    fi
}

enable_corepack_pnpm() {
    local pnpm_checked=false
    
    if [ "$pnpm_checked" = false ]; then
        if ! check_corepack_pnpm; then
            read -p "Would you like to enable PNPM through Corepack? (y/n) " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                echo "Running corepack enable pnpm..."
                # Remove existing symlinks if present
                sudo rm -f /opt/homebrew/bin/pnpm /opt/homebrew/bin/pnpx
                if NODE_OPTIONS="" corepack enable pnpm; then
                    echo -e "${GREEN}✅ Successfully enabled PNPM through Corepack${NC}"
                    pnpm_checked=true
                    return 0
                else
                    echo -e "${RED}❌ Failed to enable PNPM through Corepack${NC}"
                    pnpm_checked=true
                    return 1
                fi
            else
                echo -e "\n${BOLD}Skipping PNPM setup...${NC}"
                pnpm_checked=true
                return 0
            fi
        else
            pnpm_checked=true
            return 0
        fi
    fi
    return 0
}

install_prerequisites() {
    echo -e "\n${BOLD}Checking Prerequisites ...${NC}"
    echo

    # Define apps and their check commands
    local apps=("awscli" "dbmate" "orbstack" "corepack" "aws-vault" "tmux" "tmuxp" "ngrok")
    local commands=("aws" "dbmate" "orbstack" "corepack" "aws-vault" "tmux" "tmuxp" "ngrok")
    local pnpm_checked=false
    
    # Check each app and prompt for installation if missing
    for i in "${!apps[@]}"; do
        local brew_name="${apps[$i]}"
        local check_command="${commands[$i]}"
        
        check_app "$brew_name" "$check_command"
        if [ $? -eq 1 ]; then
            read -p "Would you like to install $brew_name? (y/n) " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                case "$brew_name" in
                    "tmux"|"tmuxp")
                        echo "Installing $brew_name..."
                        brew install "$brew_name"
                        if command -v "$brew_name" >/dev/null 2>&1; then
                            echo -e "${GREEN}✅ $brew_name installed successfully${NC}"
                        else
                            echo -e "${RED}❌ Failed to install $brew_name${NC}"
                        fi
                        ;;
                    *)
                        install_app "$brew_name"
                        ;;
                esac
                
                # If we just installed corepack, check and enable pnpm
                if [ "$brew_name" = "corepack" ] && [ "$pnpm_checked" = false ]; then
                    NODE_OPTIONS="" enable_corepack_pnpm
                    pnpm_checked=true
                fi
            else
                echo -e "\n${BOLD}Skipping installation of $brew_name ...${NC}"
            fi
        elif [ "$brew_name" = "corepack" ] && [ "$pnpm_checked" = false ]; then
            # If corepack is already installed, check pnpm once
            NODE_OPTIONS="" enable_corepack_pnpm
            pnpm_checked=true
        fi
        echo
    done
    if command -v ngrok >/dev/null 2>&1; then
        configure_ngrok
    fi
    echo -e "\n${BOLD}Prerequisites Check Complete ${NC}"
}

# AWS YubiKey Setup Function - Only installs required tools
install_aws_tools() {
    echo -e "\n${BOLD}Installing required AWS CLI tools...${NC}"
    
    # Check and install AWS CLI
    if ! command -v aws >/dev/null 2>&1; then
        brew install awscli
        echo -e "✅ AWS CLI installed"
    else
        echo -e "✅ AWS CLI already installed"
    fi
    
    # Check and install AWS Vault
    if ! command -v aws-vault >/dev/null 2>&1; then
        brew install homebrew/cask/aws-vault
        echo -e "✅ AWS Vault installed"
    else
        echo -e "✅ AWS Vault already installed"
    fi
    
    if [[ "$1" != "--no-yubikey" ]]; then
        # Check and install YubiKey Manager
        if ! command -v ykman >/dev/null 2>&1; then
            brew install ykman
            echo -e "✅ YubiKey Manager installed"
        else
            echo -e "✅ YubiKey Manager already installed"
        fi
    fi

    echo -e "\n${BOLD}✅ AWS CLI tools installation complete${NC}"
    echo -e "Please follow the AWS CLI MFA+YubiKey setup documentation for next steps."
}

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            print_help
            exit 0
            ;;
        -s|--setup)
            SETUP_FLAG=true
            shift
            ;;
        --node-version)
            if [ -n "$2" ]; then
                NODE_VERSION="$2"
                shift 2
            else
                echo "Error: --node-version requires a version number"
                exit 1
            fi
            ;;
        --infrastructure-repo)
            if [ -n "$2" ]; then
                INFRA_REPO_DIR="$2"
                shift 2
            else
                echo "Error: --infrastructure-repo requires a path argument"
                exit 1
            fi
            ;;
        --supabase-repo)
            if [ -n "$2" ]; then
                SUPABASE_REPO="$2"
                shift 2
            else
                echo "Error: --supabase-repo requires a path argument"
                exit 1
            fi
            ;;
        --aws-yubikey-setup)
            check_brew
            install_aws_tools
            shift
            ;;
        --aws-yubikey-setup-no-key)
            check_brew
            install_aws_tools "--no-yubikey"
            shift
            ;;
        *)
            echo "Unknown argument: $1"
            print_help
            exit 1
            ;;
    esac
done

# Validate setup requirements
if [ "$SETUP_FLAG" = true ]; then
    if [ -z "$INFRA_REPO_DIR" ]; then
        echo -e "${RED}Error: --infrastructure-repo is required when using --setup${NC}"
        print_help
        exit 1
    fi
    if [ -z "$SUPABASE_REPO" ]; then
        echo -e "${RED}Error: --supabase-repo is required when using --setup${NC}"
        print_help
        exit 1
    fi
    check_brew
    check_and_setup_node
    install_prerequisites
fi

# If no arguments provided, show help
if [ "$SETUP_FLAG" = false ] && [ -z "$INFRA_REPO_DIR" ]; then
    print_help
    exit 0
fi
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/tools/migrate-tool.sh.in ---
#!/usr/bin/env bash

[ ! -z "$DEBUG" ] && set -x

# first argument is the old version; a path 15 or 16
if [[ $1 == /nix/store* ]]; then
    if [ ! -L "$1/receipt.json" ] || [ ! -e "$1/receipt.json" ]; then
        echo "ERROR: $1 does not look like a valid Postgres install"
        exit 1
    fi
    OLDVER="$1"
elif [ "$1" == "15" ]; then
    PSQL15=@PSQL15_BINDIR@
    OLDVER="$PSQL15"
elif [ "$1" == "16" ]; then
    PSQL16=@PSQL16_BINDIR@
    OLDVER="$PSQL16"
else
    echo "Please provide a valid Postgres version (15 or 16), or a /nix/store path"
    exit 1
fi

# second argument is the new version; 15 or 16
if [[ $2 == /nix/store* ]]; then
    if [ ! -L "$2/receipt.json" ] || [ ! -e "$2/receipt.json" ]; then
        echo "ERROR: $1 does not look like a valid Postgres install"
        exit 1
    fi
    NEWVER="$2"
elif [ "$2" == "15" ]; then
    PSQL15=@PSQL15_BINDIR@
    NEWVER="$PSQL15"
elif [ "$2" == "16" ]; then
    PSQL16=@PSQL16_BINDIR@
    NEWVER="$PSQL16"
    echo "NEWVER IS $NEWVER"
else
    echo "Please provide a valid Postgres version (15 or 16), or a /nix/store path"
    exit 1
fi

# thid argument is the upgrade method: either pg_dumpall or pg_ugprade
if [ "$3" != "pg_dumpall" ] && [ "$3" != "pg_upgrade" ]; then
    echo "Please provide a valid upgrade method (pg_dumpall or pg_upgrade)"
    exit 1
fi
UPGRADE_METHOD="$3"

echo "Old server build: PSQL $1"
echo "New server build: PSQL $2"
echo "Upgrade method: $UPGRADE_METHOD"

PORTNO="${2:-@PGSQL_DEFAULT_PORT@}"
DATDIR=$(mktemp -d)
NEWDAT=$(mktemp -d)
mkdir -p "$DATDIR" "$NEWDAT"

echo "NOTE: using temporary directory $DATDIR for PSQL $1 data, which will not be removed"
echo "NOTE: you are free to re-use this data directory at will"
echo

$OLDVER/bin/initdb -D "$DATDIR" --locale=C --username=supabase_admin
$NEWVER/bin/initdb -D "$NEWDAT" --locale=C --username=supabase_admin

# NOTE (aseipp): we need to patch postgresql.conf to have the right pgsodium_getkey script
PSQL_CONF_FILE=@PSQL_CONF_FILE@
PGSODIUM_GETKEY_SCRIPT=@PGSODIUM_GETKEY@
echo "NOTE: patching postgresql.conf files"
for x in "$DATDIR" "$NEWDAT"; do
  sed \
    "s#@PGSODIUM_GETKEY_SCRIPT@#$PGSODIUM_GETKEY_SCRIPT#g" \
    $PSQL_CONF_FILE > "$x/postgresql.conf"
done

echo "NOTE: Starting first server (v${1}) to load data into the system"
$OLDVER/bin/pg_ctl start -D "$DATDIR"

PRIMING_SCRIPT=@PRIMING_SCRIPT@
MIGRATION_DATA=@MIGRATION_DATA@

$OLDVER/bin/psql -h localhost -d postgres -Xf "$PRIMING_SCRIPT"
$OLDVER/bin/psql -h localhost -d postgres -Xf "$MIGRATION_DATA"

if [ "$UPGRADE_METHOD" == "pg_upgrade" ]; then
  echo "NOTE: Stopping old server (v${1}) to prepare for migration"
  $OLDVER/bin/pg_ctl stop -D "$DATDIR"

  echo "NOTE: Migrating old data $DATDIR to $NEWDAT using pg_upgrade"

  export PGDATAOLD="$DATDIR"
  export PGDATANEW="$NEWDAT"
  export PGBINOLD="$OLDVER/bin"
  export PGBINNEW="$NEWVER/bin"

  if ! $NEWVER/bin/pg_upgrade --check; then
      echo "ERROR: pg_upgrade check failed"
      exit 1
  fi

  echo "NOTE: pg_upgrade check passed, proceeding with migration"
  $NEWVER/bin/pg_upgrade
  rm -f delete_old_cluster.sh # we don't need this
  exit 0
fi

if [ "$UPGRADE_METHOD" == "pg_dumpall" ]; then
    SQLDAT="$DATDIR/dump.sql"
    echo "NOTE: Exporting data via pg_dumpall ($SQLDAT)"
    $NEWVER/bin/pg_dumpall -h localhost > "$SQLDAT"

    echo "NOTE: Stopping old server (v${1}) to prepare for migration"
    $OLDVER/bin/pg_ctl stop -D "$DATDIR"

    echo "NOTE: Starting second server (v${2}) to load data into the system"
    $NEWVER/bin/pg_ctl start -D "$NEWDAT"

    echo "NOTE: Loading data into new server (v${2}) via 'cat | psql'"
    cat "$SQLDAT" | $NEWVER/bin/psql -h localhost -d postgres

    printf "\n\n\n\n"
    echo "NOTE: Done, check logs. Stopping the server; new database is located at $NEWDAT"
    $NEWVER/bin/pg_ctl stop -D "$NEWDAT"
fi

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/tools/sync-exts-versions.sh.in ---
#!/usr/bin/env bash
# shellcheck shell=bash

[ ! -z "$DEBUG" ] && set -x

#pass in env vars supplied by nix
yq=@YQ@
jq=@JQ@
editor=@NIX_EDITOR@
ansible_vars=$($yq '.' $PWD/ansible/vars.yml) 
prefetchurl=@NIXPREFETCHURL@
_nix=@NIX@
fetch_source_url() {
    local source_url=${1//\"/}  # Remove double quotes
    source_url=${source_url//\'/}  # Remove single quotes
    
    # Check if the source URL is provided
    if [ -z "$source_url" ]; then
        echo "Usage: fetch_nix_url <source_url>"
        return 1
    fi
    
    echo "$source_url"
    
    # Run nix-prefetch-url command
    local initial_hash=$($prefetchurl --type sha256 "$source_url" --unpack | cut -d ' ' -f 2)
    #once we can bump up nix version, we can use nix hash convert --hash-algo sha256
    local final_hash=$($_nix hash to-sri --type sha256 $initial_hash)
    echo "$final_hash"
}

sync_version() {

    local package_name=$1
    local version="\"$2\""
    local hash="\"$3\""


    # Update the version and hash in the Nix expression
    $editor $PWD/nix/ext/$package_name.nix version --inplace -v "$version"
    $editor $PWD/nix/ext/$package_name.nix src.hash --inplace -v $hash
}

run_sync() {
    local varname=$1
    local package_name=$2

    version=$(echo $ansible_vars |  $jq -r '.'$varname'')
    echo "$key: $version"
    url=$($_nix eval .#psql_15/exts/$package_name.src.url)
    hash=$(fetch_source_url $url | tail -n 1)
    $(sync_version $package_name $version $hash)
    echo "synced $package_name to version $version with hash $hash"


}

#for use where nix uses fetchurl 
# instead of fetchFromGithub
fetchurl_source_url() {
    local source_url=${1//\"/}  # Remove double quotes
    source_url=${source_url//\'/}  # Remove single quotes
    
    # Check if the source URL is provided
    if [ -z "$source_url" ]; then
        echo "Usage: fetch_nix_url <source_url>"
        return 1
    fi
    
    echo "$source_url"
    
    # Run nix-prefetch-url command
    local initial_hash=$($prefetchurl --type sha256 "$source_url" | cut -d ' ' -f 2)
    #once we can bump up nix version, we can use nix hash convert --hash-algo sha256
    local final_hash=$($_nix hash to-sri --type sha256 $initial_hash)
    echo "$final_hash"
}

sync_version_fetchurl() {

    local package_name=$1
    local version="\"$2\""
    local hash="\"$3\""


    # Update the version and hash in the Nix expression
    $editor $PWD/nix/ext/$package_name.nix version --inplace -v "$version"
    $editor $PWD/nix/ext/$package_name.nix src.sha256 --inplace -v $hash
}


run_sync_fetchurl() {
    local varname=$1
    local package_name=$2

    version=$(echo $ansible_vars |  $jq -r '.'$varname'')
    echo "$key: $version"
    url=$($_nix eval .#psql_15/exts/$package_name.src.url)
    hash=$(fetchurl_source_url $url | tail -n 1)
    $(sync_version_fetchurl $package_name $version $hash)
    echo "synced $package_name to version $version with hash $hash"


}

#for use on derivations that use cargoHash
update_cargo_vendor_hash() {
    local package_name=$1
    $editor $PWD/nix/ext/$package_name.nix cargoHash --inplace -v ""
    output=$($_nix build .#psql_15/exts/$package_name 2>&1)

    # Check if the command exited with an error
    if [ $? -ne 0 ]; then
        # Extract the hash value after "got: "
        hash_value_scraped=$(echo "$output" | grep "got:" | awk '{for (i=1; i<=NF; i++) if ($i ~ /^sha/) print $i}')
        hash_value="\"$hash_value_scraped\""
        # Continue using the captured hash value
        $editor $PWD/nix/ext/$package_name.nix cargoHash --inplace -v $hash_value
        echo "Updated cargoHash for $package_name to $hash_value"
    else
        echo "$package_name builds successfully, moving on..."
    fi
}

#iterate values in ansible vars, case statement
# to match ansible var to package name
keys=$(echo "$ansible_vars" | $jq -r 'keys[]')

for key in $keys; do
    case $key in
        "pg_hashids_release")
            varname="pg_hashids_release"
            package_name="pg_hashids"
            run_sync $varname $package_name
            ;;
        "hypopg_release")
            varname="hypopg_release"
            package_name="hypopg"
            run_sync $varname $package_name
            ;;
        "pg_graphql_release")
            varname="pg_graphql_release"
            package_name="pg_graphql"
            run_sync $varname $package_name
            update_cargo_vendor_hash $package_name
            ;;
        "pg_cron_release")
            varname="pg_cron_release"
            package_name="pg_cron"
            run_sync $varname $package_name
            ;;
        "pgsql_http_release")
            varname="pgsql_http_release"
            package_name="pgsql-http"
            run_sync $varname $package_name
            ;;
        "pg_jsonschema_release")
            varname="pg_jsonschema_release"
            package_name="pg_jsonschema"
            run_sync $varname $package_name
            update_cargo_vendor_hash $package_name
            ;;
        "pg_net_release")
            varname="pg_net_release"
            package_name="pg_net"
            run_sync $varname $package_name
            ;;
        "pg_plan_filter_release")
            varname="pg_plan_filter_release"
            package_name="pg_plan_filter"
            run_sync $varname $package_name
            ;;
        "pg_safeupdate_release")
            varname="pg_safeupdate_release"
            package_name="pg-safeupdate"
            run_sync $varname $package_name
            ;;
        "pgsodium_release")
            varname="pgsodium_release"
            package_name="pgsodium"
            run_sync $varname $package_name
            ;;
        "pg_repack_release")
            varname="pg_repack_release"
            package_name="pg_repack"
            run_sync $varname $package_name
            ;;
        "pgrouting_release")
            varname="pgrouting_release"
            package_name="pgrouting"
            run_sync $varname $package_name
            ;;
        "ptap_release")
            varname="pgtap_release"
            package_name="pgtap"
            run_sync $varname $package_name
            ;;
        "pg_stat_monitor_release")
            varname="pg_stat_monitor_release"
            package_name="pg_stat_monitor"
            run_sync $varname $package_name
            ;;
        "pg_tle_release")
            varname="pg_tle_release"
            package_name="pg_tle"
            run_sync $varname $package_name
            ;;
        "pgaudit_release")
            varname="pgaudit_release"
            package_name="pgaudit"
            run_sync $varname $package_name
            ;;
        "plpgsql_check_release")
            varname="plpgsql_check_release"
            package_name="plpgsql-check"
            run_sync $varname $package_name
            ;;
        "pgvector_release")
            varname="pgvector_release"
            package_name="pgvector"
            run_sync $varname $package_name
            ;;
        "pgjwt_release")
            varname="pgjwt_release"
            package_name="pgjwt"
            run_sync $varname $package_name
            ;;
        "plv8_release")
            varname="plv8_release"
            package_name="plv8"
            run_sync $varname $package_name
            ;;
        "postgis_release")
            varname="postgis_release"
            package_name="postgis"
            run_sync_fetchurl $varname $package_name
            ;;
        "pgroonga_release")
            varname="pgroonga_release"
            package_name="pgroonga"
            run_sync_fetchurl $varname $package_name
            ;;
        "rum_release")
            varname="rum_release"
            package_name="rum"
            run_sync $varname $package_name
            ;;
        "timescaledb_release")
            varname="timescaledb_release"
            package_name="timescaledb"
            run_sync $varname $package_name
            ;;
        "supautils_release")
            varname="supautils_release"
            package_name="supautils"
            run_sync $varname $package_name
            ;;
        "vault_release")
            varname="vault_release"
            package_name="vault"
            run_sync $varname $package_name
            ;;
        "wal2json_release")
            varname="wal2json_release"
            package_name="wal2json"
            run_sync $varname $package_name
            ;;
        *)
            ;;
    esac
done

# url=$($_nix eval .#psql_16/exts/pgvector.src.url)

# fetch_nix_url "$url"

#res=$editor /home/sam/postgres/nix/ext/pgvector.nix src 
#echo $res
# url=$($_nix eval .#psql_16/exts/pgvector.src.url)
# #echo $url
# hash=$(fetch_source_url $url | tail -n 1)
# echo "$hash"

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/tools/postgresql_schema.sql ---
ALTER DATABASE postgres SET "app.settings.jwt_secret" TO  'my_jwt_secret_which_is_not_so_secret';
ALTER DATABASE postgres SET "app.settings.jwt_exp" TO 3600;
ALTER USER supabase_admin WITH PASSWORD 'postgres';
ALTER USER postgres WITH PASSWORD 'postgres';
ALTER USER authenticator WITH PASSWORD 'postgres';
ALTER USER pgbouncer WITH PASSWORD 'postgres';
ALTER USER supabase_auth_admin WITH PASSWORD 'postgres';
ALTER USER supabase_storage_admin WITH PASSWORD 'postgres';
ALTER USER supabase_replication_admin WITH PASSWORD 'postgres';
ALTER ROLE supabase_read_only_user WITH PASSWORD 'postgres';
ALTER ROLE supabase_admin SET search_path TO "$user",public,auth,extensions;

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/tools/README.md ---
This directory just contains tools, but you can't run them directly. For the
sake of robustness, you should use `nix run` on this repository to do so.

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/tools/dbmate-tool.sh.in ---
#!/usr/bin/env bash
# shellcheck shell=bash

[ ! -z "$DEBUG" ] && set -x

# Default values
PSQL_VERSION="ALL"
PORTNO="@PGSQL_DEFAULT_PORT@"
PGSQL_SUPERUSER="@PGSQL_SUPERUSER@"
PGPASSWORD="${PGPASSWORD:-postgres}"
PGSQL_USER="postgres"
FLAKE_URL="github:supabase/postgres"
MIGRATIONS_DIR="@MIGRATIONS_DIR@"
CURRENT_SYSTEM="@CURRENT_SYSTEM@"
ANSIBLE_VARS="@ANSIBLE_VARS@"
PGBOUNCER_AUTH_SCHEMA_SQL=@PGBOUNCER_AUTH_SCHEMA_SQL@
STAT_EXTENSION_SQL=@STAT_EXTENSION_SQL@
# Cleanup function
cleanup() {
    echo "Cleaning up..."
    
    # Kill postgres processes first
    if pgrep -f "postgres" >/dev/null; then
        pkill -TERM postgres || true
        sleep 2
    fi

    # Then kill overmind
    if [ -S "./.overmind.sock" ]; then
        overmind kill || true
        sleep 2
    fi

    # Kill tmux sessions explicitly
    pkill -f "tmux.*overmind.*postgresql" || true
    tmux ls 2>/dev/null | grep 'overmind' | cut -d: -f1 | xargs -I{} tmux kill-session -t {} || true

    # Force kill any stragglers
    pkill -9 -f "(postgres|tmux.*overmind.*postgresql)" || true
    
    rm -f .overmind.sock Procfile

    # Final verification
    if ps aux | grep -E "(postgres|overmind|tmux.*postgresql)" | grep -v grep >/dev/null; then
        ps aux | grep -E "(postgres|overmind|tmux.*postgresql)" | grep -v grep
        return 1
    fi
}

# Set up trap for cleanup on script exit

# Function to display help
print_help() {
    echo "Usage: nix run .#dbmate-tool -- [options]"
    echo
    echo "Options:"
    echo "  -v, --version [15|16|orioledb-17|all]  Specify the PostgreSQL version to use (required defaults to --version all)"
    echo "  -p, --port PORT                    Specify the port number to use (default: 5435)"
    echo "  -h, --help                         Show this help message"
    echo
    echo "Description:"
    echo "  Runs 'dbmate up' against a locally running the version of database you specify. Or 'all' to run against all versions."
    echo "  NOTE: To create a migration, you must run 'nix develop' and then 'dbmate new <migration_name>' to create a new migration file."
    echo
    echo "Examples:"
    echo "  nix run .#dbmate-tool"
    echo "  nix run .#dbmate-tool -- --version 15"
    echo "  nix run .#dbmate-tool -- --version 16 --port 5433"
}


# Parse arguments
while [[ "$#" -gt 0 ]]; do
    case "$1" in
        -v|--version)
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                PSQL_VERSION="$2"
                shift 2
            else
                echo "Error: --version requires an argument (15, 16, or orioledb-17)"
                exit 1
            fi
            ;;
        -u|--user)
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                PGSQL_USER="$2"
                shift 2
            else
                echo "Error: --user requires an argument"
                exit 1
            fi
            ;;
        -f|--flake-url)
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                FLAKE_URL="$2"
                shift 2
            else
                echo "Error: --flake-url requires an argument"
                exit 1
            fi
            ;;
        -p|--port)
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                PORTNO="$2"
                shift 2
            else
                echo "Error: --port requires an argument"
                exit 1
            fi
            ;;
        -h|--help)
            print_help
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            print_help
            exit 1
            ;;
    esac
done

# Function to wait for PostgreSQL to be ready
wait_for_postgres() {
    local max_attempts=30  # Increased significantly
    local attempt=1
    
    # Give overmind a moment to actually start the process
    sleep 2
    
    while [ $attempt -le $max_attempts ]; do
        "${PSQLBIN}/pg_isready" -h localhost -p "$PORTNO" -U "$PGSQL_SUPERUSER" -d postgres
        local status=$?
        
        if [ $status -eq 0 ]; then
            echo "PostgreSQL is ready!"
            return 0
        fi
        echo "Waiting for PostgreSQL to start (attempt $attempt/$max_attempts)..."
        sleep 2
        attempt=$((attempt + 1))
    done
    
    echo "PostgreSQL failed to start after $max_attempts attempts"
    overmind echo postgres
    return 1
}

check_orioledb_ready() {
    local max_attempts=30
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        if "${PSQLBIN}/psql" -v ON_ERROR_STOP=1 -U "$PGSQL_SUPERUSER" -p "$PORTNO" -h localhost -d postgres -c "SELECT * FROM pg_am WHERE amname = 'orioledb'" | grep -q orioledb; then
            echo "Orioledb extension is ready!"
            return 0
        fi
        echo "Waiting for orioledb to be ready (attempt $attempt/$max_attempts)..."
        sleep 2
        attempt=$((attempt + 1))
    done
    
    echo "Orioledb failed to initialize after $max_attempts attempts"
    return 1
}

trim_schema() {
    case "$CURRENT_SYSTEM" in
    "x86_64-darwin"|"aarch64-darwin")
        sed -i '' '/INSERT INTO public.schema_migrations/,$d' "./db/schema.sql"
        echo "Matched: $CURRENT_SYSTEM"
        ;;
    *)
        sed -i '/INSERT INTO public.schema_migrations/,$d' "./db/schema.sql"
        ;;
    esac
}
overmind_start() {
        cat > Procfile << EOF
postgres_${PSQL_VERSION}: exec nix run "$FLAKE_URL#start-server" -- "$PSQL_VERSION" --skip-migrations
EOF
    overmind start -D
    echo "Waiting for overmind socket..."
    max_wait=5
    count=0
    while [ $count -lt $max_wait ]; do
        if [ -S "./.overmind.sock" ]; then
            # Found the socket, give it a moment to be ready
            sleep 5
            echo "Socket file found and ready"
            break
        fi
        echo "Waiting for socket file (attempt $count/$max_wait)"
        sleep 1
        count=$((count + 1))
    done
}
perform_dump() {
    local max_attempts=3
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        echo "Attempting dbmate dump (attempt $attempt/$max_attempts)"
        
        if dbmate dump; then
            return 0
        fi
        
        echo "Dump attempt $attempt failed, waiting before retry..."
        sleep 5
        attempt=$((attempt + 1))
    done
    
    echo "All dump attempts failed"
    return 1
}
migrate_version() {
    echo "PSQL_VERSION: $PSQL_VERSION"
    overmind kill || true
    rm -f .overmind.sock Procfile  || true
    PSQLBIN=$(nix build --no-link "$FLAKE_URL#psql_$PSQL_VERSION/bin" --json | jq -r '.[].outputs.out + "/bin"')
    echo "Using PostgreSQL version $PSQL_VERSION from $PSQLBIN"
    
    # Start overmind
    overmind_start
    echo "Waiting for overmind socket..."


    echo "Waiting for PostgreSQL to be ready..."

    #Wait for PostgreSQL to be ready to accept connections
    if ! wait_for_postgres; then
        echo "Failed to connect to PostgreSQL server"
        exit 1
    fi
    
    if [ "$PSQL_VERSION" = "orioledb-17" ]; then
        if ! check_orioledb_ready; then
            echo "Failed to initialize orioledb extension"
            exit 1
        fi
    fi

    echo "PostgreSQL server is ready"

    # Configure PostgreSQL roles and permissions
    if ! "${PSQLBIN}/psql" -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U "$PGSQL_SUPERUSER" -p "$PORTNO" -h localhost -d postgres <<-EOSQL
create role postgres superuser login password '$PGPASSWORD';
alter database postgres owner to postgres;
EOSQL
    then
        echo "Failed to configure PostgreSQL roles and permissions"
        exit 1
    fi
    "${PSQLBIN}/psql" -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U postgres -p "$PORTNO" -h localhost -d postgres -f "$PGBOUNCER_AUTH_SCHEMA_SQL"
    "${PSQLBIN}/psql" -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U postgres -p "$PORTNO" -h localhost -d postgres -f "$STAT_EXTENSION_SQL"

    #set db url to run dbmate
    export DATABASE_URL="postgres://$PGSQL_USER:$PGPASSWORD@localhost:$PORTNO/postgres?sslmode=disable"
    #export path so dbmate can find correct psql and pg_dump
    export PATH="$PSQLBIN:$PATH"
    # run init scripts
    if ! dbmate --migrations-dir "$MIGRATIONS_DIR/init-scripts" up; then
        echo "Error: Initial migration failed"
        exit 1
    fi

    # Password update command
    if ! "${PSQLBIN}/psql" -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U postgres -p "$PORTNO" -h localhost -c "ALTER USER supabase_admin WITH PASSWORD '$PGPASSWORD'"; then
        echo "Error: Failed to update supabase_admin password"
        exit 1
    fi

    # Set up database URL
    export DATABASE_URL="postgres://$PGSQL_SUPERUSER:$PGPASSWORD@localhost:$PORTNO/postgres?sslmode=disable"
    # Run migrations
    if ! dbmate --migrations-dir "$MIGRATIONS_DIR/migrations" up; then
        echo "Error: Final migration failed"
        exit 1
    fi

    echo "Running dbmate dump with $PSQLBIN"
    perform_dump

    echo "CURRENT_SYSTEM: $CURRENT_SYSTEM"
    if [ -f "./db/schema.sql" ]; then
        trim_schema
        cp "./db/schema.sql" "./migrations/schema-$PSQL_VERSION.sql"
        echo "Schema file moved to ./migrations/schema-$PSQL_VERSION.sql"
        echo "PSQLBIN is $PSQLBIN"
    else
        echo "Warning: schema.sql file not found in ./db directory"
        exit 1
    fi

    # If we get here, all commands succeeded
    echo "PostgreSQL migration completed successfully"
    echo "Check migrations are idempotent"
    for sql in ./migrations/db/migrations/*.sql; do
        echo "$0: running $sql"
        "${PSQLBIN}/psql" -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U "$PGSQL_SUPERUSER" -p "$PORTNO" -h localhost -d postgres -f "$sql" || {
            echo "Failed to execute $sql"
            exit 1
        }
    done
}

if [ "$PSQL_VERSION" == "all" ]; then
    VERSIONS=$(yq '.postgres_major[]' "$ANSIBLE_VARS" | tr -d '"')
    echo "$VERSIONS" | while read -r version; do
        PSQL_VERSION="$version"
        echo "Migrating to PostgreSQL version $PSQL_VERSION"
        migrate_version
        cleanup
    done
else
    echo "Migrating to PostgreSQL version $PSQL_VERSION"
    migrate_version
    cleanup
fi

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/tools/run-client.sh.in ---
#!/usr/bin/env bash
# shellcheck shell=bash

[ ! -z "$DEBUG" ] && set -x

# Default values
PSQL_VERSION="15"
MIGRATION_FILE=""
PORTNO="@PGSQL_DEFAULT_PORT@"
PSQL_USER="postgres"

# Function to display help
print_help() {
    echo "Usage: nix run .#start-client -- [options]"
    echo
    echo "Options:"
    echo "  -v, --version [15|16|orioledb-16]  Specify the PostgreSQL version to use (required)"
    echo "  -f, --file FILE                    Provide a custom migration script"
    echo "  -u, --user USER                    Specify the user/role to use (default: postgres)"
    echo "  -h, --help                         Show this help message"
    echo
    echo "Description:"
    echo "  Starts an interactive 'psql' session connecting to a Postgres database started with the"
    echo "  'nix run .#start-server' command. If a migration file is not provided, the client"
    echo "  initializes the database with the default migrations for a new Supabase project."
    echo "  If a migrations file is provided, default migrations are skipped"
    echo "  If no migration file is provided, it runs the default Supabase migrations."
    echo
    echo "Examples:"
    echo "  nix run .#start-client"
    echo "  nix run .#start-client -- --version 15"
    echo "  nix run .#start-client -- --version 16 --file custom_migration.sql"
    echo "  nix run .#start-client -- --version 16 --port 5433"
    echo "  nix run .#start-client -- --version 16 --user supabase_admin"
}

# Parse arguments
while [[ "$#" -gt 0 ]]; do
    case "$1" in
        -v|--version)
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                PSQL_VERSION="$2"
                shift 2
            else
                echo "Error: --version requires an argument (15, 16, or orioledb-16)"
                exit 1
            fi
            ;;
        -f|--file)
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                MIGRATION_FILE="$2"
                shift 2
            else
                echo "Error: --file requires a filename"
                exit 1
            fi
            ;;
        -u|--user)
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                PSQL_USER="$2"
                shift 2
            else
                echo "Error: --user requires an argument"
                exit 1
            fi
            ;;
        -p|--port)
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                PORTNO="$2"
                shift 2
            else
                echo "Error: --port requires an argument"
                exit 1
            fi
            ;;
        -h|--help)
            print_help
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            print_help
            exit 1
            ;;
    esac
done

# Check if version is provided
if [[ -z "$PSQL_VERSION" ]]; then
    echo "Error: PostgreSQL version is required."
    print_help
    exit 1
fi

# Determine PostgreSQL version
if [ "$PSQL_VERSION" == "15" ]; then
    echo "Starting client for PSQL 15"
    PSQL15=@PSQL15_BINDIR@
    BINDIR="$PSQL15"
elif [ "$PSQL_VERSION" == "16" ]; then
    echo "Starting client for PSQL 16"
    PSQL16=@PSQL16_BINDIR@
    BINDIR="$PSQL16"
elif [ "$PSQL_VERSION" == "orioledb-17" ]; then
    echo "Starting client for PSQL ORIOLEDB 17"
    PSQLORIOLEDB16=@PSQLORIOLEDB17_BINDIR@
    BINDIR="$PSQLORIOLEDB16"
else
    echo "Please provide a valid Postgres version (15, 16, or orioledb-16)"
    exit 1
fi

#vars for migration.sh
export PATH=$BINDIR/bin:$PATH
export POSTGRES_DB=postgres
export POSTGRES_HOST=localhost

PGSQL_SUPERUSER=@PGSQL_SUPERUSER@
MIGRATIONS_DIR=@MIGRATIONS_DIR@
POSTGRESQL_SCHEMA_SQL=@POSTGRESQL_SCHEMA_SQL@
PGBOUNCER_AUTH_SCHEMA_SQL=@PGBOUNCER_AUTH_SCHEMA_SQL@
STAT_EXTENSION_SQL=@STAT_EXTENSION_SQL@

# Start interactive psql session
exec psql -U "$PSQL_USER" -p "$PORTNO" -h localhost postgres

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/tools/run-restore.sh.in ---
#!/usr/bin/env bash
# shellcheck shell=bash

set -euo pipefail

# Function to display help message
show_help() {
    echo "Usage: nix run .#pg-restore -- [OPTIONS]"
    echo
    echo "Run pg_restore with the specified parameters."
    echo
    echo "Options:"
    echo "  --version     PostgreSQL version (currently only 15 is supported)"
    echo "  --dbname      Name of the database to restore to"
    echo "  --host        Host of the database server"
    echo "  --user        Database user to connect as"
    echo "  --file        Path to the file to restore from (absolute or relative to current directory)"
    echo "  --port        Port number (default: 5432)"
    echo "  -h, --help    Show this help message and exit"
    echo "Example:"
    echo "nix run .#pg-restore --  --version 15 --dbname postgres --host localhost --user postgres --port 5435 --file my.dump"
}

# Initialize variables
PG_VERSION=""
DBNAME=""
DBHOST=""
DBUSER=""
RESTORE_FILE=""
PORT="5432"

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --version)
            PG_VERSION="$2"
            shift 2
            ;;
        --dbname)
            DBNAME="$2"
            shift 2
            ;;
        --host)
            DBHOST="$2"
            shift 2
            ;;
        --user)
            DBUSER="$2"
            shift 2
            ;;
        --file)
            RESTORE_FILE="$2"
            shift 2
            ;;
        --port)
            PORT="$2"
            shift 2
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
done

# Check if all required arguments are provided
if [ -z "$PG_VERSION" ] || [ -z "$DBNAME" ] || [ -z "$DBHOST" ] || [ -z "$DBUSER" ] || [ -z "$RESTORE_FILE" ]; then
    echo "Error: Missing required arguments."
    show_help
    exit 1
fi

if [ "$PG_VERSION" == "15" ]; then
    echo "Starting restore for PSQL 15"
    PSQL15=@PSQL15_BINDIR@
    PSQL_BINDIR="$PSQL15"
else
    echo "Error: Please provide a valid Postgres version (currently only 15 is supported)"
    show_help
    exit 1
fi

# Convert RESTORE_FILE to an absolute path if it's relative
if [[ "$RESTORE_FILE" != /* ]]; then
    RESTORE_FILE="$(pwd)/$RESTORE_FILE"
fi

# Check if the file exists
if [ ! -f "$RESTORE_FILE" ]; then
    echo "Error: Restore file '$RESTORE_FILE' does not exist."
    exit 1
fi

echo "Using restore file: $RESTORE_FILE"

# Run pg_restore and capture its exit status
"$PSQL_BINDIR/bin/pg_restore" \
    -h "$DBHOST" \
    -p "$PORT" \
    -U "$DBUSER" \
    -d "$DBNAME" \
    -v \
    --no-owner \
    --no-acl \
    "$RESTORE_FILE"

RESTORE_STATUS=$?

# Check the exit status of pg_restore
if [ $RESTORE_STATUS -eq 0 ]; then
    echo "Restore completed successfully."
    exit 0
else
    echo "Restore failed with exit code $RESTORE_STATUS."
    exit $RESTORE_STATUS
fi
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docker/init.sh.in ---
#!/bin/bash
# shellcheck shell=bash
/bin/initdb --locale=C -D /data/postgresql --username=supabase_admin
ln -s /etc/postgresql.conf /data/postgresql/postgresql.conf
/bin/postgres -p @PGSQL_DEFAULT_PORT@ -D /data/postgresql 

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/overlays/psql_16-oriole.nix ---
final: prev: {
  pg_orioledb = prev.postgresql_16.overrideAttrs (old: {
    pname = "postgresql_orioledb";
    version = "16_31";
    src = prev.fetchurl {
      url = "https://github.com/orioledb/postgres/archive/refs/tags/patches16_31.tar.gz";
      sha256 = "sha256-29uHUACwZKh8e4zJ9tWzEhLNjEuh6P31KbpxnMEhtuI=";
    };
    buildInputs = old.buildInputs ++ [
      prev.bison
      prev.docbook5
      prev.docbook_xsl
      prev.docbook_xsl_ns
      prev.docbook_xml_dtd_45
      prev.flex
      prev.libxslt
      prev.perl
    ];
  });
  postgresql_orioledb = final.pg_orioledb;
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/overlays/cargo-pgrx-0-11-3.nix ---
final: prev: {
  #cargo-pgrx_0_11_3 = cargo-pgrx.cargo-pgrx_0_11_3;

  buildPgrxExtension_0_11_3 = prev.buildPgrxExtension.override {
    cargo-pgrx = final.cargo-pgrx_0_11_3;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg_repack.nix ---
{ lib
, stdenv
, fetchFromGitHub
, openssl
, postgresql
, postgresqlTestHook
, readline
, testers
, zlib
}:

stdenv.mkDerivation (finalAttrs: {
  pname = "pg_repack";
  version = "1.5.2";

  buildInputs = postgresql.buildInputs ++ [ postgresql ];

  src = fetchFromGitHub {
    owner = "reorg";
    repo = "pg_repack";
    rev = "ver_${finalAttrs.version}";
    hash = "sha256-wfjiLkx+S3zVrAynisX1GdazueVJ3EOwQEPcgUQt7eA=";
  };

  installPhase = ''
    install -D bin/pg_repack -t $out/bin/
    install -D lib/pg_repack${postgresql.dlSuffix} -t $out/lib/
    install -D lib/{pg_repack--${finalAttrs.version}.sql,pg_repack.control} -t $out/share/postgresql/extension
  '';

  passthru.tests = {
    version = testers.testVersion {
      package = finalAttrs.finalPackage;
    };
    extension = stdenv.mkDerivation {
      name = "plpgsql-check-test";
      dontUnpack = true;
      doCheck = true;
      buildInputs = [ postgresqlTestHook ];
      nativeCheckInputs = [ (postgresql.withPackages (ps: [ ps.pg_repack ])) ];
      postgresqlTestUserOptions = "LOGIN SUPERUSER";
      failureHook = "postgresqlStop";
      checkPhase = ''
        runHook preCheck
        psql -a -v ON_ERROR_STOP=1 -c "CREATE EXTENSION pg_repack;"
        runHook postCheck
      '';
      installPhase = "touch $out";
    };
  };

  meta = with lib; {
    description = "Reorganize tables in PostgreSQL databases with minimal locks";
    longDescription = ''
      pg_repack is a PostgreSQL extension which lets you remove bloat from tables and indexes, and optionally restore
      the physical order of clustered indexes. Unlike CLUSTER and VACUUM FULL it works online, without holding an
      exclusive lock on the processed tables during processing. pg_repack is efficient to boot,
      with performance comparable to using CLUSTER directly.
    '';
    homepage = "https://github.com/reorg/pg_repack";
    license = licenses.bsd3;
    maintainers = with maintainers; [ samrose ];
    inherit (postgresql.meta) platforms;
    mainProgram = "pg_repack";
  };
})

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg_regress.nix ---
{ lib
, stdenv
, postgresql
}:

stdenv.mkDerivation {
  pname = "pg_regress";
  version = postgresql.version;

  phases = [ "installPhase" ];

  installPhase = ''
    mkdir -p $out/bin
    cp ${postgresql}/lib/pgxs/src/test/regress/pg_regress $out/bin/
  '';

  meta = with lib; {
    description = "Regression testing tool for PostgreSQL";
    homepage = "https://www.postgresql.org/";
    maintainers = with maintainers; [ samrose ];
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/vault.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "vault";
  version = "0.2.9";

  buildInputs = [ postgresql ];

  src = fetchFromGitHub {
    owner = "supabase";
    repo = pname;
    rev = "refs/tags/v${version}";
    hash = "sha256-kXTngBW4K6FkZM8HvJG2Jha6OQqbejhnk7tchxy031I=";
  };

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp sql/*.sql $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Store encrypted secrets in PostgreSQL";
    homepage = "https://github.com/supabase/${pname}";
    maintainers = with maintainers; [ samrose ];
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pgjwt.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql, unstableGitUpdater }:

stdenv.mkDerivation rec {
  pname = "pgjwt";
  version = "9742dab1b2f297ad3811120db7b21451bca2d3c9";

  src = fetchFromGitHub {
    owner  = "michelp";
    repo   = "pgjwt";
    rev    = "${version}";
    hash = "sha256-Hw3R9bMGDmh+dMzjmqZSy/rT4mX8cPU969OJiARFg10=";
  };

  dontBuild = true;
  installPhase = ''
    mkdir -p $out/share/postgresql/extension
    cp pg*sql *.control $out/share/postgresql/extension
  '';

  passthru.updateScript = unstableGitUpdater { };

  meta = with lib; {
    description = "PostgreSQL implementation of JSON Web Tokens";
    longDescription = ''
      sign() and verify() functions to create and verify JSON Web Tokens.
    '';
    license = licenses.mit;
    platforms = postgresql.meta.platforms;
    maintainers = with maintainers; [samrose];
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg_cron.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "pg_cron";
  version = "1.6.4";

  buildInputs = [ postgresql ];

  src = fetchFromGitHub {
    owner  = "citusdata";
    repo   = pname;
    rev    = "v${version}";
    hash = "sha256-t1DpFkPiSfdoGG2NgNT7g1lkvSooZoRoUrix6cBID40=";
  };

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp *${postgresql.dlSuffix}      $out/lib
    cp *.sql     $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Run Cron jobs through PostgreSQL";
    homepage    = "https://github.com/citusdata/pg_cron";
    changelog   = "https://github.com/citusdata/pg_cron/raw/v${version}/CHANGELOG.md";
    maintainers = with maintainers; [ samrose ];
    platforms   = postgresql.meta.platforms;
    license     = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/plpgsql-check.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql, postgresqlTestHook }:

stdenv.mkDerivation rec {
  pname = "plpgsql-check";
  version = "2.7.11";

  src = fetchFromGitHub {
    owner = "okbob";
    repo = "plpgsql_check";
    rev = "v${version}";
    hash = "sha256-vR3MvfmUP2QEAtXFpq0NCCKck3wZPD+H3QleHtyVQJs=";
  };

  buildInputs = [ postgresql ];

  installPhase = ''
    install -D -t $out/lib *${postgresql.dlSuffix}
    install -D -t $out/share/postgresql/extension *.sql
    install -D -t $out/share/postgresql/extension *.control
  '';

  passthru.tests.extension = stdenv.mkDerivation {
    name = "plpgsql-check-test";
    dontUnpack = true;
    doCheck = true;
    buildInputs = [ postgresqlTestHook ];
    nativeCheckInputs = [ (postgresql.withPackages (ps: [ ps.plpgsql_check ])) ];
    postgresqlTestUserOptions = "LOGIN SUPERUSER";
    failureHook = "postgresqlStop";
    checkPhase = ''
      runHook preCheck
      psql -a -v ON_ERROR_STOP=1 -c "CREATE EXTENSION plpgsql_check;"
      runHook postCheck
    '';
    installPhase = "touch $out";
  };

  meta = with lib; {
    description = "Linter tool for language PL/pgSQL";
    homepage = "https://github.com/okbob/plpgsql_check";
    changelog = "https://github.com/okbob/plpgsql_check/releases/tag/v${version}";
    platforms = postgresql.meta.platforms;
    license = licenses.mit;
    maintainers = [ maintainers.marsam ];
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/orioledb.nix ---
{ lib, stdenv, fetchFromGitHub, curl, libkrb5, postgresql, python3, openssl }:

stdenv.mkDerivation rec {
  pname = "orioledb";
  name = pname;
  src = fetchFromGitHub {
    owner = "orioledb";
    repo = "orioledb";
    rev = "beta10";
    sha256 = "sha256-O4OTi8ickylVXE9FURm5R++A+l15Z22YLna7OVzVMjc=";
  };
  version = "beta10";
  buildInputs = [ curl libkrb5 postgresql python3 openssl ];
  buildPhase = "make USE_PGXS=1 ORIOLEDB_PATCHSET_VERSION=6";
  installPhase = ''
    runHook preInstall

    mkdir -p $out/{lib,share/postgresql/extension}

    # Copy the extension library
    cp orioledb${postgresql.dlSuffix} $out/lib/

    # Copy sql files from the sql directory
    cp sql/*.sql $out/share/postgresql/extension/

    # Copy control file
    cp orioledb.control $out/share/postgresql/extension/

    runHook postInstall
  '';
  doCheck = true;
  meta = with lib; {
    description = "orioledb";
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg_net.nix ---
{ lib, stdenv, fetchFromGitHub, curl, postgresql }:

stdenv.mkDerivation rec {
  pname = "pg_net";
  version = "0.14.0";

  buildInputs = [ curl postgresql ];

  src = fetchFromGitHub {
    owner = "supabase";
    repo = pname;
    rev = "refs/tags/v${version}";
    hash = "sha256-c1pxhTyrE5j6dY+M5eKAboQNofIORS+Dccz+7HKEKQI=";
  };

  env.NIX_CFLAGS_COMPILE = "-Wno-error";

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp *${postgresql.dlSuffix}      $out/lib
    cp sql/*.sql $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Async networking for Postgres";
    homepage = "https://github.com/supabase/pg_net";
    maintainers = with maintainers; [ samrose ];
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/use-system-groonga.patch ---
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 33b34477..f4ffefe5 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -12,7 +12,6 @@ if(MSVC_VERSION LESS 1800)
   message(FATAL_ERROR "PGroonga supports only MSVC 2013 or later")
 endif()
 
-add_subdirectory(vendor/groonga)
 
 set(PGRN_POSTGRESQL_DIR "${CMAKE_INSTALL_PREFIX}"
   CACHE PATH "PostgreSQL binary directory")
@@ -52,8 +51,6 @@ string(REGEX REPLACE "([0-9]+)\\.([0-9]+)\\.([0-9]+)" "\\3"
 string(REGEX REPLACE ".*comment = '([^']+)'.*" "\\1"
   PGRN_DESCRIPTION "${PGRN_CONTROL}")
 
-file(READ "${CMAKE_CURRENT_SOURCE_DIR}/vendor/groonga/bundled_message_pack_version"
-  PGRN_BUNDLED_MESSAGE_PACK_VERSION)
 string(STRIP
   "${PGRN_BUNDLED_MESSAGE_PACK_VERSION}"
   PGRN_BUNDLED_MESSAGE_PACK_VERSION)
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg_backtrace.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "pg_backtrace";
  version = "1.1";

  buildInputs = [ postgresql ];

  src = fetchFromGitHub {
    owner  = "pashkinelfe";
    repo   = pname;
    rev    = "d100bac815a7365e199263f5b3741baf71b14c70";
    hash = "sha256-IVCL4r4oj1Ams03D8y+XCFkckPFER/W9tQ68GkWQQMY=";
  };

  makeFlags = [ "USE_PGXS=1" ];

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp *${postgresql.dlSuffix}      $out/lib
    cp *.sql     $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Updated fork of pg_backtrace";
    homepage    = "https://github.com/pashkinelfe/pg_backtrace";
    platforms   = postgresql.meta.platforms;
    license     = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pljava.nix ---
{ stdenv, lib, fetchFromGitHub, openssl, openjdk, maven, postgresql, libkrb5, makeWrapper, gcc, pkg-config, which }:

maven.buildMavenPackage rec {
  pname = "pljava";

  version = "1.6.7"; 

  src = fetchFromGitHub {
    owner = "tada";
    repo = "pljava";
    rev = "V1_6_7";  
    sha256 = "sha256-M17adSLsw47KZ2BoUwxyWkXKRD8TcexDAy61Yfw4fNU=";  
    
  };

  mvnParameters = "clean install -Dmaven.test.skip -DskipTests -Dmaven.javadoc.skip=true";  
  mvnHash = "sha256-lcxRduh/nKcPL6YQIVTsNH0L4ga0LgJpQKgX5IPkRzs=";
  
  nativeBuildInputs = [ makeWrapper maven openjdk postgresql openssl postgresql gcc libkrb5 pkg-config ];
  buildInputs = [ stdenv.cc.cc.lib which];
  buildPhase = ''
    export PATH=$(lib.makeBinPath [ postgresql ]):$PATH

  '';
  buildOffline = true;

  installPhase = ''
    mkdir -p $out/pljavabuild
    cp -r *   $out/pljavabuild
    mkdir -p $out/share/postgresql/extension/pljava
    mkdir -p $out/share/postgresql/pljava
    mkdir -p $out/lib
    mkdir -p $out/etc
    java -Dpgconfig=${postgresql}/bin/pg_config \
      -Dpgconfig.sharedir=$out/share \
      -Dpgconfig.sysconfdir=$out/etc/pljava.policy \
      -Dpgconfig.pkglibdir=$out/lib \
      -jar $out/pljavabuild/pljava-packaging/target/pljava-pg15.jar
    cp $out/share/pljava/* $out/share/postgresql/extension/pljava
    cp $out/share/pljava/* $out/share/postgresql/pljava
    cp $out/share/extension/*.control $out/share/postgresql/extension
    rm -r $out/pljavabuild
  '';

  meta = with lib; {
    description = "PL/Java extension for PostgreSQL";
    homepage = https://github.com/tada/pljava;
    license = licenses.bsd3;
    maintainers = [ maintainers.samrose ];  # Update with actual maintainer info
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg_stat_monitor.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

let
  # NOTE (aseipp): the 1.x series of pg_stat_monitor has some non-standard and
  # weird build logic (Percona projects in general seem to have their own
  # strange build harness) where it will try to pick the right .sql file to
  # install into the extension dir based on the postgresql major version. for
  # our purposes, we only need to support v13 and v14+, so just replicate this
  # logic from the makefile and pick the right file here.
  #
  # this seems to all be cleaned up in version 2.0 of the extension, so ideally
  # we could upgrade to it later on and nuke this.
  # DEPRECATED sqlFilename = if lib.versionOlder postgresql.version "14"
  #   then "pg_stat_monitor--1.0.13.sql.in"
  #   else "pg_stat_monitor--1.0.14.sql.in";

in
stdenv.mkDerivation rec {
  pname = "pg_stat_monitor";
  version = "2.1.0";

  buildInputs = [ postgresql ];

  src = fetchFromGitHub {
    owner = "percona";
    repo = pname;
    rev = "refs/tags/${version}";
    hash = "sha256-STJVvvrLVLe1JevNu6u6EftzAWv+X+J8lu66su7Or2s=";
  };

  makeFlags = [ "USE_PGXS=1" ];

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}
  
    cp *${postgresql.dlSuffix}      $out/lib
    cp *.sql     $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Query Performance Monitoring Tool for PostgreSQL";
    homepage = "https://github.com/percona/${pname}";
    maintainers = with maintainers; [ samrose ];
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
    broken = lib.versionOlder postgresql.version "15";
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg_plan_filter.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "pg_plan_filter";
  version = "5081a7b5cb890876e67d8e7486b6a64c38c9a492";

  buildInputs = [ postgresql ];

  src = fetchFromGitHub {
    owner = "pgexperts";
    repo = pname;
    rev = "${version}";
    hash = "sha256-YNeIfmccT/DtOrwDmpYFCuV2/P6k3Zj23VWBDkOh6sw=";
  };

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp *${postgresql.dlSuffix}      $out/lib
    cp *.sql     $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Filter PostgreSQL statements by execution plans";
    homepage = "https://github.com/pgexperts/${pname}";
    maintainers = with maintainers; [ samrose ];
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/postgis.nix ---
{ fetchurl
, lib, stdenv
, perl
, libxml2
, postgresql
, geos
, proj
, json_c
, pkg-config
, file
, protobufc
, libiconv
, pcre2
, nixosTests
, callPackage
}:

let
  sfcgal = callPackage ./sfcgal/sfcgal.nix { };
  gdal = callPackage ./gdal.nix { inherit postgresql; };
in
stdenv.mkDerivation rec {
  pname = "postgis";
  version = "3.3.7";

  outputs = [ "out" "doc" ];

  src = fetchurl {
    url = "https://download.osgeo.org/postgis/source/postgis-${version}.tar.gz";
    sha256 = "sha256-UHJKDd5JrcJT5Z4CTYsY/va+ToU0GUPG1eHhuXTkP84=";
  };

  buildInputs = [ libxml2 postgresql geos proj gdal json_c protobufc pcre2.dev sfcgal ]
                ++ lib.optional stdenv.isDarwin libiconv;
  nativeBuildInputs = [ perl pkg-config ];
  dontDisableStatic = true;


  env.NIX_LDFLAGS = "-L${lib.getLib json_c}/lib";

  preConfigure = ''
    sed -i 's@/usr/bin/file@${file}/bin/file@' configure
    configureFlags="--datadir=$out/share/postgresql --datarootdir=$out/share/postgresql --bindir=$out/bin --docdir=$doc/share/doc/${pname} --with-gdalconfig=${gdal}/bin/gdal-config --with-jsondir=${json_c.dev} --disable-extension-upgrades-install --with-sfcgal"

    makeFlags="PERL=${perl}/bin/perl datadir=$out/share/postgresql pkglibdir=$out/lib bindir=$out/bin docdir=$doc/share/doc/${pname}"
  '';

  postConfigure = ''
    sed -i "s|@mkdir -p \$(DESTDIR)\$(PGSQL_BINDIR)||g ;
            s|\$(DESTDIR)\$(PGSQL_BINDIR)|$prefix/bin|g
            " \
        "raster/loader/Makefile";
    sed -i "s|\$(DESTDIR)\$(PGSQL_BINDIR)|$prefix/bin|g
            " \
        "raster/scripts/python/Makefile";
    mkdir -p $out/bin
    ln -s ${postgresql}/bin/postgres $out/bin/postgres
  '';

postInstall = ''
  rm $out/bin/postgres
  for prog in $out/bin/*; do # */
    ln -s $prog $prog-${version}
  done
  # Add function definition and usage to tiger geocoder files
  for file in $out/share/postgresql/extension/postgis_tiger_geocoder*--${version}.sql; do
      sed -i "/SELECT postgis_extension_AddToSearchPath('tiger');/a SELECT postgis_extension_AddToSearchPath('extensions');" "$file"
  done
  # Original topology patching
  for file in $out/share/postgresql/extension/postgis_topology*--${version}.sql; do
    sed -i "/SELECT topology.AddToSearchPath('topology');/i SELECT topology.AddToSearchPath('extensions');" "$file"
  done
  mkdir -p $doc/share/doc/postgis
  mv doc/* $doc/share/doc/postgis/
'';

  passthru.tests.postgis = nixosTests.postgis;

  meta = with lib; {
    description = "Geographic Objects for PostgreSQL";
    homepage = "https://postgis.net/";
    changelog = "https://git.osgeo.org/gitea/postgis/postgis/raw/tag/${version}/NEWS";
    license = licenses.gpl2;
    maintainers = with maintainers; [ samrose ];
    inherit (postgresql.meta) platforms;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/plv8.nix ---
{ stdenv
, lib
, fetchFromGitHub
, v8
, perl
, postgresql
# For passthru test on various systems, and local development on macos
# not we are not currently using passthru tests but retaining for possible contrib
# to nixpkgs 
, runCommand
, coreutils
, gnugrep
, clang
, xcbuild
, darwin
, patchelf
}:

stdenv.mkDerivation (finalAttrs: {
  pname = "plv8";
  version = "3.1.10";

  src = fetchFromGitHub {
    owner = "plv8";
    repo = "plv8";
    rev = "v${finalAttrs.version}";
    hash = "sha256-g1A/XPC0dX2360Gzvmo9/FSQnM6Wt2K4eR0pH0p9fz4=";
  };

  patches = [
    # Allow building with system v8.
    # https://github.com/plv8/plv8/pull/505 (rejected)
    ./0001-build-Allow-using-V8-from-system.patch
  ];

  nativeBuildInputs = [
    perl
  ] ++ lib.optionals stdenv.isDarwin [
    clang
    xcbuild
  ];

  buildInputs = [
    v8
    postgresql
  ] ++ lib.optionals stdenv.isDarwin [
    darwin.apple_sdk.frameworks.CoreFoundation
    darwin.apple_sdk.frameworks.Kerberos
  ];

  buildFlags = [ "all" ];

  makeFlags = [
    # Nixpkgs build a v8 monolith instead of separate v8_libplatform.
    "USE_SYSTEM_V8=1"
    "V8_OUTDIR=${v8}/lib"
     "PG_CONFIG=${postgresql}/bin/pg_config"
  ] ++ lib.optionals stdenv.isDarwin [
    "CC=${clang}/bin/clang"
    "CXX=${clang}/bin/clang++"
    "SHLIB_LINK=-L${v8}/lib -lv8_monolith -Wl,-rpath,${v8}/lib"
  ] ++ lib.optionals (!stdenv.isDarwin) [
    "SHLIB_LINK=-lv8"
  ];

  NIX_LDFLAGS = (lib.optionals stdenv.isDarwin [
    "-L${postgresql}/lib"
    "-L${v8}/lib"
    "-lv8_monolith"
    "-lpq"
    "-lpgcommon"
    "-lpgport"
    "-F${darwin.apple_sdk.frameworks.CoreFoundation}/Library/Frameworks"
    "-framework" "CoreFoundation"
    "-F${darwin.apple_sdk.frameworks.Kerberos}/Library/Frameworks"
    "-framework" "Kerberos"
    "-undefined" "dynamic_lookup"
    "-flat_namespace"
  ]); 

  installFlags = [
    # PGXS only supports installing to postgresql prefix so we need to redirect this
    "DESTDIR=${placeholder "out"}"
  ];

  # No configure script.
  dontConfigure = true;

  postPatch = ''
    patchShebangs ./generate_upgrade.sh
    substituteInPlace generate_upgrade.sh \
      --replace " 2.3.10 " " 2.3.10 2.3.11 2.3.12 2.3.13 2.3.14 2.3.15 "

    ${lib.optionalString stdenv.isDarwin ''
      # Replace g++ with clang++ in Makefile
      sed -i 's/g++/clang++/g' Makefile
    ''}
  '';

 postInstall = ''
    # Move the redirected to proper directory.
    # There appear to be no references to the install directories
    # so changing them does not cause issues.
    mv "$out/nix/store"/*/* "$out"
    rmdir "$out/nix/store"/* "$out/nix/store" "$out/nix"

    # Handle different PostgreSQL versions
    if [ "${lib.versions.major postgresql.version}" = "15" ]; then
      mv "$out/lib/plv8-${finalAttrs.version}.so" "$out/lib/plv8.so"
      ln -s "$out/lib/plv8.so" "$out/lib/plv8-${finalAttrs.version}.so"
      sed -i 's|module_pathname = '"'"'$libdir/plv8-[0-9.]*'"'"'|module_pathname = '"'"'$libdir/plv8'"'"'|' "$out/share/postgresql/extension/plv8.control"
      sed -i 's|module_pathname = '"'"'$libdir/plv8-[0-9.]*'"'"'|module_pathname = '"'"'$libdir/plv8'"'"'|' "$out/share/postgresql/extension/plcoffee.control"
      sed -i 's|module_pathname = '"'"'$libdir/plv8-[0-9.]*'"'"'|module_pathname = '"'"'$libdir/plv8'"'"'|' "$out/share/postgresql/extension/plls.control"

      ${lib.optionalString stdenv.isDarwin ''
        install_name_tool -add_rpath "${v8}/lib" $out/lib/plv8.so
        install_name_tool -add_rpath "${postgresql}/lib" $out/lib/plv8.so
        install_name_tool -add_rpath "${stdenv.cc.cc.lib}/lib" $out/lib/plv8.so
        install_name_tool -change @rpath/libv8_monolith.dylib ${v8}/lib/libv8_monolith.dylib $out/lib/plv8.so
      ''}

      ${lib.optionalString (!stdenv.isDarwin) ''
        ${patchelf}/bin/patchelf --set-rpath "${v8}/lib:${postgresql}/lib:${stdenv.cc.cc.lib}/lib" $out/lib/plv8.so
      ''}
    else
      ${lib.optionalString stdenv.isDarwin ''
        install_name_tool -add_rpath "${v8}/lib" $out/lib/plv8-${finalAttrs.version}${postgresql.dlSuffix}
        install_name_tool -add_rpath "${postgresql}/lib" $out/lib/plv8-${finalAttrs.version}${postgresql.dlSuffix}
        install_name_tool -add_rpath "${stdenv.cc.cc.lib}/lib" $out/lib/plv8-${finalAttrs.version}${postgresql.dlSuffix}
        install_name_tool -change @rpath/libv8_monolith.dylib ${v8}/lib/libv8_monolith.dylib $out/lib/plv8-${finalAttrs.version}${postgresql.dlSuffix}
      ''}

      ${lib.optionalString (!stdenv.isDarwin) ''
        ${patchelf}/bin/patchelf --set-rpath "${v8}/lib:${postgresql}/lib:${stdenv.cc.cc.lib}/lib" $out/lib/plv8-${finalAttrs.version}${postgresql.dlSuffix}
      ''}
    fi
  '';

  meta = with lib; {
    description = "V8 Engine Javascript Procedural Language add-on for PostgreSQL";
    homepage = "https://plv8.github.io/";
    maintainers = with maintainers; [ samrose ];
    platforms = [ "x86_64-linux" "aarch64-linux" "aarch64-darwin" "x86_64-darwin" ];
    license = licenses.postgresql;
  };
})

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg_partman.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "pg_partman";
  version = "5.1.0";

  buildInputs = [ postgresql ];

  src = fetchFromGitHub {
    owner  = "pgpartman";
    repo   = pname;
    rev    = "refs/tags/v${version}";
    sha256 = "sha256-GrVOJ5ywZMyqyDroYDLdKkXDdIJSDGhDfveO/ZvrmYs=";
  };

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp src/*${postgresql.dlSuffix} $out/lib
    cp updates/*     $out/share/postgresql/extension
    cp -r sql/*      $out/share/postgresql/extension
    cp *.control     $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Partition management extension for PostgreSQL";
    homepage    = "https://github.com/pgpartman/pg_partman";
    changelog   = "https://github.com/pgpartman/pg_partman/blob/v${version}/CHANGELOG.md";
    maintainers = with maintainers; [ samrose ];
    platforms   = postgresql.meta.platforms;
    license     = licenses.postgresql;
    broken      = versionOlder postgresql.version "14";
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg_hashids.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "pg_hashids";
  version = "cd0e1b31d52b394a0df64079406a14a4f7387cd6";

  buildInputs = [ postgresql ];

  src = fetchFromGitHub {
    owner = "iCyberon";
    repo = pname;
    rev = "${version}";
    hash = "sha256-Nmb7XLqQflYZfqj0yrewfb1Hl5YgEB5wfjBunPwIuOU=";
  };

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp *${postgresql.dlSuffix}      $out/lib
    cp *.sql     $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Generate short unique IDs in PostgreSQL";
    homepage = "https://github.com/iCyberon/pg_hashids";
    maintainers = with maintainers; [ samrose ];
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg-safeupdate.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "pg-safeupdate";
  version = "1.4";

  buildInputs = [ postgresql ];

  src = fetchFromGitHub {
    owner  = "eradman";
    repo   = pname;
    rev    = version;
    hash = "sha256-1cyvVEC9MQGMr7Tg6EUbsVBrMc8ahdFS3+CmDkmAq4Y=";
  };

  installPhase = ''
    install -D safeupdate${postgresql.dlSuffix} -t $out/lib
  '';

  meta = with lib; {
    description = "A simple extension to PostgreSQL that requires criteria for UPDATE and DELETE";
    homepage    = "https://github.com/eradman/pg-safeupdate";
    changelog   = "https://github.com/eradman/pg-safeupdate/raw/${src.rev}/NEWS";
    platforms   = postgresql.meta.platforms;
    license     = licenses.postgresql;
    broken      = versionOlder postgresql.version "14";
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pgroonga.nix ---
{ lib, stdenv, fetchurl, pkg-config, postgresql, msgpack-c, callPackage, mecab, makeWrapper, xxHash  }:
let
  supabase-groonga = callPackage ../supabase-groonga.nix { };
in
stdenv.mkDerivation rec {
  pname = "pgroonga";
  version = "3.2.5";
  src = fetchurl {
    url = "https://packages.groonga.org/source/${pname}/${pname}-${version}.tar.gz";
    sha256 = "sha256-GM9EOQty72hdE4Ecq8jpDudhZLiH3pP9ODLxs8DXcSY=";
  };
  nativeBuildInputs = [ pkg-config makeWrapper ];
  
  buildInputs = [ postgresql msgpack-c supabase-groonga mecab ] ++ lib.optionals stdenv.isDarwin [
    xxHash
  ];

  propagatedBuildInputs = [ supabase-groonga ];
  configureFlags = [
    "--with-mecab=${mecab}"
    "--enable-mecab"
    "--with-groonga=${supabase-groonga}"
    "--with-groonga-plugin-dir=${supabase-groonga}/lib/groonga/plugins"
  ];

 makeFlags = [
    "HAVE_MSGPACK=1"
    "MSGPACK_PACKAGE_NAME=msgpack-c"
    "HAVE_MECAB=1"
  ];

  NIX_CFLAGS_COMPILE = lib.optionalString stdenv.isDarwin (builtins.concatStringsSep " " [
    "-Wno-error=incompatible-function-pointer-types"
    "-Wno-error=format"
    "-Wno-format"
    "-I${supabase-groonga}/include/groonga"
    "-I${xxHash}/include"
    "-DPGRN_VERSION=\"${version}\""
  ]);

  preConfigure = ''
    export GROONGA_LIBS="-L${supabase-groonga}/lib -lgroonga"
    export GROONGA_CFLAGS="-I${supabase-groonga}/include"
    export MECAB_CONFIG="${mecab}/bin/mecab-config"
    ${lib.optionalString stdenv.isDarwin ''
      export CPPFLAGS="-I${supabase-groonga}/include/groonga -I${xxHash}/include -DPGRN_VERSION=\"${version}\""
      export CFLAGS="-I${supabase-groonga}/include/groonga -I${xxHash}/include -DPGRN_VERSION=\"${version}\""
      export PG_CPPFLAGS="-Wno-error=incompatible-function-pointer-types -Wno-error=format"
    ''}
  '';

  installPhase = ''
    mkdir -p $out/lib $out/share/postgresql/extension $out/bin
    install -D pgroonga${postgresql.dlSuffix} -t $out/lib/
    install -D pgroonga.control -t $out/share/postgresql/extension
    install -D data/pgroonga-*.sql -t $out/share/postgresql/extension
    install -D pgroonga_database${postgresql.dlSuffix} -t $out/lib/
    install -D pgroonga_database.control -t $out/share/postgresql/extension
    install -D data/pgroonga_database-*.sql -t $out/share/postgresql/extension

    echo "Debug: Groonga plugins directory contents:"
    ls -l ${supabase-groonga}/lib/groonga/plugins/tokenizers/
  '';

  meta = with lib; {
    description = "A PostgreSQL extension to use Groonga as the index";
    longDescription = ''
      PGroonga is a PostgreSQL extension to use Groonga as the index.
      PostgreSQL supports full text search against languages that use only alphabet and digit.
      It means that PostgreSQL doesn't support full text search against Japanese, Chinese and so on.
      You can use super fast full text search feature against all languages by installing PGroonga into your PostgreSQL.
    '';
    homepage = "https://pgroonga.github.io/";
    changelog = "https://github.com/pgroonga/pgroonga/releases/tag/${version}";
    license = licenses.postgresql;
    platforms = postgresql.meta.platforms;
    maintainers = with maintainers; [ samrose ];
  };
}
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/wal2json.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "wal2json";
  version = "2_6";

  src = fetchFromGitHub {
    owner = "eulerto";
    repo = "wal2json";
    rev = "wal2json_${builtins.replaceStrings ["."] ["_"] version}";
    hash = "sha256-+QoACPCKiFfuT2lJfSUmgfzC5MXf75KpSoc2PzPxKyM=";
  };

  buildInputs = [ postgresql ];

  makeFlags = [ "USE_PGXS=1" ];

  installPhase = ''
    install -D -t $out/lib *${postgresql.dlSuffix}
    install -D -t $out/share/postgresql/extension sql/*.sql
  '';

  meta = with lib; {
    description = "PostgreSQL JSON output plugin for changeset extraction";
    homepage = "https://github.com/eulerto/wal2json";
    changelog = "https://github.com/eulerto/wal2json/releases/tag/wal2json_${version}";
    maintainers = with maintainers; [ samrose ];
    platforms = postgresql.meta.platforms;
    license = licenses.bsd3;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/supautils.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "supautils";
  version = "2.6.0";

  buildInputs = [ postgresql ];

  src = fetchFromGitHub {
    owner = "supabase";
    repo = pname;
    rev = "refs/tags/v${version}";
    hash = "sha256-QNfUpQjqHNzbNqBvjb5a3GtNH9hjbBMDUK19xUU3LpI=";
  };

  installPhase = ''
    mkdir -p $out/lib

    install -D *${postgresql.dlSuffix} -t $out/lib
  '';

  meta = with lib; {
    description = "PostgreSQL extension for enhanced security";
    homepage = "https://github.com/supabase/${pname}";
    maintainers = with maintainers; [ steve-chavez ];
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg_graphql.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql, buildPgrxExtension_0_12_6, cargo, rust-bin }:
let
  rustVersion = "1.80.0";
  cargo = rust-bin.stable.${rustVersion}.default;
in
buildPgrxExtension_0_12_6 rec {
  pname = "pg_graphql";
  version = "1.5.9";
  inherit postgresql;

  src = fetchFromGitHub {
    owner = "supabase";
    repo = pname;
    rev = "v${version}";
    hash = "sha256-YpLN43FtLhp2cb7cyM+4gEx8GTwsRiKTfxaMq0b8hk0=";
  };

  nativeBuildInputs = [ cargo ];
  buildInputs = [ postgresql ];
  
  CARGO="${cargo}/bin/cargo";
  #darwin env needs PGPORT to be unique for build to not clash with other pgrx extensions
  env = lib.optionalAttrs stdenv.isDarwin {
    POSTGRES_LIB = "${postgresql}/lib";
    RUSTFLAGS = "-C link-arg=-undefined -C link-arg=dynamic_lookup";
    PGPORT = "5434";
  };
  cargoHash = "sha256-d2RSHtJgbYlOvArjOTaeYoca01UyWPUEO5vhktxxB6U=";

  # FIXME (aseipp): disable the tests since they try to install .control
  # files into the wrong spot, aside from that the one main test seems
  # to work, though
  doCheck = false;

  meta = with lib; {
    description = "GraphQL support for PostreSQL";
    homepage = "https://github.com/supabase/${pname}";
    maintainers = with maintainers; [ samrose ];
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/age.nix ---
{ lib, stdenv, fetchurl, postgresql, openssl, bison, flex, pkgs }: # Added pkgs

let
  pgMajorStr = lib.versions.major postgresql.version; # e.g., "15" or "17"
  ageVersion = "1.5.0"; # This is the AGE version, defined here

  ageSrcInfo =
    if pgMajorStr == "15" then {
      url = "https://dlcdn.apache.org/age/PG15/${ageVersion}/apache-age-${ageVersion}-src.tar.gz";
      hash = "sha256-7iuLsE/XKgcLo48vzUpZBJcs67oJwoCL817RPAua8nA="; # Hash for PG15 AGE 1.5.0 src
      isSupported = true;
    } else if pgMajorStr == "16" then { # If you add a PG16 target later
      url = "https://dlcdn.apache.org/age/PG16/${ageVersion}/apache-age-${ageVersion}-src.tar.gz";
      # IMPORTANT: You would need to prefetch this hash for the PG16 source tarball
      hash = "sha256-PLEASE_PREFETCH_AND_FILL_FOR_PG16_AGE_1.5.0_SRC";
      isSupported = true; # Assuming AGE 1.5.0 for PG16 exists and you want to support it
    } else { # Covers PG17 (from orioledb-17) and any other unsupported versions
      isSupported = false;
      url = ""; # Dummy URL to prevent fetchurl error during evaluation for unsupported versions
      hash = ""; # Dummy hash
    };
in
stdenv.mkDerivation rec {
  pname = "age";
  version = ageVersion; # Explicitly set version to ageVersion

  # Conditionally fetch source or use a dummy if unsupported
  src = if ageSrcInfo.isSupported then fetchurl {
    url = ageSrcInfo.url;
    sha256 = ageSrcInfo.hash;
  } else pkgs.runCommand "fake-age-src-${pname}-${version}" {} "mkdir -p $out"; # Dummy src

  nativeBuildInputs = [ bison flex ];
  buildInputs = [ postgresql openssl ];

  makeFlags = [
    "PG_CONFIG=${postgresql}/bin/pg_config"
    # Corrected PG_CPPFLAGS from previous attempt, assuming ${src} points to unpacked root
    "PG_CPPFLAGS=-I${src}/include -I${src}/include/catalog -I${src}/src/include -I${src}/src/include/catalog -Wno-error -Wno-deprecated-non-prototype -Wno-cast-function-type-strict"
  ];

  preBuild = ''
    # This phase will not run if src is the dummy derivation
    if [ ! -f "${src}/include/catalog/ag_catalog.h" ]; then
      echo "Skipping preBuild checks for dummy source or ag_catalog.h not found where expected."
      echo "Attempted path: ${src}/include/catalog/ag_catalog.h"
      # If it's a real source and the file is missing, it's an error.
      # If it's the dummy source, this 'if' body won't execute meaningfully.
      if [ -d "${src}/include" ]; then # Check if it's a real source directory
          echo "ERROR: ag_catalog.h not found in a real source directory!"
          ls -R ${src} # List contents for debugging
          exit 1
      fi
    else
      echo "Found ag_catalog.h in ${src}/include/catalog"
    fi
    if ! command -v flex >/dev/null 2>&1; then
      echo "ERROR: flex is not found in the build environment. Path: $PATH"
      exit 1
    fi
    echo "Flex version: $(flex --version)"
  '';

  installPhase = if ageSrcInfo.isSupported then ''
    runHook preInstall

    make install DESTDIR=$out PG_CONFIG=${postgresql}/bin/pg_config

    PKGLIBDIR=$(${postgresql}/bin/pg_config --pkglibdir)
    SHAREDIR=$(${postgresql}/bin/pg_config --sharedir)

    mkdir -p $out/lib
    mkdir -p $out/share/postgresql/extension

    found_so=false
    if [ -d "$out$PKGLIBDIR" ]; then
        echo "Looking for .so in $out$PKGLIBDIR"
        if mv $out$PKGLIBDIR/age*.so $out/lib/ 2>/dev/null; then
            found_so=true
            echo "Moved .so from $out$PKGLIBDIR"
        fi
    fi
    if [ "$found_so" = "false" ] && [ -d "$out/usr/local/pgsql/lib" ]; then # Common fallback for non-DESTDIR compliant makefiles
        echo "AGE .so not found in specific pkglibdir, trying $out/usr/local/pgsql/lib"
        if mv $out/usr/local/pgsql/lib/age*.so $out/lib/ 2>/dev/null; then
            found_so=true
            echo "Moved .so from $out/usr/local/pgsql/lib"
        fi
    fi
    if [ "$found_so" = "false" ]; then
        echo "AGE .so not found in pkglibdir, searching more broadly in $out"
        find "$out" -name "age*.so" -print -exec mv {} $out/lib/ \; || echo "Still no .so found"
    fi

    found_control_sql=false
    if [ -d "$out$SHAREDIR/extension" ]; then
        echo "Looking for control/sql in $out$SHAREDIR/extension"
        if mv $out$SHAREDIR/extension/age*.* $out/share/postgresql/extension/ 2>/dev/null; then
            found_control_sql=true
            echo "Moved control/sql from $out$SHAREDIR/extension"
        fi
    fi
    if [ "$found_control_sql" = "false" ] && [ -d "$out/usr/local/pgsql/share/extension" ]; then # Common fallback
         echo "AGE control/sql not found in specific sharedir, trying $out/usr/local/pgsql/share/extension"
        if mv $out/usr/local/pgsql/share/extension/age*.* $out/share/postgresql/extension/ 2>/dev/null; then
            found_control_sql=true
            echo "Moved control/sql from $out/usr/local/pgsql/share/extension"
        fi
    fi
    if [ "$found_control_sql" = "false" ]; then
        echo "AGE control/sql files not found in sharedir, searching more broadly in $out"
        find "$out" -path "*/extension/age.control" -print -exec mv {} $out/share/postgresql/extension/ \; || echo "age.control not found"
        find "$out" -path "*/extension/age--*.sql" -print -exec mv {} $out/share/postgresql/extension/ \; || echo "age SQL files not found"
    fi

    if [ -d "$out/usr" ]; then find "$out/usr" -depth -type d -empty -delete; fi
    if [ -d "$out/nix" ]; then find "$out/nix" -depth -type d -empty -delete; fi

    echo "Final .so files in $out/lib:"
    ls -lR $out/lib | grep age || echo "No age .so files in $out/lib"
    echo "Final .control/.sql files in $out/share/postgresql/extension:"
    ls -lR $out/share/postgresql/extension | grep age || echo "No age control/sql files in $out/share/postgresql/extension"

    runHook postInstall
  '' else ''
    echo "Skipping install for unsupported AGE/PG combination for ${pname}-${version}."
    mkdir -p $out/lib $out/share/postgresql/extension # Create empty dirs so the derivation is valid
  '';

  meta = with lib; {
    description = "Apache AGE graph database extension for PostgreSQL";
    homepage = "https://age.apache.org/";
    license = licenses.asl20;
    platforms = postgresql.meta.platforms;
    maintainers = [ maintainers.barneycook ];
    broken = !ageSrcInfo.isSupported; # Mark as broken if not supported for this PG major version
  };
}
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pgsql-http.nix ---
{ lib, stdenv, fetchFromGitHub, curl, postgresql }:

stdenv.mkDerivation rec {
  pname = "pgsql-http";
  version = "1.6.1";

  buildInputs = [ curl postgresql ];

  src = fetchFromGitHub {
    owner = "pramsey";
    repo = pname;
    rev = "refs/tags/v${version}";
    hash = "sha256-C8eqi0q1dnshUAZjIsZFwa5FTYc7vmATF3vv2CReWPM=";
  };

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp *${postgresql.dlSuffix}      $out/lib
    cp *.sql     $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "HTTP client for Postgres";
    homepage = "https://github.com/pramsey/${pname}";
    maintainers = with maintainers; [ samrose ];
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pgaudit.nix ---
{ lib, stdenv, fetchFromGitHub, libkrb5, openssl, postgresql }:
#adapted from https://github.com/NixOS/nixpkgs/blob/master/pkgs/servers/sql/postgresql/ext/pgaudit.nix
let
  source = {
    "17" = {
      version = "17.0";
      hash = "sha256-3ksq09wiudQPuBQI3dhEQi8IkXKLVIsPFgBnwLiicro=";
    };
    "16" = {
      version = "16.0";
      hash = "sha256-8+tGOl1U5y9Zgu+9O5UDDE4bec4B0JC/BQ6GLhHzQzc=";
    };
    "15" = {
      version = "1.7.0";
      hash = "sha256-8pShPr4HJaJQPjW1iPJIpj3CutTx8Tgr+rOqoXtgCcw=";
    };
  }.${lib.versions.major postgresql.version} or (throw "Source for pgaudit is not available for ${postgresql.version}");
in
stdenv.mkDerivation {
  pname = "pgaudit";
  inherit (source) version;

  src = fetchFromGitHub {
    owner = "pgaudit";
    repo = "pgaudit";
    rev = source.version;
    hash = source.hash;
  };

  buildInputs = [ libkrb5 openssl postgresql ];

  makeFlags = [ "USE_PGXS=1" ];

  installPhase = ''
    install -D -t $out/lib pgaudit${postgresql.dlSuffix}
    install -D -t $out/share/postgresql/extension *.sql
    install -D -t $out/share/postgresql/extension *.control
  '';

  meta = with lib; {
    description = "Open Source PostgreSQL Audit Logging";
    homepage = "https://github.com/pgaudit/pgaudit";
    changelog = "https://github.com/pgaudit/pgaudit/releases/tag/${source.version}";
    maintainers = with maintainers; [ samrose ];
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pgsodium.nix ---
{ lib, stdenv, fetchFromGitHub, libsodium, postgresql }:

stdenv.mkDerivation rec {
  pname = "pgsodium";
  version = "3.1.8";

  buildInputs = [ libsodium postgresql ];

  src = fetchFromGitHub {
    owner = "michelp";
    repo = pname;
    rev = "refs/tags/v${version}";
    hash = "sha256-j5F1PPdwfQRbV8XJ8Mloi8FvZF0MTl4eyIJcBYQy1E4=";
  };

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp *${postgresql.dlSuffix}      $out/lib
    cp sql/*.sql $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Modern cryptography for PostgreSQL";
    homepage = "https://github.com/michelp/${pname}";
    maintainers = with maintainers; [ samrose ];
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pgtap.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql, perl, perlPackages, which }:

stdenv.mkDerivation rec {
  pname = "pgtap";
  version = "1.2.0";

  src = fetchFromGitHub {
    owner = "theory";
    repo = "pgtap";
    rev = "v${version}";
    hash = "sha256-lb0PRffwo6J5a6Hqw1ggvn0cW7gPZ02OEcLPi9ineI8=";
  };

  nativeBuildInputs = [ postgresql perl perlPackages.TAPParserSourceHandlerpgTAP which ];

  installPhase = ''
    install -D {sql/pgtap--${version}.sql,pgtap.control} -t $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "A unit testing framework for PostgreSQL";
    longDescription = ''
      pgTAP is a unit testing framework for PostgreSQL written in PL/pgSQL and PL/SQL.
      It includes a comprehensive collection of TAP-emitting assertion functions,
      as well as the ability to integrate with other TAP-emitting test frameworks.
      It can also be used in the xUnit testing style.
    '';
    maintainers = with maintainers; [ samrose ];
    homepage = "https://pgtap.org";
    inherit (postgresql.meta) platforms;
    license = licenses.mit;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/hypopg.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "hypopg";
  version = "1.4.1";

  buildInputs = [ postgresql ];

  src = fetchFromGitHub {
    owner = "HypoPG";
    repo = pname;
    rev = "refs/tags/${version}";
    hash = "sha256-88uKPSnITRZ2VkelI56jZ9GWazG/Rn39QlyHKJKSKMM=";
  };

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp *${postgresql.dlSuffix}      $out/lib
    cp *.sql     $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Hypothetical Indexes for PostgreSQL";
    homepage = "https://github.com/HypoPG/${pname}";
    maintainers = with maintainers; [ samrose ];
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pgrouting.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql, perl, cmake, boost }:

stdenv.mkDerivation rec {
  pname = "pgrouting";
  version = "3.4.1";

  nativeBuildInputs = [ cmake perl ];
  buildInputs = [ postgresql boost ];

  src = fetchFromGitHub {
    owner  = "pgRouting";
    repo   = pname;
    rev    = "v${version}";
    hash = "sha256-QC77AnPGpPQGEWi6JtJdiNsB2su5+aV2pKg5ImR2B0k=";
  };

  #disable compile time warnings for incompatible pointer types only on macos and pg16
  NIX_CFLAGS_COMPILE = lib.optionalString (stdenv.isDarwin && lib.versionAtLeast postgresql.version "16") 
  "-Wno-error=int-conversion -Wno-error=incompatible-pointer-types";

  cmakeFlags = [
    "-DPOSTGRESQL_VERSION=${postgresql.version}"
  ] ++ lib.optionals (stdenv.isDarwin && lib.versionAtLeast postgresql.version "16")  [
    "-DCMAKE_MACOSX_RPATH=ON"
    "-DCMAKE_SHARED_MODULE_SUFFIX=.dylib"
    "-DCMAKE_SHARED_LIBRARY_SUFFIX=.dylib"
  ];

  preConfigure = lib.optionalString (stdenv.isDarwin && lib.versionAtLeast postgresql.version "16") ''
    export DLSUFFIX=.dylib
    export CMAKE_SHARED_LIBRARY_SUFFIX=.dylib
    export CMAKE_SHARED_MODULE_SUFFIX=.dylib
    export MACOSX_RPATH=ON
  '';

  postBuild = lib.optionalString (stdenv.isDarwin && lib.versionAtLeast postgresql.version "16") ''
    shopt -s nullglob
    for file in lib/libpgrouting-*.so; do
      if [ -f "$file" ]; then
        mv "$file" "''${file%.so}.dylib"
      fi
    done
    shopt -u nullglob
  '';

  installPhase = ''
    install -D lib/*${postgresql.dlSuffix}                       -t $out/lib
    install -D sql/pgrouting--*.sql   -t $out/share/postgresql/extension
    install -D sql/common/pgrouting.control    -t $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "A PostgreSQL/PostGIS extension that provides geospatial routing functionality";
    homepage    = "https://pgrouting.org/";
    changelog   = "https://github.com/pgRouting/pgrouting/releases/tag/v${version}";
    maintainers = with maintainers; [ steve-chavez samrose ];
    platforms   = postgresql.meta.platforms;
    license     = licenses.gpl2Plus;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/0001-build-Allow-using-V8-from-system.patch ---
diff --git a/Makefile b/Makefile
index 38879cc..6e78eeb 100644
--- a/Makefile
+++ b/Makefile
@@ -20,6 +20,7 @@ OBJS = $(SRCS:.cc=.o)
 MODULE_big = plv8-$(PLV8_VERSION)
 EXTENSION = plv8
 PLV8_DATA = plv8.control plv8--$(PLV8_VERSION).sql
+USE_SYSTEM_V8 = 0
 
 
 # Platform detection
@@ -41,6 +42,7 @@ PGXS := $(shell $(PG_CONFIG) --pgxs)
 PG_VERSION_NUM := $(shell cat `$(PG_CONFIG) --includedir-server`/pg_config*.h \
 		   | perl -ne 'print $$1 and exit if /PG_VERSION_NUM\s+(\d+)/')
 
+ifeq ($(USE_SYSTEM_V8),0)
 AUTOV8_DIR = build/v8
 AUTOV8_OUT = build/v8/out.gn/obj
 AUTOV8_STATIC_LIBS = -lv8_libplatform -lv8_libbase
@@ -66,6 +68,7 @@ v8:
 	make -f Makefiles/Makefile.macos v8
 endif
 endif
+endif
 
 # enable direct jsonb conversion by default
 CCFLAGS += -DJSONB_DIRECT_CONVERSION
@@ -83,6 +86,7 @@ ifdef BIGINT_GRACEFUL
 endif
 
 
+ifeq ($(USE_SYSTEM_V8),0)
 # We're gonna build static link.  Rip it out after include Makefile
 SHLIB_LINK := $(filter-out -lv8, $(SHLIB_LINK))
 
@@ -101,6 +105,7 @@ else
 		SHLIB_LINK += -lrt -std=c++14 
 	endif
 endif
+endif
 
 DATA = $(PLV8_DATA)
 ifndef DISABLE_DIALECT
-- 
2.37.3

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/rum.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "rum";
  version = "1.3.14";

  src = fetchFromGitHub {
    owner = "postgrespro";
    repo = "rum";
    rev = version;
    hash = "sha256-VsfpxQqRBu9bIAP+TfMRXd+B3hSjuhU2NsutocNiCt8=";
  };

  buildInputs = [ postgresql ];

  makeFlags = [ "USE_PGXS=1" ];

  installPhase = ''
    install -D -t $out/lib *${postgresql.dlSuffix}
    install -D -t $out/share/postgresql/extension *.control
    install -D -t $out/share/postgresql/extension *.sql
  '';

  meta = with lib; {
    description = "Full text search index method for PostgreSQL";
    homepage = "https://github.com/postgrespro/rum";
    license = licenses.postgresql;
    platforms = postgresql.meta.platforms;
    maintainers = with maintainers; [ samrose ];
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/gdal.nix ---
{ lib
, stdenv
, fetchFromGitHub
, cmake
, pkg-config
, curl
, expat
, libgeotiff
, geos
, json_c
, libxml2
, postgresql
, proj
, sqlite
, libtiff
, zlib
}:

stdenv.mkDerivation rec  {
  pname = "gdal";
  version = "3.8.5";

  src = fetchFromGitHub {
    owner = "OSGeo";
    repo = "gdal";
    rev = "v${version}";
    hash = "sha256-Z+mYlyOX9vJ772qwZMQfCbD/V7RL6+9JLHTzoZ55ot0=";
  };

  nativeBuildInputs = [
    cmake
    pkg-config
  ];

  buildInputs = [
    curl
    expat
    libgeotiff
    geos
    json_c
    libxml2
    postgresql
    proj
    sqlite
    libtiff
    zlib
  ];

  cmakeFlags = [
    "-DGDAL_USE_INTERNAL_LIBS=OFF"
    "-DGEOTIFF_INCLUDE_DIR=${lib.getDev libgeotiff}/include"
    "-DGEOTIFF_LIBRARY_RELEASE=${lib.getLib libgeotiff}/lib/libgeotiff${stdenv.hostPlatform.extensions.sharedLibrary}"
    "-DBUILD_PYTHON_BINDINGS=OFF"
  ] ++ lib.optionals (!stdenv.isDarwin) [
    "-DCMAKE_SKIP_BUILD_RPATH=ON"
  ] ++ lib.optionals stdenv.isDarwin [
    "-DCMAKE_BUILD_WITH_INSTALL_NAME_DIR=ON"
  ];

  enableParallelBuilding = true;

  meta = with lib; {
    description = "Translator library for raster geospatial data formats (PostGIS-focused build)";
    homepage = "https://www.gdal.org/";
    license = licenses.mit;
    maintainers = with maintainers; teams.geospatial.members ++ [ marcweber dotlambda ];
    platforms = platforms.unix;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg_jsonschema.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql, buildPgrxExtension_0_12_6, cargo, rust-bin }:
let
  rustVersion = "1.80.0";
  cargo = rust-bin.stable.${rustVersion}.default;
in
buildPgrxExtension_0_12_6 rec {
  pname = "pg_jsonschema";
  version = "0.3.3";
  inherit postgresql;

  src = fetchFromGitHub {
    owner = "supabase";
    repo = pname;
    rev = "v${version}";
    hash = "sha256-Au1mqatoFKVq9EzJrpu1FVq5a1kBb510sfC980mDlsU=";
  };

  nativeBuildInputs = [ cargo ];
  buildInputs = [ postgresql ];
  # update the following array when the pg_jsonschema version is updated
  # required to ensure that extensions update scripts from previous versions are generated

  previousVersions = ["0.3.1" "0.3.0" "0.2.0" "0.1.4" "0.1.4" "0.1.2" "0.1.1" "0.1.0"];
  CARGO="${cargo}/bin/cargo";
  #darwin env needs PGPORT to be unique for build to not clash with other pgrx extensions
  env = lib.optionalAttrs stdenv.isDarwin {
    POSTGRES_LIB = "${postgresql}/lib";
    RUSTFLAGS = "-C link-arg=-undefined -C link-arg=dynamic_lookup";
    PGPORT = "5433";
  };

  cargoLock = {
    lockFile = "${src}/Cargo.lock";
    allowBuiltinFetchGit = false;
  };
  
  # FIXME (aseipp): testsuite tries to write files into /nix/store; we'll have
  # to fix this a bit later.
  doCheck = false;

  preBuild = ''
    echo "Processing git tags..."
    echo '${builtins.concatStringsSep "," previousVersions}' | sed 's/,/\n/g' > git_tags.txt
  '';

  postInstall = ''
    echo "Creating SQL files for previous versions..."
    current_version="${version}"
    sql_file="$out/share/postgresql/extension/pg_jsonschema--$current_version.sql"
    
    if [ -f "$sql_file" ]; then
      while read -r previous_version; do
        if [ "$(printf '%s\n' "$previous_version" "$current_version" | sort -V | head -n1)" = "$previous_version" ] && [ "$previous_version" != "$current_version" ]; then
          new_file="$out/share/postgresql/extension/pg_jsonschema--$previous_version--$current_version.sql"
          echo "Creating $new_file"
          cp "$sql_file" "$new_file"
        fi
      done < git_tags.txt
    else
      echo "Warning: $sql_file not found"
    fi
    rm git_tags.txt
  '';


  meta = with lib; {
    description = "JSON Schema Validation for PostgreSQL";
    homepage = "https://github.com/supabase/${pname}";
    maintainers = with maintainers; [ samrose ];
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/timescaledb.nix ---
{ lib, stdenv, fetchFromGitHub, cmake, postgresql, openssl, libkrb5 }:

stdenv.mkDerivation rec {
  pname = "timescaledb-apache";
  version = "2.16.1";

  nativeBuildInputs = [ cmake ];
  buildInputs = [ postgresql openssl libkrb5 ];

  src = fetchFromGitHub {
    owner = "timescale";
    repo = "timescaledb";
    rev = version;
    hash = "sha256-sLxWdBmih9mgiO51zLLxn9uwJVYc5JVHJjSWoADoJ+w=";
  };

  cmakeFlags = [ "-DSEND_TELEMETRY_DEFAULT=OFF" "-DREGRESS_CHECKS=OFF" "-DTAP_CHECKS=OFF" "-DAPACHE_ONLY=1" ]
    ++ lib.optionals stdenv.isDarwin [ "-DLINTER=OFF" ];

  # Fix the install phase which tries to install into the pgsql extension dir,
  # and cannot be manually overridden. This is rather fragile but works OK.
  postPatch = ''
    for x in CMakeLists.txt sql/CMakeLists.txt; do
      substituteInPlace "$x" \
        --replace 'DESTINATION "''${PG_SHAREDIR}/extension"' "DESTINATION \"$out/share/postgresql/extension\""
    done

    for x in src/CMakeLists.txt src/loader/CMakeLists.txt tsl/src/CMakeLists.txt; do
      substituteInPlace "$x" \
        --replace 'DESTINATION ''${PG_PKGLIBDIR}' "DESTINATION \"$out/lib\""
    done
  '';

  meta = with lib; {
    description = "Scales PostgreSQL for time-series data via automatic partitioning across time and space";
    homepage = "https://www.timescale.com/";
    changelog = "https://github.com/timescale/timescaledb/blob/${version}/CHANGELOG.md";
    maintainers = with maintainers; [ samrose ];
    platforms = postgresql.meta.platforms;
    license = licenses.asl20;
    broken = versionOlder postgresql.version "13";
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pgmq.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "pgmq";
  version = "1.4.4";
  buildInputs = [ postgresql ];
  src = fetchFromGitHub {
    owner  = "tembo-io";
    repo   = pname;
    rev    = "v${version}";
    hash = "sha256-z+8/BqIlHwlMnuIzMz6eylmYbSmhtsNt7TJf/CxbdVw=";
  };

  buildPhase = ''
    cd pgmq-extension
  '';

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    mv sql/pgmq.sql $out/share/postgresql/extension/pgmq--${version}.sql
    cp sql/*.sql $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "A lightweight message queue. Like AWS SQS and RSMQ but on Postgres.";
    homepage    = "https://github.com/tembo-io/pgmq";
    maintainers = with maintainers; [ olirice ];
    platforms   = postgresql.meta.platforms;
    license     = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg_tle.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql, flex, openssl, libkrb5 }:

stdenv.mkDerivation rec {
  pname = "pg_tle";
  version = "1.4.0";

  nativeBuildInputs = [ flex ];
  buildInputs = [ openssl postgresql libkrb5 ];

  src = fetchFromGitHub {
    owner = "aws";
    repo = pname;
    rev = "refs/tags/v${version}";
    hash = "sha256-crxj5R9jblIv0h8lpqddAoYe2UqgUlnvbOajKTzVces=";
  };

  
  makeFlags = [ "FLEX=flex" ];

  
  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp *${postgresql.dlSuffix}      $out/lib
    cp *.sql     $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Framework for 'Trusted Language Extensions' in PostgreSQL";
    homepage = "https://github.com/aws/${pname}";
    maintainers = with maintainers; [ samrose ];
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/timescaledb-2.9.1.nix ---
{ lib, stdenv, fetchFromGitHub, cmake, postgresql, openssl, libkrb5 }:

stdenv.mkDerivation rec {
  pname = "timescaledb-apache";
  version = "2.9.1";

  nativeBuildInputs = [ cmake ];
  buildInputs = [ postgresql openssl libkrb5 ];

  src = fetchFromGitHub {
    owner = "timescale";
    repo = "timescaledb";
    rev = version;
    hash = "sha256-fvVSxDiGZAewyuQ2vZDb0I6tmlDXl6trjZp8+qDBtb8=";
  };

  cmakeFlags = [ "-DSEND_TELEMETRY_DEFAULT=OFF" "-DREGRESS_CHECKS=OFF" "-DTAP_CHECKS=OFF" "-DAPACHE_ONLY=1" ]
    ++ lib.optionals stdenv.isDarwin [ "-DLINTER=OFF" ];

  # Fix the install phase which tries to install into the pgsql extension dir,
  # and cannot be manually overridden. This is rather fragile but works OK.
  postPatch = ''
    for x in CMakeLists.txt sql/CMakeLists.txt; do
      substituteInPlace "$x" \
        --replace 'DESTINATION "''${PG_SHAREDIR}/extension"' "DESTINATION \"$out/share/postgresql/extension\""
    done

    for x in src/CMakeLists.txt src/loader/CMakeLists.txt tsl/src/CMakeLists.txt; do
      substituteInPlace "$x" \
        --replace 'DESTINATION ''${PG_PKGLIBDIR}' "DESTINATION \"$out/lib\""
    done
  '';


  # timescaledb-2.9.1.so already exists in the lib directory
  # we have no need for the timescaledb.so or control file
  postInstall = ''
    rm $out/lib/timescaledb.so
    rm $out/share/postgresql/extension/timescaledb.control
  '';

  meta = with lib; {
    description = "Scales PostgreSQL for time-series data via automatic partitioning across time and space";
    homepage = "https://www.timescale.com/";
    changelog = "https://github.com/timescale/timescaledb/blob/${version}/CHANGELOG.md";
    maintainers = with maintainers; [ samrose ];
    platforms = postgresql.meta.platforms;
    license = licenses.asl20;
    broken = versionOlder postgresql.version "13";
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pgvector.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "pgvector";
  version = "0.8.0";

  buildInputs = [ postgresql ];

  src = fetchFromGitHub {
    owner = "pgvector";
    repo = pname;
    rev = "refs/tags/v${version}";
    hash = "sha256-JsZV+I4eRMypXTjGmjCtMBXDVpqTIPHQa28ogXncE/Q=";
  };

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp *${postgresql.dlSuffix}      $out/lib
    cp sql/*.sql $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Open-source vector similarity search for Postgres";
    homepage = "https://github.com/${src.owner}/${src.repo}";
    maintainers = with maintainers; [ olirice ];
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/index_advisor.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "index_advisor";
  version = "0.2.0";

  buildInputs = [ postgresql ];

  src = fetchFromGitHub {
    owner = "olirice";
    repo = pname;
    rev = "v${version}";
    hash = "sha256-G0eQk2bY5CNPMeokN/nb05g03CuiplRf902YXFVQFbs=";
  };

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp *.sql     $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Recommend indexes to improve query performance in PostgreSQL";
    homepage = "https://github.com/olirice/index_advisor";
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}



'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/wrappers/default.nix ---
{ lib
, stdenv
, fetchFromGitHub
, openssl
, pkg-config
, postgresql
, buildPgrxExtension_0_12_6
, cargo
, darwin
, jq
, rust-bin
, git
}:
let
  rustVersion = "1.80.0";
  cargo = rust-bin.stable.${rustVersion}.default;
in
buildPgrxExtension_0_12_6 rec {
  pname = "supabase-wrappers";
  version = "0.4.4";
  # update the following array when the wrappers version is updated
  # required to ensure that extensions update scripts from previous versions are generated
  previousVersions = ["0.4.3" "0.4.2" "0.4.1" "0.4.0" "0.3.1" "0.3.0" "0.2.0" "0.1.19" "0.1.18" "0.1.17" "0.1.16" "0.1.15" "0.1.14" "0.1.12" "0.1.11" "0.1.10" "0.1.9" "0.1.8" "0.1.7" "0.1.6" "0.1.5" "0.1.4" "0.1.1" "0.1.0"];
  inherit postgresql;
  src = fetchFromGitHub {
    owner = "supabase";
    repo = "wrappers";
    rev = "v${version}";
    hash = "sha256-QoGFJpq8PuvMM8SS+VZd7MlNl56uFivRjs1tCtwX+oE=";
  };
 
  nativeBuildInputs = [ pkg-config cargo git ];
  buildInputs = [ openssl postgresql ] ++ lib.optionals (stdenv.isDarwin) [ 
    darwin.apple_sdk.frameworks.CoreFoundation 
    darwin.apple_sdk.frameworks.Security 
    darwin.apple_sdk.frameworks.SystemConfiguration 
  ];

  NIX_LDFLAGS = "-L${postgresql}/lib -lpq";

  # Set necessary environment variables for pgrx
  env = lib.optionalAttrs stdenv.isDarwin {
    POSTGRES_LIB = "${postgresql}/lib";
    RUSTFLAGS = "-C link-arg=-undefined -C link-arg=dynamic_lookup";
    PGPORT = "5435";
  };

  OPENSSL_NO_VENDOR = 1;
  #need to set this to 2 to avoid cpu starvation
  CARGO_BUILD_JOBS = "2";
  CARGO="${cargo}/bin/cargo";
  
  #CARGO_NET_GIT_FETCH_WITH_CLI = "true";
  cargoLock = {
    lockFile = "${src}/Cargo.lock";
    allowBuiltinFetchGit = false;
    outputHashes = {
      "clickhouse-rs-1.1.0-alpha.1" = "sha256-G+v4lNP5eK2U45D1fL90Dq24pUSlpIysNCxuZ17eac0=";
    };
  };

 preConfigure = ''
    cd wrappers
    
    # update the clickhouse-rs dependency
    # append the branch name to the git URL to help cargo locate the commit
    # while maintaining the rev for reproducibility
    awk -i inplace '
    /\[dependencies.clickhouse-rs\]/ {
      print
      getline
      if ($0 ~ /git =/) {
        print "git = \"https://github.com/suharev7/clickhouse-rs/async-await\""
      } else {
        print
      }
      while ($0 !~ /^\[/ && NF > 0) {
        getline
        if ($0 ~ /rev =/) print
        if ($0 ~ /^\[/) print
      }
      next
    }
    { print }
    ' Cargo.toml
    
    # Verify the file is still valid TOML, break build with this error
    # if it is not
    if ! cargo verify-project 2>/dev/null; then
      echo "Failed to maintain valid TOML syntax"
      exit 1
    fi
    
    cd ..
  '';
  
  buildAndTestSubdir = "wrappers";
  buildFeatures = [
    "helloworld_fdw"
    "all_fdws"
  ];
  doCheck = false;

  preBuild = ''
    echo "Processing git tags..."
    echo '${builtins.concatStringsSep "," previousVersions}' | sed 's/,/\n/g' > git_tags.txt
  '';

 postInstall = ''
   echo "Modifying main SQL file to use unversioned library name..."
   current_version="${version}"
   main_sql_file="$out/share/postgresql/extension/wrappers--$current_version.sql"
   if [ -f "$main_sql_file" ]; then
     sed -i 's|$libdir/wrappers-[0-9.]*|$libdir/wrappers|g' "$main_sql_file"
     echo "Modified $main_sql_file"
   else
     echo "Warning: $main_sql_file not found"
   fi
   echo "Creating and modifying SQL files for previous versions..."
   
   if [ -f "$main_sql_file" ]; then
     while read -r previous_version; do
       if [ "$(printf '%s\n' "$previous_version" "$current_version" | sort -V | head -n1)" = "$previous_version" ] && [ "$previous_version" != "$current_version" ]; then
         new_file="$out/share/postgresql/extension/wrappers--$previous_version--$current_version.sql"
         echo "Creating $new_file"
         cp "$main_sql_file" "$new_file"
         sed -i 's|$libdir/wrappers-[0-9.]*|$libdir/wrappers|g' "$new_file"
         echo "Modified $new_file"
       fi
     done < git_tags.txt
   else
     echo "Warning: $main_sql_file not found"
   fi
   mv $out/lib/wrappers-${version}${postgresql.dlSuffix} $out/lib/wrappers${postgresql.dlSuffix}
   ln -s $out/lib/wrappers${postgresql.dlSuffix} $out/lib/wrappers-${version}${postgresql.dlSuffix}
 
  echo "Creating wrappers.so symlinks to support pg_upgrade..."
  if [ -f "$out/lib/wrappers.so" ]; then
    while read -r previous_version; do
      if [ "$(printf '%s\n' "$previous_version" "$current_version" | sort -V | head -n1)" = "$previous_version" ] && [ "$previous_version" != "$current_version" ]; then
        new_file="$out/lib/wrappers-$previous_version.so"
        echo "Creating $new_file"
        ln -s "$out/lib/wrappers.so" "$new_file"
      fi
    done < git_tags.txt
  else
    echo "Warning: $out/lib/wrappers.so not found"
  fi

   rm git_tags.txt
   echo "Contents of updated wrappers.control:"
   cat "$out/share/postgresql/extension/wrappers.control"
   echo "List of generated SQL files:"
   ls -l $out/share/postgresql/extension/wrappers--*.sql
 '';

  meta = with lib; {
    description = "Various Foreign Data Wrappers (FDWs) for PostreSQL";
    homepage = "https://github.com/supabase/wrappers";
    maintainers = with maintainers; [ samrose ];
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/mecab-naist-jdic/default.nix ---
{ lib, stdenv, fetchurl, mecab }:

stdenv.mkDerivation rec {
  pname = "mecab-naist-jdic";
  version = "0.6.3b-20111013";
  
  src = fetchurl {
    url = "https://github.com/supabase/mecab-naist-jdic/raw/main/mecab-naist-jdic-${version}.tar.gz";
    sha256 = "sha256-yzdwDcmne5U/K/OxW0nP7NZ4SFMKLPirywm1lMpWKMw=";
  };
  
  buildInputs = [ mecab ];
  
  configureFlags = [
    "--with-charset=utf8"
  ];

  buildPhase = ''
    runHook preBuild
    make
    ${mecab}/libexec/mecab/mecab-dict-index -d . -o . -f UTF-8 -t utf-8
    runHook postBuild
  '';
  
  installPhase = ''
    runHook preInstall
    
    mkdir -p $out/lib/mecab/dic/naist-jdic
    cp *.dic *.bin *.def $out/lib/mecab/dic/naist-jdic/
    
    runHook postInstall
  '';
  
  meta = with lib; {
    description = "Naist Japanese Dictionary for MeCab";
    homepage = "https://taku910.github.io/mecab/";
    license = licenses.gpl2;
    platforms = platforms.unix;
    maintainers = with maintainers; [ samrose ];
  };
}
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/sfcgal/sfcgal.nix ---
{ lib, stdenv, fetchFromGitLab, cgal, cmake, pkg-config, gmp, mpfr, boost }:

stdenv.mkDerivation rec {
  pname = "sfcgal";
  version = "61f3b08ade49493b56c6bafa98c7c1f84addbc10";

  src = fetchFromGitLab {
    owner = "sfcgal";
    repo = "SFCGAL";
    rev = "${version}";
    hash = "sha256-nKSqiFyMkZAYptIeShb1zFg9lYSny3kcGJfxdeTFqxw=";
  };

  nativeBuildInputs = [ cmake pkg-config cgal gmp mpfr boost ];

  cmakeFlags = [ "-DCGAL_DIR=${cgal}" "-DCMAKE_PREFIX_PATH=${cgal}" ];


  postPatch = ''
    substituteInPlace sfcgal.pc.in \
      --replace '$'{prefix}/@CMAKE_INSTALL_LIBDIR@ @CMAKE_INSTALL_FULL_LIBDIR@
  '';

  meta = with lib; {
    description = "A wrapper around CGAL that intents to implement 2D and 3D operations on OGC standards models";
    homepage = "https://sfcgal.gitlab.io/SFCGAL/";
    license = with licenses; [ gpl3Plus lgpl3Plus];
    platforms = platforms.all;
    maintainers = with maintainers; [ samrose ];
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/start-here.md ---
Let's go ahead and install Nix. To do that, we'll use the
**[nix-installer tool]** by Determinate Systems. This works on many platforms,
but most importantly it works on **aarch64 Linux** and **x86_64 Linux**. Use the
following command in your shell, **it should work on any Linux distro of your
choice**:

[nix-installer tool]: https://github.com/DeterminateSystems/nix-installer

```bash
curl \
  --proto '=https' --tlsv1.2 \
  -sSf -L https://install.determinate.systems/nix \
| sh -s -- install
```

After you do this, **you must log in and log back out of your desktop
environment** to get a new login session. This is so that your shell can have
the Nix tools installed on `$PATH` and so that your user shell can see some
extra settings.

You should now be able to do something like the following; try running these
same commands on your machine:

```
$ nix --version
nix (Nix) 2.16.1
```

```
$ nix run nixpkgs#nix-info -- -m
 - system: `"x86_64-linux"`
 - host os: `Linux 5.15.90.1-microsoft-standard-WSL2, Ubuntu, 22.04.2 LTS (Jammy Jellyfish), nobuild`
 - multi-user?: `yes`
 - sandbox: `yes`
 - version: `nix-env (Nix) 2.16.1`
 - channels(root): `"nixpkgs"`
 - nixpkgs: `/nix/var/nix/profiles/per-user/root/channels/nixpkgs`
```

If the above worked, you're now cooking with gas!

> _**NOTE**_: While there is an upstream tool to install Nix, written in Bash,
> we use the Determinate Systems installer — which will hopefully replace the
> original — because it's faster, and takes care of several extra edge cases
> that the original one couldn't handle, and makes several changes to the
> default installed configuration to make things more user friendly. Determinate
> Systems is staffed by many long-time Nix contributors and the creator of Nix,
> and is trustworthy.

## Do some fun stuff

One of the best things about Nix that requires _very little_ knowledge of it is
that it lets you install the latest and greatest versions of many tools _on any
Linux distribution_. We'll explain more about that later on. But just as a few
examples:

- **Q**: I want the latest version of Deno. Can we get that?
- **A**: `nix profile install nixpkgs#deno`, and you're done!

<!-- break bulletpoints -->

- **Q**: What about HTTPie? A nice Python application?
- **A**: Same idea: `nix profile install nixpkgs#httpie`

<!-- break bulletpoints -->

- **Q**: What about my favorite Rust applications, like ripgrep and bat?
- **A.1**: `nix profile install nixpkgs#ripgrep`
- **A.2**: `nix profile install nixpkgs#bat`
- **A.3**: And yes, you also have exa, fd, hyperfine, and more!

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/start-client-server.md ---
## Running the server

If you want to run a postgres server, just do this from the root of the
repository:

```
nix run .#start-server 15
```

Replace the `15` with a `16`, and you'll be using a different version. Optionally you can specify a second argument for the port.

You likely have a running postgres, so to not cause a conflict, this uses port 5435 by default.

Actually, you don't even need the repository. You can do this from arbitrary
directories, if the left-hand side of the hash character (`.` in this case) is a
valid "flake reference":

```
# from any arbitrary directory
nix run github:supabase/postgres#start-server 15
```

### Arbitrary versions at arbitrary git revisions

Let's say you want to use a PostgreSQL build from a specific version of the
repository. You can change the syntax of the above to use _any_ version of the
repository, at any time, by adding the commit hash after the repository name:

```
# use postgresql 15 build at commit <some commit hash>
nix run github:supabase/postgres/<some commit hash>#start-server 15
```

## Running the client

All of the same rules apply, but try using `start-client` on the right-hand side
of the hash character, instead. For example:

```
nix run github:supabase/postgres#start-server 15 &
sleep 5
nix run github:supabase/postgres#start-client 16
```

## Running a server replica

To start a replica you can use the `start-postgres-replica` command.

- first argument: the master version
- second argument: the master port
- third argument: the replica server port

First start a server and a couple of replicas:

```
$ start-postgres-server 15 5435

$ start-postgres-replica 15 5439

$ start-postgres-replica 15 5440
```

Now check the master server:

```
$ start-postgres-client 15 5435
```

```sql
SELECT client_addr, state
FROM pg_stat_replication;
 client_addr |   state
-------------+-----------
 ::1         | streaming
 ::1         | streaming
(2 rows)

create table items as select x::int from generate_series(1,100) x;
```

And a replica:

```
$ start-postgres-client 15 5439
```

```sql
select count(*) from items;
 count
-------
   100
(1 row)
```

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/adding-tests.md ---
There are basically two types of tests you can add:

- pgTAP based tests, and
- pg\_regress tests
- Migration tests.

In all cases, a number of extensions may be installed into the database for
use; you can see those in both [postgresql.conf.in](../tests/postgresql.conf.in)
and [prime.sql](../tests/prime.sql) (extensions may be enabled in either place.)

## pg\_regress tests

pg\_regress tests are in [tests/sql](./../tests/sql/) with output in [tests/expected](./../tests/expected/).
To create a new test, create a new SQL file in [tests/sql](./../tests/sql/) and then run:

```
nix flake check -L
```

Next, review the logs to identify where the test output was written

```
postgres> CREATE EXTENSION IF NOT EXISTS index_advisor;
postgres> CREATE EXTENSION  
postgres> (using postmaster on localhost, port 5432)    
postgres> ============== running regression test queries        ==============
postgres> test new_test                     ... diff: /nix/store/5gk419ddz7mzzwhc9j6yj5i8lkw67pdl-tests/expected/new_test.out: No such file or directory
postgres> diff command failed with status 512: diff  "/nix/store/5gk419ddz7mzzwhc9j6yj5i8lkw67pdl-tests/expected/new_test.out" "/nix/store/2fbrvnnr7iz6yigyf0rb0vxnyqvrgxzp-postgres-15.6-check-harness/regression_output/results/new_test.out" > "/nix/store/2fbrvnnr7iz6yigyf0rb0vxnyqvrgxzp-postgres-15.6-check-harness/regression_output/results/new_test.out.diff
```

and copy the `regression_output` directory to where you can review

```
cp -r /nix/store/2fbrvnnr7iz6yigyf0rb0vxnyqvrgxzp-postgres-15.6-check-harness/regression_output .
```

Then you can review the contents of `regression_output/results/new_test.out` to see if it matches what you expected.

If it does match your expectations, copy the file to [tests/expected](./../tests/expected/) and the test will pass on the next run.

If the output does not match your expectations, update the `<new_test>.sql` file, re-run with `nix flake check -L` and try again


## pgTAP tests

These are super easy: simply add `.sql` files to the
[tests/smoke](./../tests/smoke/) directory, then:

```
nix flake check -L
```

(`-L` prints logs to stderrr, for more details see `man nix`)

These files are run using `pg_prove`; they pretty much behave exactly like how
you expect; you can read
[the pgTAP documentation](https://pgtap.org/documentation.html) for more.

For a good example of a pgTAP test as a pull request, check out
[pull request #4](https://github.com/supabase/nix-postgres/pull/4/files).

## Re-running tests

`nix flake check` gets its results cached, so if you do it again the tests won't rerun. If you change a file then it will run again.

<!-- If you want to force rerun without modifying a file, you can do:

```
nix build .#checks.x86_64-linux.psql_15 --rebuild
nix build .#checks.x86_64-linux.psql_16 --rebuild
```
-->

Limitation: currently there's no way to rerun all the tests, so you have to specify the check attribute.

To get the correct attribute (`#checks.x86_64-linux.psql_15` above), you can do `nix flake show`. This will show a tree with all the output attributes.

## Migration tests

> **NOTE**: Currently, migration tests _do not happen in CI_. They can only be
> run manually.

Migration tests are pretty simple in the sense they follow a very simple
principle:

- You put data in the database
- Run the migration procedure
- It should probably not fail

Step 1 and 2 are easy, and for various reasons (e.g. mistakes from upstream
extension authors), step 3 isn't guaranteed, so that's what the whole idea is
designed to test.

To add data into the database, modify the
[data.sql](../nix/tests/migrations/data.sql) script and add whatever you want into
it. This script gets loaded into the old version of the database at startup, and
it's expected that the new version of the database can handle it.

To run the `migration-test` tool, check out the documentation on
[migration-tests](./migration-tests.md).

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/new-major-postgres.md ---
PostgreSQL versions are managed in upstream nixpkgs.

See this example PR to add a new version of PostgreSQL; this version is for 16
beta3, but any version is roughly the same. In short, you need to:

- Add a new version and hash
- Possibly patch the source code for minor refactorings
  - In this example, an old patch had to be rewritten because a function was
    split into two different functions; the patch is functionally equivalent but
    textually different
- Add the changes to `all-packages.nix`
- Integrate inside the CI and get code review
- Run `nix flake update` to get a new version, once it's ready

https://github.com/NixOS/nixpkgs/pull/249030

## Adding the major version to this repository

It isn't well abstracted, unfortunately. In short: look for the strings `14` and
`15` under `flake.nix` and `nix/tools/`. More specifically:

- Add `psql_XX` to `basePackages` in `flake.nix`
- Ditto with `checks` in `flake.nix`
- Modify the tools under `tools/` to understand the new major version
- Make sure the CI is integrated under the GitHub Actions.

The third step and fourth steps are the most annoying, really. The first two are
easy and by that point you can run `nix flake check` in order to test the build,
at least.

## Other notes

See also issue [#6](https://github.com/supabase/nix-postgres/issues/6), which
would make it possible to define PostgreSQL versions inside this repository.

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/nix-overlays.md ---
Overlays are a feature of Nixpkgs that allow you to:

- Add new packages with new names to the namespace _without_ modifying upstream
  - For example, if there is a package `foobar`, you might add `foobar-1_2_3` to
    add a specific version for backwards compatibility
- Globally override _existing_ package names, in terms of other packages.
  - For example, if you want to globally override a package to enable a
    disabled-by-default feature.

First, you need to define a file for the overlay under
[overlays/](../overlays/), and then import it in `flake.nix`. There is an
example pull request in
[#14](https://github.com/supabase/nix-postgres/issues/14) for this; an overlay
typically looks like this:

```
final: prev: {
    gdal = prev.gdalMinimal;
}
```

This says "globally override `gdal` with a different version, named
`gdalMinimal`". In this case `gdalMinimal` is a build with less features
enabled.

The most important part is that there is an equation of the form `lhs = rhs;`
&mdash; if the `lhs` refers to an existing name, it's overwritten. If it refers
to a new name, it's introduced. Overwriting an existing name acts as if you
changed the files upstream: so the above example _globally_ overrides GDAL for
anything that depends on it.

The names `final` and `prev` are used to refer to packages in terms of other
overlays. For more information about this, see the
[NixOS Wiki Page for Overlays](https://nixos.wiki/wiki/Overlays).

We also use an overlay to override the default build recipe for `postgresql_16`, and instead feed it the specially patched postgres for use with orioledb extension. This experimental variant can be built with `nix build .#psql_orioledb_16/bin`. This will build this patched version of postgres, along with all extensions and wrappers that currently are known to work with orioledb.

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/README.md ---
# Documentation

This directory contains most of the "runbooks" and documentation on how to use
this repository.

You probably want to start with the [starting guide](./start-here.md). Then,
learn how to play with `postgres` in the [build guide](./build-postgres.md).
After that, you can probe around a bit.

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/use-direnv.md ---
Have you ever used a tool like `pip`'s `bin/activate` script, or `rbenv`? These
tools populate your shell environment with the right tools and scripts and
dependencies (e.g. `PYTHONPATH`) to run your software.

What if I told you there was a magical tool that worked like that, and could do
it for arbitrary languages and tools?

That tool is called **[direnv](https://direnv.net)**.

## Install direnv and use it in your shell

First, install `direnv`:

```
$ nix profile install nixpkgs#direnv
```

```
$ which direnv
/home/austin/.nix-profile/bin/direnv
```

Now, you need to activate it in your shell by hooking into it. If you're using
**Bash**, try putting this in your `.bashrc` and starting up a new interactive
shell:

```
eval "$(direnv hook bash)"
```

Not using bash? Check the
[direnv hook documentation](https://direnv.net/docs/hook.html) for more.

## Set up `nix-postgres`

Let's go back to the `nix-postgres` source code.

```
cd $HOME/tmp-nix-postgres
```

Now, normally, direnv is going to look for a file called `.envrc` and load that
if it exists. But to be polite, we don't do that by default; we keep a file
named `.envrc.recommended` in the repository instead, and encourage people to do
this:

```
echo "source_env .envrc.recommended" >> .envrc
```

All this says is "Load the code from `.envrc.recommended` directly", just like a
normal bash script using `source`. The idea of this pattern is to allow users to
have their own customized `.envrc` and piggyback on the committed code for
utility &mdash; and `.envrc` is `.gitignore`'d, so you can put e.g. secret
tokens inside without fear of committing them.

Run the above command, and then...

## What just happened?

Oops, a big red error appeared?

```
$ echo "source_env .envrc.recommended" >> .envrc
direnv: error /home/austin/work/nix-postgres/.envrc is blocked. Run `direnv allow` to approve its content
```

What happened? By default, as a security measure, `direnv` _does not_ load or
execute any code from an `.envrc` file, and instead it MUST be allowed
explicitly.

## `direnv allow`

Our `.envrc.recommended` file will integrate with Nix directly. So run
`direnv allow`, and you'll suddenly see the following:

```
$ direnv allow
direnv: loading ~/work/nix-postgres/.envrc
direnv: loading ~/work/nix-postgres/.envrc.recommended
direnv: loading https://raw.githubusercontent.com/nix-community/nix-direnv/2.3.0/direnvrc (sha256-Dmd+j63L84wuzgyjITIfSxSD57Tx7v51DMxVZOsiUD8=)
direnv: using flake
direnv: nix-direnv: renewed cache
direnv: export +AR +AS +CC +CONFIG_SHELL +CXX +DETERMINISTIC_BUILD +HOST_PATH +IN_NIX_SHELL +LD +NIX_BINTOOLS +NIX_BINTOOLS_WRAPPER_TARGET_HOST_x86_64_unknown_linux_gnu +NIX_BUILD_CORES +NIX_CC +NIX_CC_WRAPPER_TARGET_HOST_x86_64_unknown_linux_gnu +NIX_CFLAGS_COMPILE +NIX_ENFORCE_NO_NATIVE +NIX_HARDENING_ENABLE +NIX_LDFLAGS +NIX_STORE +NM +OBJCOPY +OBJDUMP +PYTHONHASHSEED +PYTHONNOUSERSITE +PYTHONPATH +RANLIB +READELF +SIZE +SOURCE_DATE_EPOCH +STRINGS +STRIP +_PYTHON_HOST_PLATFORM +_PYTHON_SYSCONFIGDATA_NAME +__structuredAttrs +buildInputs +buildPhase +builder +cmakeFlags +configureFlags +depsBuildBuild +depsBuildBuildPropagated +depsBuildTarget +depsBuildTargetPropagated +depsHostHost +depsHostHostPropagated +depsTargetTarget +depsTargetTargetPropagated +doCheck +doInstallCheck +dontAddDisableDepTrack +mesonFlags +name +nativeBuildInputs +out +outputs +patches +phases +preferLocalBuild +propagatedBuildInputs +propagatedNativeBuildInputs +shell +shellHook +stdenv +strictDeps +system ~PATH ~XDG_DATA_DIRS
```

What just happened is that we populated the ambient shell environment with tools
specified inside of `flake.nix` &mdash; we'll cover Flakes later. But for now,
your tools are provisioned!


## The power of `direnv`

`direnv` with Nix is a frighteningly good development combination for many
purposes. This is its main power: you can use it to create on-demand developer
shells for any language, tool, or environment, and all you need to do is `cd` to
the right directory.

This is the power of `direnv`: your projects always, on demand, will have the
right tools configured and available, no matter if you last worked on them a day
ago or a year ago, or it was done by your teammate, or you have a brand new
computer that you've never programmed on.

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/references.md ---
Nix references and other useful tools:

- **Zero to Nix**: Start here to get your feet wet with how Nix works, and how
  to use Nixpkgs: https://zero-to-nix.com/
- `nix-installer`: My recommended way to install Nix
  - https://github.com/DeterminateSystems/nix-installer
- Nix manual https://nixos.org/manual/nix/stable/
  - Useful primarily for option and command references
- Flake schema reference https://nixos.wiki/wiki/Flakes
  - Useful to know what `flake.nix` is referring to
- Example pull requests for this repo:
  - Adding smoke tests for an extension:
    https://github.com/supabase/nix-postgres/pull/2
  - Extension smoke tests, part 2:
    https://github.com/supabase/nix-postgres/pull/3
  - Adding an extension and a smoke test at once:
    https://github.com/supabase/nix-postgres/pull/4/files
  - Updating an extension to trunk:
    https://github.com/supabase/nix-postgres/pull/7
  - Updating an extension to the latest release:
    https://github.com/supabase/nix-postgres/pull/9
- Contributing to [nixpkgs](https://github.com/nixos/nixpkgs)
  - Adding a PGRX-powered extension:
    https://github.com/NixOS/nixpkgs/pull/246803
  - Adding a normal extension: https://github.com/NixOS/nixpkgs/pull/249000
  - Adding new PostgreSQL versions: https://github.com/NixOS/nixpkgs/pull/249030
- NixOS Discourse: https://discourse.nixos.org/
  - Useful for community feedback, guidance, and help
- `nix-update`: https://github.com/Mic92/nix-update
  - Used in this repository to help update extensions
- pgTAP for testing: https://pgtap.org/documentation.html

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/build-postgres.md ---
# 01 &mdash; Using supabase nix

Let's clone this repo:

```bash
git clone https://github.com/supabase/postgres $HOME/supabase-postgres
cd $HOME/supabase-postgres
```

## Hashes for everyone

But how do we build stuff within it? With `nix build`, of course! For example,
the following command will, when completed, create a symlink named `result` that
points to a path which contains an entire PostgreSQL 15 installation &mdash;
extensions and all:

```
nix build .#psql_15/bin
```

```
$ readlink result
/nix/store/ybf48481x033649mgdzk5dyaqv9dppzx-postgresql-and-plugins-15.3
```

```
$ ls result
bin  include  lib  share
```

```
$ ll result/bin/
total 9928
dr-xr-xr-x 2 root root    4096 Dec 31  1969 ./
dr-xr-xr-x 5 root root    4096 Dec 31  1969 ../
lrwxrwxrwx 1 root root      79 Dec 31  1969 .initdb-wrapped -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/.initdb-wrapped*
-r-xr-xr-x 1 root root 9829624 Dec 31  1969 .postgres-wrapped*
lrwxrwxrwx 1 root root      73 Dec 31  1969 clusterdb -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/clusterdb*
lrwxrwxrwx 1 root root      72 Dec 31  1969 createdb -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/createdb*
lrwxrwxrwx 1 root root      74 Dec 31  1969 createuser -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/createuser*
lrwxrwxrwx 1 root root      70 Dec 31  1969 dropdb -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/dropdb*
lrwxrwxrwx 1 root root      72 Dec 31  1969 dropuser -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/dropuser*
lrwxrwxrwx 1 root root      68 Dec 31  1969 ecpg -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/ecpg*
lrwxrwxrwx 1 root root      70 Dec 31  1969 initdb -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/initdb*
lrwxrwxrwx 1 root root      72 Dec 31  1969 oid2name -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/oid2name*
lrwxrwxrwx 1 root root      74 Dec 31  1969 pg_amcheck -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_amcheck*
lrwxrwxrwx 1 root root      81 Dec 31  1969 pg_archivecleanup -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_archivecleanup*
lrwxrwxrwx 1 root root      77 Dec 31  1969 pg_basebackup -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_basebackup*
lrwxrwxrwx 1 root root      76 Dec 31  1969 pg_checksums -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_checksums*
-r-xr-xr-x 1 root root   53432 Dec 31  1969 pg_config*
lrwxrwxrwx 1 root root      78 Dec 31  1969 pg_controldata -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_controldata*
-r-xr-xr-x 1 root root   82712 Dec 31  1969 pg_ctl*
lrwxrwxrwx 1 root root      71 Dec 31  1969 pg_dump -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_dump*
lrwxrwxrwx 1 root root      74 Dec 31  1969 pg_dumpall -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_dumpall*
lrwxrwxrwx 1 root root      74 Dec 31  1969 pg_isready -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_isready*
lrwxrwxrwx 1 root root      77 Dec 31  1969 pg_receivewal -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_receivewal*
lrwxrwxrwx 1 root root      78 Dec 31  1969 pg_recvlogical -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_recvlogical*
lrwxrwxrwx 1 root root      73 Dec 31  1969 pg_repack -> /nix/store/bi9i5ns4cqxk235qz3srs9p4x1qfxfna-pg_repack-1.4.8/bin/pg_repack*
lrwxrwxrwx 1 root root      75 Dec 31  1969 pg_resetwal -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_resetwal*
lrwxrwxrwx 1 root root      74 Dec 31  1969 pg_restore -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_restore*
lrwxrwxrwx 1 root root      73 Dec 31  1969 pg_rewind -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_rewind*
lrwxrwxrwx 1 root root      77 Dec 31  1969 pg_test_fsync -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_test_fsync*
lrwxrwxrwx 1 root root      78 Dec 31  1969 pg_test_timing -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_test_timing*
lrwxrwxrwx 1 root root      74 Dec 31  1969 pg_upgrade -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_upgrade*
lrwxrwxrwx 1 root root      79 Dec 31  1969 pg_verifybackup -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_verifybackup*
lrwxrwxrwx 1 root root      74 Dec 31  1969 pg_waldump -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_waldump*
lrwxrwxrwx 1 root root      71 Dec 31  1969 pgbench -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pgbench*
lrwxrwxrwx 1 root root      71 Dec 31  1969 pgsql2shp -> /nix/store/4wwzd3c136g6j7aqva2gyiqgwy784qjv-postgis-3.3.3/bin/pgsql2shp*
lrwxrwxrwx 1 root root      77 Dec 31  1969 pgsql2shp-3.3.3 -> /nix/store/4wwzd3c136g6j7aqva2gyiqgwy784qjv-postgis-3.3.3/bin/pgsql2shp-3.3.3*
lrwxrwxrwx 1 root root      75 Dec 31  1969 pgtopo_export -> /nix/store/4wwzd3c136g6j7aqva2gyiqgwy784qjv-postgis-3.3.3/bin/pgtopo_export*
lrwxrwxrwx 1 root root      81 Dec 31  1969 pgtopo_export-3.3.3 -> /nix/store/4wwzd3c136g6j7aqva2gyiqgwy784qjv-postgis-3.3.3/bin/pgtopo_export-3.3.3*
lrwxrwxrwx 1 root root      75 Dec 31  1969 pgtopo_import -> /nix/store/4wwzd3c136g6j7aqva2gyiqgwy784qjv-postgis-3.3.3/bin/pgtopo_import*
lrwxrwxrwx 1 root root      81 Dec 31  1969 pgtopo_import-3.3.3 -> /nix/store/4wwzd3c136g6j7aqva2gyiqgwy784qjv-postgis-3.3.3/bin/pgtopo_import-3.3.3*
-r-xr-xr-x 1 root root     286 Dec 31  1969 postgres*
lrwxrwxrwx 1 root root      74 Dec 31  1969 postmaster -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/postmaster*
lrwxrwxrwx 1 root root      68 Dec 31  1969 psql -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/psql*
lrwxrwxrwx 1 root root      74 Dec 31  1969 raster2pgsql -> /nix/store/4wwzd3c136g6j7aqva2gyiqgwy784qjv-postgis-3.3.3/bin/raster2pgsql*
lrwxrwxrwx 1 root root      80 Dec 31  1969 raster2pgsql-3.3.3 -> /nix/store/4wwzd3c136g6j7aqva2gyiqgwy784qjv-postgis-3.3.3/bin/raster2pgsql-3.3.3*
lrwxrwxrwx 1 root root      73 Dec 31  1969 reindexdb -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/reindexdb*
lrwxrwxrwx 1 root root      71 Dec 31  1969 shp2pgsql -> /nix/store/4wwzd3c136g6j7aqva2gyiqgwy784qjv-postgis-3.3.3/bin/shp2pgsql*
lrwxrwxrwx 1 root root      77 Dec 31  1969 shp2pgsql-3.3.3 -> /nix/store/4wwzd3c136g6j7aqva2gyiqgwy784qjv-postgis-3.3.3/bin/shp2pgsql-3.3.3*
lrwxrwxrwx 1 root root      72 Dec 31  1969 vacuumdb -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/vacuumdb*
lrwxrwxrwx 1 root root      72 Dec 31  1969 vacuumlo -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/vacuumlo*
```

As we can see, these files all point to paths under `/nix/store`. We're actually
looking at a "farm" of symlinks to various paths, but collectively they form an
entire installation directory we can reuse as much as we want.

The path
`/nix/store/ybf48481x033649mgdzk5dyaqv9dppzx-postgresql-and-plugins-15.3`
ultimately is a cryptographically hashed, unique name for our installation of
PostgreSQL with those plugins. This hash includes _everything_ used to build it,
so even a single change anywhere to any extension or version would result in a
_new_ hash.

The ability to refer to a piece of data by its hash, by some notion of
_content_, is a very powerful primitive, as we'll see later.

## Build a different version: v16

What if we wanted PostgreSQL 16 and plugins? Just replace `_15` with `_16`:

```
nix build .#psql_16/bin
```

You're done:

```
$ readlink result
/nix/store/p7ziflx0000s28bfb213jsghrczknkc4-postgresql-and-plugins-14.8
```


## Using `nix develop`


`nix develop .` will just drop you in a subshell with
tools you need _ready to go instantly_. That's all you need to do! And once that
shell goes away, nix installed tools will be removed from your `$PATH` as well.

There's an even easier way to do this
[that is completely transparent to you, as well](./use-direnv.md).

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/receipt-files.md ---
Every time you run `nix build` on this repository to build PostgreSQL, the
installation directory comes with a _receipt_ file that tells you what's inside
of it. Primarily, this tells you:

- The version of PostgreSQL,
- The installed extensions, and
- The version of nixpkgs.

The intent of the receipt file is to provide a mechanism for tooling to
understand installation directories and provide things like upgrade paths or
upgrade mechanisms.

## Example receipt

For example:

```
nix build .#psql_15/bin
```

```
austin@GANON:~/work/nix-postgres$ nix build .#psql_15/bin
austin@GANON:~/work/nix-postgres$ ls result
bin  include  lib  receipt.json  share
```

The receipt is in JSON format, under `receipt.json`. Here's an example of what
it would look like:

```json
{
  "extensions": [
    {
      "name": "pgsql-http",
      "version": "1.5.0"
    },
    {
      "name": "pg_plan_filter",
      "version": "unstable-2021-09-23"
    },
    {
      "name": "pg_net",
      "version": "0.7.2"
    },
    {
      "name": "pg_hashids",
      "version": "unstable-2022-09-17"
    },
    {
      "name": "pgsodium",
      "version": "3.1.8"
    },
    {
      "name": "pg_graphql",
      "version": "unstable-2023-08-01"
    },
    {
      "name": "pg_stat_monitor",
      "version": "1.0.1"
    },
    {
      "name": "pg_jsonschema",
      "version": "unstable-2023-07-23"
    },
    {
      "name": "vault",
      "version": "0.2.9"
    },
    {
      "name": "hypopg",
      "version": "1.3.1"
    },
    {
      "name": "pg_tle",
      "version": "1.0.4"
    },
    {
      "name": "supabase-wrappers",
      "version": "unstable-2023-07-31"
    },
    {
      "name": "supautils",
      "version": "1.7.3"
    }
  ],
  "nixpkgs": {
    "extensions": [
      {
        "name": "postgis",
        "version": "3.3.3"
      },
      {
        "name": "pgrouting",
        "version": "3.5.0"
      },
      {
        "name": "pgtap",
        "version": "1.2.0"
      },
      {
        "name": "pg_cron",
        "version": "1.5.2"
      },
      {
        "name": "pgaudit",
        "version": "1.7.0"
      },
      {
        "name": "pgjwt",
        "version": "unstable-2021-11-13"
      },
      {
        "name": "plpgsql_check",
        "version": "2.3.4"
      },
      {
        "name": "pg-safeupdate",
        "version": "1.4"
      },
      {
        "name": "timescaledb",
        "version": "2.11.1"
      },
      {
        "name": "wal2json",
        "version": "2.5"
      },
      {
        "name": "plv8",
        "version": "3.1.5"
      },
      {
        "name": "rum",
        "version": "1.3.13"
      },
      {
        "name": "pgvector",
        "version": "0.4.4"
      },
      {
        "name": "pg_repack",
        "version": "1.4.8"
      },
      {
        "name": "pgroonga",
        "version": "3.0.8"
      }
    ],
    "revision": "750fc50bfd132a44972aa15bb21937ae26303bc4"
  },
  "psql-version": "15.3",
  "receipt-version": "1",
  "revision": "vcs=d250647+20230814"
}
```

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/adding-new-package.md ---
# Adding a new extension package


## Pre-packaging steps
1. Make sure you have nix installed [Nix installer](https://github.com/DeterminateSystems/nix-installer)
2. Create a branch off of `develop`


## C/C++ postgres extensions

If you are creating a C/C++ extension, the pattern found in https://github.com/supabase/postgres/blob/develop/nix/ext/pgvector.nix will work well.

```
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "pgvector";
  version = "0.7.4";

  buildInputs = [ postgresql ];

  src = fetchFromGitHub {
    owner = "pgvector";
    repo = pname;
    rev = "refs/tags/v${version}";
    hash = "sha256-qwPaguQUdDHV8q6GDneLq5MuhVroPizpbqt7f08gKJI=";
  };

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp *.so      $out/lib
    cp sql/*.sql $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Open-source vector similarity search for Postgres";
    homepage = "https://github.com/${src.owner}/${src.repo}";
    maintainers = with maintainers; [ olirice ];
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}
```

This uses `stdenv.mkDerivation` which is a general nix builder for C and C++ projects (and others). It can auto detect the Makefile, and attempt to use it. ***It's a good practice to not have steps in the Makefile of your project that try to deal with OS specific system paths, or make calls out to the internet, as Nix cannot use these steps to build your project.*** 

Your build should produce all of the sql and control files needed for the install phase.

1. Once you have created this file, you can add it to `nix/ext/<yourname>.nix` and edit `flake.nix` and add it to the `ourExtensions` list.
2. `git add .` as nix uses git to track changes 
3. In your package file, temporarily empty the `hash = "sha256<...>=";` to `hash = "";` and save and `git add .`
4. Run `nix build .#psql_15/exts/<yourname>`  to try to trigger a build, nix will print the calculated sha256 value that you can add back the the `hash` variable, save the file again, and re-run `nix build .#psql_15/exts/<yourname>`. 
5. Add any needed migrations into the `supabase/postgres` migrations directory.
6. You can then run tests locally to verify that the update of the package succeeded. 
7. Now it's ready for PR review!

## Extensions written in Rust that use `buildPgrxExtension` builder

Extensions like:

* https://github.com/supabase/postgres/blob/develop/nix/ext/wrappers/default.nix
* https://github.com/supabase/postgres/blob/develop/nix/ext/pg_graphql.nix
* https://github.com/supabase/postgres/blob/develop/nix/ext/pg_jsonschema.nix

Are written in Rust, built with `cargo`, and need to use https://github.com/pgcentralfoundation/pgrx to build the extension.

We in turn have a special nix package `builder` which is sourced from `nixpkgs` and called `buildPgrxExtension` 

A simple example is found in `pg_jsonschema`


```
{ lib, stdenv, fetchFromGitHub, postgresql, buildPgrxExtension_0_11_3, cargo }:

buildPgrxExtension_0_11_3 rec {
  pname = "pg_jsonschema";
  version = "0.3.1";
  inherit postgresql;

  src = fetchFromGitHub {
    owner = "supabase";
    repo = pname;
    rev = "v${version}";
    hash = "sha256-YdKpOEiDIz60xE7C+EzpYjBcH0HabnDbtZl23CYls6g=";
  };

  nativeBuildInputs = [ cargo ];
  buildInputs = [ postgresql ];
  # update the following array when the pg_jsonschema version is updated
  # required to ensure that extensions update scripts from previous versions are generated

  previousVersions = ["0.3.0" "0.2.0" "0.1.4" "0.1.4" "0.1.2" "0.1.1" "0.1.0"];
  CARGO="${cargo}/bin/cargo";
  env = lib.optionalAttrs stdenv.isDarwin {
    POSTGRES_LIB = "${postgresql}/lib";
    RUSTFLAGS = "-C link-arg=-undefined -C link-arg=dynamic_lookup";
  };
  cargoHash = "sha256-VcS+efMDppofuFW2zNrhhsbC28By3lYekDFquHPta2g=";

  # FIXME (aseipp): testsuite tries to write files into /nix/store; we'll have
  # to fix this a bit later.
  doCheck = false;

  preBuild = ''
    echo "Processing git tags..."
    echo '${builtins.concatStringsSep "," previousVersions}' | sed 's/,/\n/g' > git_tags.txt
  '';

  postInstall = ''
    echo "Creating SQL files for previous versions..."
    current_version="${version}"
    sql_file="$out/share/postgresql/extension/pg_jsonschema--$current_version.sql"
    
    if [ -f "$sql_file" ]; then
      while read -r previous_version; do
        if [ "$(printf '%s\n' "$previous_version" "$current_version" | sort -V | head -n1)" = "$previous_version" ] && [ "$previous_version" != "$current_version" ]; then
          new_file="$out/share/postgresql/extension/pg_jsonschema--$previous_version--$current_version.sql"
          echo "Creating $new_file"
          cp "$sql_file" "$new_file"
        fi
      done < git_tags.txt
    else
      echo "Warning: $sql_file not found"
    fi
    rm git_tags.txt
  '';


  meta = with lib; {
    description = "JSON Schema Validation for PostgreSQL";
    homepage = "https://github.com/supabase/${pname}";
    maintainers = with maintainers; [ samrose ];
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}
```

Here we have built support in our overlay to specify and pin the version of `buildPgrxExtension` to a specific version (in this case `buildPgrxExtension_0_11_3`). This is currently the only version we can support, but this can be extended in our overlay https://github.com/supabase/postgres/blob/develop/nix/overlays/cargo-pgrx-0-11-3.nix to support other versions.

A few things about `buildPgrxExtension_x`:

* It doesn't support `buildPhase`, `installPhase` and those are implemented directly in the builder already
* It mostly just allows `cargo build` to do it's thing, but you may need to set env vars for the build process as seen above 
* It caclulates a special `cargoHash` that will be generated after the first in `src` is generated, when running `nix build .#psql_15/exts/<yourname>` to build the extension


## Post Nix derivation release steps


1. You can add and run tests as described in https://github.com/supabase/postgres/blob/develop/nix/docs/adding-tests.md 
2. You may need to add tests to our test.yml gh action workflow as well.
3. You can add the package and name and version to `ansible/vars.yml` it is not necessary to add the sha256 hash here, as the package is already built and cached in our release process before these vars are ever run.
4. to check that all your files will land in the overall build correctly, you can run `nix profile install .#psql_15/bin` on your machine, and check in `~/.nix-profile/bin, ~/.nix-profile/lib, ~/.nix-profile/share/postgresql/*` and you should see your lib, .control and sql files there. 
5. You can also run `nix run .#start-server 15` and in a new terminal window run `nix run .#star-client-and-migrate 15` and try to `CREATE EXTENSION <yourname>` and work with it there
6. Check that your extension works with the `pg_upgrade` process (TODO documentation forthcoming)
7. Now you are ready to PR the extension
8. From here, the release process should typically take care of the rest. 
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/docker.md ---
Docker images are pushed to `ghcr.io` on every commit. Try the following:

```
docker run --rm -it ghcr.io/supabase/nix-postgres-15:latest
```

Every Docker image that is built on every push is given a tag that exactly
corresponds to a Git commit in the repository &mdash; for example commit
[d3e0c39d34e1bb4d37e058175a7bc376620f6868](https://github.com/supabase/nix-postgres/commit/d3e0c39d34e1bb4d37e058175a7bc376620f6868)
in this repository has a tag in the container registry which can be used to pull
exactly that version.

This just starts the server. Client container images are not provided; you can
use `nix run` for that, as outlined [here](./start-client-server.md).

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/update-extension.md ---

# Update an existing nix extension


1. Create a branch off of `develop`
2. For instance, if we were updating https://github.com/supabase/postgres/blob/develop/nix/ext/supautils.nix we would:
   1. change the `version = "2.2.1";` to whatever our git tag release version is that we want to update to
   2. temporarily empty the `hash = "sha256-wSUEG0at00TPAoHv6+NMzuUE8mfW6fnHH0MNxvBdUiE=";` to `hash = "";` and save `supautils.nix` and `git add  .`
   3. run `nix build .#psql_15/exts/supautils` or the name of the extension to update, nix will print the calculated sha256 value that you can add back the the `hash` variable, save the file again, and re-run nix build .#psql_15/exts/supautils.
   4. NOTE: This step is only necessary for `buildPgrxExtension` packages, which includes supabase-wrappers, pg_jsonschema, and pg_graphql. Otherwise you can skip this step. For our packages that are build with `buildPgrxExtension` you will need to prepend the previous version to the `previousVersions` variable before updating the version in the package (for instance if you are updating `supabase-wrappers` extension from `0.4.1` to `0.4.2` then you would prepend `0.4.1` to this line https://github.com/supabase/postgres/blob/develop/nix/ext/wrappers/default.nix#L18 ). 
   5. Add any needed migrations into the `supabase/postgres` migrations directory
   6. update the version in `ansible/vars.yml` as usual
   7. You can then run the `nix flake check -L` tests locally to verify that the update of the package succeeded. 
   8. Now it's ready for PR review.
   9. Once the PR is approved, if you want the change to go out in a release, update the common-nix.vars.yml file with the new version prior to merging.
  


'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/migration-tests.md ---
Migration tests are run similar to running the client and server; see
[more on that here](./start-client-server.md).

Instead, you use the following format to specify the upgrade:

```
nix run .#migration-test <from> <to> [pg_dumpall|pg_upgrade]
```

The arguments are:

- The version to upgrade from
- The version to upgrade to
- The upgrade mechanism: either `pg_dumpall` or `pg_upgrade`

## Specifying the version

The versions for upgrading can be one of two forms:

- A major version number, e.g. `14` or `15`
- A path to `/nix/store`, which points to _any_ version of PostgreSQL, as long
  as it has the "expected" layout and is a postgresql install.

## Always use the latest version of the migration tool

Unlike the method for starting the client or server, you probably always want to
use the latest version of the `migration-test` tool from the repository. This is
because it can ensure forwards and backwards compatibility if necessary.

## Upgrading between arbitrary `/nix/store` versions

If you want to test migrations from arbitrary versions built by the repository,
you can combine `nix build` and `nix run` to do so. You can use the syntax from
the runbook on [running the server & client](./start-client-server.md) to refer
to arbitrary git revisions.

For example, if you updated an extension in this repository, and you want to
test a migration from PostgreSQL 14 to PostgreSQL 14 + (updated extension),
using `pg_upgrade` &mdash; simply record the two git commits you want to
compare, and you could do something like the following:

```
OLD_GIT_VERSION=...
NEW_GIT_VERSION=...

nix run github:supabase/nix-postgres#migration-test \
  $(nix build "github:supabase/nix-postgres/$OLD_GIT_VERSION#psql_14/bin") \
  $(nix build "github:supabase/nix-postgres/$NEW_GIT_VERSION#psql_14/bin") \
  pg_upgrade
```

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/cargo-pgrx/default.nix ---
{ lib
, darwin
, fetchCrate
, openssl
, pkg-config
, makeRustPlatform
, stdenv
, rust-bin
}:
let
  rustVersion = "1.85.1";
  rustPlatform = makeRustPlatform {
    cargo = rust-bin.stable.${rustVersion}.default;
    rustc = rust-bin.stable.${rustVersion}.default;
  };
  generic =
    { version
    , hash
    , cargoHash
    }:
    rustPlatform.buildRustPackage rec {
      # rust-overlay uses 'cargo-auditable' wrapper for 'cargo' command, but it
      # is using older version 0.18.1 of 'cargo_metadata' which doesn't support
      # rust edition 2024, so we disable the 'cargo-auditable' just for now.
      # ref: https://github.com/oxalica/rust-overlay/issues/153
      auditable = false;
      pname = "cargo-pgrx";
      inherit version;
      src = fetchCrate {
        inherit version pname hash;
      };
      inherit cargoHash;
      nativeBuildInputs = lib.optionals stdenv.hostPlatform.isLinux [
        pkg-config
      ];
      buildInputs = lib.optionals stdenv.hostPlatform.isLinux [
        openssl
      ] ++ lib.optionals stdenv.hostPlatform.isDarwin [
        darwin.apple_sdk.frameworks.Security
      ];
      
      OPENSSL_DIR = "${openssl.dev}";
      OPENSSL_INCLUDE_DIR = "${openssl.dev}/include";
      OPENSSL_LIB_DIR = "${openssl.out}/lib";
      PKG_CONFIG_PATH = "${openssl.dev}/lib/pkgconfig";
      preCheck = ''
        export PGRX_HOME=$(mktemp -d)
      '';
      checkFlags = [
        # requires pgrx to be properly initialized with cargo pgrx init
        "--skip=command::schema::tests::test_parse_managed_postmasters"
      ];
      meta = with lib; {
        description = "Build Postgres Extensions with Rust";
        homepage = "https://github.com/pgcentralfoundation/pgrx";
        changelog = "https://github.com/pgcentralfoundation/pgrx/releases/tag/v${version}";
        license = licenses.mit;
        maintainers = with maintainers; [ happysalada ];
        mainProgram = "cargo-pgrx";
      };
    };
in
{
  cargo-pgrx_0_11_3 = generic {
    version = "0.11.3";
    hash = "sha256-UHIfwOdXoJvR4Svha6ud0FxahP1wPwUtviUwUnTmLXU=";
    cargoHash = "sha256-j4HnD8Zt9uhlV5N7ldIy9564o9qFEqs5KfXHmnQ1WEw=";
  };
  cargo-pgrx_0_12_6 = generic {
    version = "0.12.6";
    hash = "sha256-7aQkrApALZe6EoQGVShGBj0UIATnfOy2DytFj9IWdEA=";
    cargoHash = "sha256-Di4UldQwAt3xVyvgQT1gUhdvYUVp7n/a72pnX45kP0w=";
  };
  cargo-pgrx_0_12_9 = generic {
    version = "0.12.9";
    hash = "sha256-aR3DZAjeEEAjLQfZ0ZxkjLqTVMIEbU0UiZ62T4BkQq8=";
    cargoHash = "sha256-KTKcol9qSNLQZGW32e6fBb6cPkUGItknyVpLdBYqrBY=";
  };
  cargo-pgrx_0_14_3 = generic {
    version = "0.14.3";
    hash = "sha256-3TsNpEqNm3Uol5XPW1i0XEbP2fF2+RKB2d7lO6BDnvQ=";
    cargoHash = "sha256-Ny7j56pwB+2eEK62X0nWfFKQy5fBz+Q1oyvecivxLkk=";
  };
  inherit rustPlatform;
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/cargo-pgrx/buildPgrxExtension.nix ---
# preBuildAndTest and some small other bits
# taken from https://github.com/tcdi/pgrx/blob/v0.9.4/nix/extension.nix
# (but now heavily modified)
# which uses MIT License with the following license file
#
# MIT License
#
# Portions Copyright 2019-2021 ZomboDB, LLC.
# Portions Copyright 2021-2022 Technology Concepts & Design, Inc. <support@tcdi.com>.
# All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

{ lib
, cargo-pgrx
, pkg-config
, rustPlatform
, stdenv
, Security
, writeShellScriptBin
}:

# The idea behind: Use it mostly like rustPlatform.buildRustPackage and so
# we hand most of the arguments down.
#
# Additional arguments are:
#   - `postgresql` postgresql package of the version of postgresql this extension should be build for.
#                  Needs to be the build platform variant.
#   - `useFakeRustfmt` Whether to use a noop fake command as rustfmt. cargo-pgrx tries to call rustfmt.
#                      If the generated rust bindings aren't needed to use the extension, its a
#                      unnecessary and heavy dependency. If you set this to true, you also
#                      have to add `rustfmt` to `nativeBuildInputs`.

{ buildAndTestSubdir ? null
, buildType ? "release"
, buildFeatures ? [ ]
, cargoBuildFlags ? [ ]
, postgresql
# cargo-pgrx calls rustfmt on generated bindings, this is not strictly necessary, so we avoid the
# dependency here. Set to false and provide rustfmt in nativeBuildInputs, if you need it, e.g.
# if you include the generated code in the output via postInstall.
, useFakeRustfmt ? true
, usePgTestCheckFeature ? true
, ...
} @ args:
let
  rustfmtInNativeBuildInputs = lib.lists.any (dep: lib.getName dep == "rustfmt") (args.nativeBuildInputs or []);
in

assert lib.asserts.assertMsg ((args.installPhase or "") == "")
  "buildPgrxExtensions overwrites the installPhase, so providing one does nothing";
assert lib.asserts.assertMsg ((args.buildPhase or "") == "")
  "buildPgrxExtensions overwrites the buildPhase, so providing one does nothing";
assert lib.asserts.assertMsg (useFakeRustfmt -> !rustfmtInNativeBuildInputs)
  "The parameter useFakeRustfmt is set to true, but rustfmt is included in nativeBuildInputs. Either set useFakeRustfmt to false or remove rustfmt from nativeBuildInputs.";
assert lib.asserts.assertMsg (!useFakeRustfmt -> rustfmtInNativeBuildInputs)
  "The parameter useFakeRustfmt is set to false, but rustfmt is not included in nativeBuildInputs. Either set useFakeRustfmt to true or add rustfmt from nativeBuildInputs.";

let
  fakeRustfmt = writeShellScriptBin "rustfmt" ''
    exit 0
    '';
  maybeDebugFlag = lib.optionalString (buildType != "release") "--debug";
  maybeEnterBuildAndTestSubdir = lib.optionalString (buildAndTestSubdir != null) ''
    export CARGO_TARGET_DIR="$(pwd)/target"
    pushd "${buildAndTestSubdir}"
  '';
  maybeLeaveBuildAndTestSubdir = lib.optionalString (buildAndTestSubdir != null) "popd";

  pgrxPostgresMajor = lib.versions.major postgresql.version;
  preBuildAndTest = ''
    export PGRX_HOME=$(mktemp -d)
    export PGDATA="$PGRX_HOME/data-${pgrxPostgresMajor}/"
    cargo-pgrx pgrx init "--pg${pgrxPostgresMajor}" ${lib.getDev postgresql}/bin/pg_config
    echo "unix_socket_directories = '$(mktemp -d)'" > "$PGDATA/postgresql.conf"

    # This is primarily for Mac or other Nix systems that don't use the nixbld user.
    export USER="$(whoami)"
    pg_ctl start
    createuser -h localhost --superuser --createdb "$USER" || true
    pg_ctl stop
  '';

  argsForBuildRustPackage = builtins.removeAttrs args [ "postgresql" "useFakeRustfmt" "usePgTestCheckFeature" ];

  # so we don't accidentally `(rustPlatform.buildRustPackage argsForBuildRustPackage) // { ... }` because
  # we forgot parentheses
  finalArgs = argsForBuildRustPackage // {
    buildInputs = (args.buildInputs or [ ]) ++ lib.optionals stdenv.hostPlatform.isDarwin [ Security ];

    nativeBuildInputs = (args.nativeBuildInputs or [ ]) ++ [
      cargo-pgrx
      postgresql
      pkg-config
      rustPlatform.bindgenHook
    ] ++ lib.optionals useFakeRustfmt [ fakeRustfmt ];

    buildPhase = ''
      runHook preBuild

      echo "Executing cargo-pgrx buildPhase"
      ${preBuildAndTest}
      ${maybeEnterBuildAndTestSubdir}

      PGRX_BUILD_FLAGS="--frozen -j $NIX_BUILD_CORES ${builtins.concatStringsSep " " cargoBuildFlags}" \
      ${lib.optionalString stdenv.hostPlatform.isDarwin ''RUSTFLAGS="''${RUSTFLAGS:+''${RUSTFLAGS} }-Clink-args=-Wl,-undefined,dynamic_lookup"''} \
      cargo pgrx package \
        --pg-config ${lib.getDev postgresql}/bin/pg_config \
        ${maybeDebugFlag} \
        --features "${builtins.concatStringsSep " " buildFeatures}" \
        --out-dir "$out"

      ${maybeLeaveBuildAndTestSubdir}

      runHook postBuild
    '';

    preCheck = preBuildAndTest + args.preCheck or "";

    installPhase = ''
      runHook preInstall

      echo "Executing buildPgrxExtension install"

      ${maybeEnterBuildAndTestSubdir}

      cargo-pgrx pgrx stop all

      mv $out/${postgresql}/* $out
      rm -rf $out/nix

      ${maybeLeaveBuildAndTestSubdir}

      runHook postInstall
    '';

    PGRX_PG_SYS_SKIP_BINDING_REWRITE = "1";
    CARGO_BUILD_INCREMENTAL = "false";
    RUST_BACKTRACE = "full";

    checkNoDefaultFeatures = true;
    checkFeatures = (args.checkFeatures or [ ]) ++ (lib.optionals usePgTestCheckFeature [ "pg_test" ]) ++ [ "pg${pgrxPostgresMajor}" ];
  };
in
rustPlatform.buildRustPackage finalArgs

'''

