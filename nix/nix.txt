The below represents the folders and files from the root paths:
- /Users/barneycook/Desktop/code/ProjectRef/postgres/flake.nix
- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix

Each file is separated by '''--- followed by the file path and ending with ---.
File content begins immediately after its path and extends until the next '''---


*Directory: nix*
Total words: 22601

File structure:

nix/
    do-not-use-vendored-libraries.patch
    fix-cmake-install-path.patch
    init.sh
    nix.txt
    supabase-groonga.nix
    wal-g.nix
postgresql/
    15.nix
    16.nix
    17.nix
    default.nix
    generic.nix
    orioledb-16.nix
    orioledb-17.nix
    patches/
        less-is-more.patch
        locale-binary-path.patch
        paths-for-split-outputs.patch
        paths-with-postgresql-suffix.patch
        relative-to-symlinks-16+.patch
        relative-to-symlinks.patch
        socketdir-in-run-13+.patch
        socketdir-in-run.patch
        specify_pkglibdir_at_runtime.patch
tools/
    README.md
    dbmate-tool.sh.in
    local-infra-bootstrap.sh.in
    migrate-tool.sh.in
    postgresql_schema.sql
    run-client.sh.in
    run-replica.sh.in
    run-restore.sh.in
    run-server.sh.in
    supabase-groonga.nix
    sync-exts-versions.sh.in
    update_readme.nu
    wal-g.nix
docker/
    init.sh.in
overlays/
    cargo-pgrx-0-11-3.nix
    psql_16-oriole.nix
ext/
    0001-build-Allow-using-V8-from-system.patch
    age.nix
    gdal.nix
    hypopg.nix
    index_advisor.nix
    orioledb.nix
    pg-safeupdate.nix
    pg_backtrace.nix
    pg_cron.nix
    pg_graphql.nix
    pg_hashids.nix
    pg_jsonschema.nix
    pg_net.nix
    pg_partman.nix
    pg_plan_filter.nix
    pg_regress.nix
    pg_repack.nix
    pg_stat_monitor.nix
    pg_tle.nix
    pgaudit.nix
    pgjwt.nix
    pgmq.nix
    pgroonga.nix
    pgrouting.nix
    pgsodium.nix
    pgsql-http.nix
    pgtap.nix
    pgvector.nix
    pljava.nix
    plpgsql-check.nix
    plv8.nix
    postgis.nix
    rum.nix
    supautils.nix
    timescaledb-2.9.1.nix
    timescaledb.nix
    use-system-groonga.patch
    vault.nix
    wal2json.nix
    wrappers/
        default.nix
    mecab-naist-jdic/
        default.nix
    sfcgal/
        sfcgal.nix
docs/
    README.md
    adding-new-package.md
    adding-tests.md
    build-postgres.md
    docker.md
    migration-tests.md
    new-major-postgres.md
    nix-overlays.md
    receipt-files.md
    references.md
    start-client-server.md
    start-here.md
    update-extension.md
    use-direnv.md
cargo-pgrx/
    buildPgrxExtension.nix
    default.nix


*File: flake.nix*
Words: 5299

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/init.sh ---
#!/bin/bash
# shellcheck shell=bash

export PGUSER=supabase_admin
export PGDATA=$PWD/postgres_data
export PGHOST=$PWD/postgres
export PGPORT=5432
export PGPASS=postgres
export LOG_PATH=$PGHOST/LOG
export PGDATABASE=testdb
export DATABASE_URL="postgresql:///$PGDATABASE?host=$PGHOST&port=$PGPORT"
mkdir -p $PGHOST
if [ ! -d $PGDATA ]; then
    echo 'Initializing postgresql database...'
    initdb $PGDATA --locale=C --username $PGUSER -A md5 --pwfile=<(echo $PGPASS) --auth=trust
    echo "listen_addresses='*'" >> $PGDATA/postgresql.conf
    echo "unix_socket_directories='$PGHOST'" >> $PGDATA/postgresql.conf
    echo "unix_socket_permissions=0700" >> $PGDATA/postgresql.conf
fi
chmod o-rwx $PGDATA

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/do-not-use-vendored-libraries.patch ---
Do not use vendored libraries

--- a/vendor/CMakeLists.txt
+++ b/vendor/CMakeLists.txt
@@ -14,10 +14,7 @@
 # License along with this library; if not, write to the Free Software
 # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 
 add_subdirectory(onigmo)
-add_subdirectory(mruby)
-add_subdirectory(mecab)
-add_subdirectory(message_pack)
 if(GRN_WITH_MRUBY)
   add_subdirectory(groonga-log)
 endif()
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/fix-cmake-install-path.patch ---
Fix CMake install path

--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1141,11 +1141,11 @@
 
 set(prefix "${CMAKE_INSTALL_PREFIX}")
 set(exec_prefix "\${prefix}")
-set(bindir "\${exec_prefix}/${CMAKE_INSTALL_BINDIR}")
-set(sbindir "\${exec_prefix}/${CMAKE_INSTALL_SBINDIR}")
-set(libdir "\${prefix}/${CMAKE_INSTALL_LIBDIR}")
-set(includedir "\${prefix}/${CMAKE_INSTALL_INCLUDEDIR}")
-set(datarootdir "\${prefix}/${CMAKE_INSTALL_DATAROOTDIR}")
+set(bindir "${CMAKE_INSTALL_FULL_BINDIR}")
+set(sbindir "${CMAKE_INSTALL_FULL_SBINDIR}")
+set(libdir "${CMAKE_INSTALL_FULL_LIBDIR}")
+set(includedir "${CMAKE_INSTALL_FULL_INCLUDEDIR}")
+set(datarootdir "${CMAKE_INSTALL_FULL_DATAROOTDIR}")
 set(datadir "\${datarootdir}")
 set(expanded_pluginsdir "${GRN_PLUGINS_DIR}")
 set(GRN_EXPANDED_DEFAULT_DOCUMENT_ROOT "${GRN_DEFAULT_DOCUMENT_ROOT}")
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/supabase-groonga.nix ---
{ lib, stdenv, cmake, fetchurl, kytea, msgpack-c, mecab, pkg-config, rapidjson
, testers, xxHash, zstd, postgresqlPackages, makeWrapper, suggestSupport ? false
, zeromq, libevent, openssl, lz4Support ? false, lz4, zlibSupport ? true, zlib
, writeShellScriptBin, callPackage }:
let mecab-naist-jdic = callPackage ./ext/mecab-naist-jdic { };
in stdenv.mkDerivation (finalAttrs: {
  pname = "supabase-groonga";
  version = "14.0.5";
  src = fetchurl {
    url =
      "https://packages.groonga.org/source/groonga/groonga-${finalAttrs.version}.tar.gz";
    hash = "sha256-y4UGnv8kK0z+br8wXpPf57NMXkdEJHcLCuTvYiubnIc=";
  };
  patches =
    [ ./fix-cmake-install-path.patch ./do-not-use-vendored-libraries.patch ];
  nativeBuildInputs = [ cmake pkg-config makeWrapper ];
  buildInputs = [ rapidjson xxHash zstd mecab kytea msgpack-c ]
    ++ lib.optionals lz4Support [ lz4 ] ++ lib.optional zlibSupport [ zlib ]
    ++ lib.optionals suggestSupport [ zeromq libevent ];
  cmakeFlags = [
    "-DWITH_MECAB=ON"
    "-DMECAB_DICDIR=${mecab-naist-jdic}/lib/mecab/dic/naist-jdic"
    "-DMECAB_CONFIG=${mecab}/bin/mecab-config"
    "-DENABLE_MECAB_TOKENIZER=ON"
    "-DMECAB_INCLUDE_DIR=${mecab}/include"
    "-DMECAB_LIBRARY=${mecab}/lib/libmecab.so"
    "-DGROONGA_ENABLE_TOKENIZER_MECAB=YES"
    "-DGRN_WITH_MECAB=YES"
  ];
  preConfigure = ''
    export MECAB_DICDIR=${mecab-naist-jdic}/lib/mecab/dic/naist-jdic
    echo "MeCab dictionary directory is: $MECAB_DICDIR"
  '';
  buildPhase = ''
    cmake --build . -- VERBOSE=1
    grep -i mecab CMakeCache.txt || (echo "MeCab not detected in CMake cache" && exit 1)
    echo "CMake cache contents related to MeCab:"
    grep -i mecab CMakeCache.txt
  '';

  # installPhase = ''
  #   mkdir -p $out/bin $out/lib/groonga/plugins
  #   cp -r lib/groonga/plugins/* $out/lib/groonga/plugins
  #   cp -r bin/* $out/bin
  #   echo "Installed Groonga plugins:"
  #   ls -l $out/lib/groonga/plugins
  # '';

  postInstall = ''
    echo "Searching for MeCab-related files:"
    find $out -name "*mecab*"

    echo "Checking Groonga plugins directory:"
    ls -l $out/lib/groonga/plugins

    echo "Wrapping Groonga binary:"
    wrapProgram $out/bin/groonga \
      --set GRN_PLUGINS_DIR $out/lib/groonga/plugins 

  '';
  env.NIX_CFLAGS_COMPILE =
    lib.optionalString zlibSupport "-I${zlib.dev}/include";

  meta = with lib; {
    homepage = "https://groonga.org/";
    description = "Open-source fulltext search engine and column store";
    license = licenses.lgpl21;
    platforms = platforms.all;
    longDescription = ''
      Groonga is an open-source fulltext search engine and column store.
      It lets you write high-performance applications that requires fulltext search.
    '';
  };
})
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/wal-g.nix ---
{ lib
, buildGoModule
, fetchFromGitHub
, brotli
, libsodium
, installShellFiles
,
}:

let
  walGCommon = { version, vendorHash, sha256, majorVersion }:
    buildGoModule rec {
      pname = "wal-g-${majorVersion}";
      inherit version;

      src = fetchFromGitHub {
        owner = "wal-g";
        repo = "wal-g";
        rev = "v${version}";
        inherit sha256;
      };

      inherit vendorHash;

      nativeBuildInputs = [ installShellFiles ];

      buildInputs = [
        brotli
        libsodium
      ];

      subPackages = [ "main/pg" ];

      tags = [
        "brotli"
        "libsodium"
      ];

      ldflags = [
        "-s"
        "-w"
        "-X github.com/wal-g/wal-g/cmd/pg.walgVersion=${version}"
        "-X github.com/wal-g/wal-g/cmd/pg.gitRevision=${src.rev}"
      ];

      postInstall = ''
        mv $out/bin/pg $out/bin/wal-g-${majorVersion}
        
        # Create version-specific completions
        mkdir -p $out/share/bash-completion/completions
        $out/bin/wal-g-${majorVersion} completion bash > $out/share/bash-completion/completions/wal-g-${majorVersion}
        
        mkdir -p $out/share/zsh/site-functions
        $out/bin/wal-g-${majorVersion} completion zsh > $out/share/zsh/site-functions/_wal-g-${majorVersion}
        
      '';

      meta = with lib; {
        homepage = "https://github.com/wal-g/wal-g";
        license = licenses.asl20;
        description = "Archival restoration tool for PostgreSQL";
        mainProgram = "wal-g-${majorVersion}";
      };
    };
in
{
  # wal-g v2.0.1
  wal-g-2 = walGCommon {
    version = "2.0.1";
    sha256 = "sha256-5mwA55aAHwEFabGZ6c3pi8NLcYofvoe4bb/cFj7NWok=";
    vendorHash = "sha256-BbQuY6r30AkxlCZjY8JizaOrqEBdv7rIQet9KQwYB/g=";
    majorVersion = "2";
  };

  # wal-g v3.0.5
  wal-g-3 = walGCommon {
    version = "3.0.5";
    sha256 = "sha256-wVr0L2ZXMuEo6tc2ajNzPinVQ8ZVzNOSoaHZ4oFsA+U=";
    vendorHash = "sha256-YDLAmRfDl9TgbabXj/1rxVQ052NZDg3IagXVTe5i9dw=";
    majorVersion = "3";
  };
}
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/16.nix ---
import ./generic.nix {
  version = "16.3";
  hash = "sha256-Mxlj1dPcTK9CFqBJ+kC2bWvLjHMGFYWUEblRh2TmBYU=";
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/17.nix ---
import ./generic.nix {
  version = "17.4";
  hash = "sha256-xGBbc/6hGWNAZpn5Sblm5dFzp+4Myu+JON7AyoqZX+c=";
}
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/15.nix ---
import ./generic.nix {
  version = "15.8";
  hash = "sha256-RANRX5pp7rPv68mPMLjGlhIr/fiV6Ss7I/W452nty2o=";
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/orioledb-16.nix ---
import ./generic.nix {
  version = "16_31";
  hash = "sha256-29uHUACwZKh8e4zJ9tWzEhLNjEuh6P31KbpxnMEhtuI=";
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/orioledb-17.nix ---
import ./generic.nix {
  version = "17_6";
  hash = "sha256-HbuTcXNanFOl9YfvlSzQJon8CfAhc8TFwo/y7jXy51w=";
}
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/default.nix ---
self:
let
  versions = {
    postgresql_15 = ./15.nix;
    postgresql_16 = ./16.nix;
    postgresql_17 = ./17.nix;
    postgresql_orioledb-16 = ./orioledb-16.nix;
    postgresql_orioledb-17 = ./orioledb-17.nix;
  };
  mkAttributes = jitSupport:
    self.lib.mapAttrs' (version: path:
      let
        attrName = if jitSupport then "${version}_jit" else version;
      in
      self.lib.nameValuePair attrName (import path {
        inherit jitSupport self;
      })
    ) versions;
in
# variations without and with JIT
(mkAttributes false) // (mkAttributes true)

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/generic.nix ---
let

  generic =
      # adapted from the nixpkgs postgresql package
      # dependencies
      { stdenv, lib, fetchurl, fetchpatch, makeWrapper
      , glibc, zlib, readline, openssl, icu, lz4, zstd, systemd, libossp_uuid
      , pkg-config, libxml2, tzdata, libkrb5, substituteAll, darwin
      , linux-pam
      #orioledb specific
      , perl, bison, flex, docbook_xsl, docbook_xml_dtd_45, docbook_xsl_ns, libxslt

      # This is important to obtain a version of `libpq` that does not depend on systemd.
      , systemdSupport ? lib.meta.availableOn stdenv.hostPlatform systemd && !stdenv.hostPlatform.isStatic
      , enableSystemd ? null
      , gssSupport ? with stdenv.hostPlatform; !isWindows && !isStatic

      # for postgresql.pkgs
      , self, newScope, buildEnv

      # source specification
      , version, hash, muslPatches ? {}

      # for tests
      , testers

      # JIT
      , jitSupport
      , nukeReferences, patchelf, llvmPackages

      # PL/Python
      , pythonSupport ? false
      , python3

      # detection of crypt fails when using llvm stdenv, so we add it manually
      # for <13 (where it got removed: https://github.com/postgres/postgres/commit/c45643d618e35ec2fe91438df15abd4f3c0d85ca)
      , libxcrypt
    } @args:
  let
    atLeast = lib.versionAtLeast version;
    olderThan = lib.versionOlder version;
    lz4Enabled = atLeast "14";
    zstdEnabled = atLeast "15";

    systemdSupport' = if enableSystemd == null then systemdSupport else (lib.warn "postgresql: argument enableSystemd is deprecated, please use systemdSupport instead." enableSystemd);

    pname = "postgresql";

    stdenv' = if jitSupport then llvmPackages.stdenv else stdenv;
  in stdenv'.mkDerivation (finalAttrs: {
    inherit version;
    pname = pname + lib.optionalString jitSupport "-jit";

    src = if (builtins.match "[0-9][0-9]_.*" version != null) then
      fetchurl {
        url = "https://github.com/orioledb/postgres/archive/refs/tags/patches${version}.tar.gz";
        inherit hash;
      }
    else
      fetchurl {
        url = "mirror://postgresql/source/v${version}/${pname}-${version}.tar.bz2";
        inherit hash;
      };

    hardeningEnable = lib.optionals (!stdenv'.cc.isClang) [ "pie" ];

    outputs = [ "out" "lib" ];
    setOutputFlags = false; # $out retains configureFlags :-/

    buildInputs = [
      zlib
      readline
      openssl
      (libxml2.override {python = python3;})
      icu
    ]
      ++ lib.optionals (olderThan "13") [ libxcrypt ]
      ++ lib.optionals jitSupport [ llvmPackages.llvm ]
      ++ lib.optionals lz4Enabled [ lz4 ]
      ++ lib.optionals zstdEnabled [ zstd ]
      ++ lib.optionals systemdSupport' [ systemd ]
      ++ lib.optionals pythonSupport [ python3 ]
      ++ lib.optionals gssSupport [ libkrb5 ]
      ++ lib.optionals stdenv'.isLinux [ linux-pam ]
      ++ lib.optionals (!stdenv'.isDarwin) [ libossp_uuid ]
      ++ lib.optionals (builtins.match "[0-9][0-9]_.*" version != null || atLeast "17") [ 
        perl bison flex docbook_xsl docbook_xml_dtd_45 docbook_xsl_ns libxslt
      ];

    nativeBuildInputs = [
      makeWrapper
      pkg-config
      bison
      flex
    ]
      ++ lib.optionals jitSupport [ llvmPackages.llvm.dev nukeReferences patchelf ];

    enableParallelBuilding = true;

    separateDebugInfo = true;

    buildFlags = [ "world-bin" ];

    # Makes cross-compiling work when xml2-config can't be executed on the host.
    # Fixed upstream in https://github.com/postgres/postgres/commit/0bc8cebdb889368abdf224aeac8bc197fe4c9ae6
    env.NIX_CFLAGS_COMPILE = lib.optionalString (olderThan "13") "-I${libxml2.dev}/include/libxml2";

    configureFlags = [
      "--with-openssl"
      "--with-libxml"
      "--with-icu"
      "--sysconfdir=/etc"
      "--libdir=$(lib)/lib"
      "--with-system-tzdata=${tzdata}/share/zoneinfo"
      "--enable-debug"
      (lib.optionalString systemdSupport' "--with-systemd")
      (if stdenv'.isDarwin then "--with-uuid=e2fs" else "--with-ossp-uuid")
    ] ++ lib.optionals lz4Enabled [ "--with-lz4" ]
      ++ lib.optionals zstdEnabled [ "--with-zstd" ]
      ++ lib.optionals gssSupport [ "--with-gssapi" ]
      ++ lib.optionals pythonSupport [ "--with-python" ]
      ++ lib.optionals jitSupport [ "--with-llvm" ]
      ++ lib.optionals stdenv'.isLinux [ "--with-pam" ];

    patches = [
      (if atLeast "16" then ./patches/relative-to-symlinks-16+.patch else ./patches/relative-to-symlinks.patch)
      ./patches/less-is-more.patch
      ./patches/paths-for-split-outputs.patch
      ./patches/specify_pkglibdir_at_runtime.patch
      ./patches/paths-with-postgresql-suffix.patch

      (substituteAll {
        src = ./patches/locale-binary-path.patch;
        locale = "${if stdenv.isDarwin then darwin.adv_cmds else lib.getBin stdenv.cc.libc}/bin/locale";
      })
    ] ++ lib.optionals stdenv'.hostPlatform.isMusl (
      # Using fetchurl instead of fetchpatch on purpose: https://github.com/NixOS/nixpkgs/issues/240141
      map fetchurl (lib.attrValues muslPatches)
    ) ++ lib.optionals stdenv'.isLinux  [
      (if atLeast "13" then ./patches/socketdir-in-run-13+.patch else ./patches/socketdir-in-run.patch)
    ];

    installTargets = [ "install-world-bin" ];

    postPatch = ''
      # Hardcode the path to pgxs so pg_config returns the path in $out
      substituteInPlace "src/common/config_info.c" --subst-var out
    '' + lib.optionalString jitSupport ''
        # Force lookup of jit stuff in $out instead of $lib
        substituteInPlace src/backend/jit/jit.c --replace pkglib_path \"$out/lib\"
        substituteInPlace src/backend/jit/llvm/llvmjit.c --replace pkglib_path \"$out/lib\"
        substituteInPlace src/backend/jit/llvm/llvmjit_inline.cpp --replace pkglib_path \"$out/lib\"
    '';

    postInstall =
      ''
        moveToOutput "lib/pgxs" "$out" # looks strange, but not deleting it
        moveToOutput "lib/libpgcommon*.a" "$out"
        moveToOutput "lib/libpgport*.a" "$out"
        moveToOutput "lib/libecpg*" "$out"

        # Prevent a retained dependency on gcc-wrapper.
        substituteInPlace "$out/lib/pgxs/src/Makefile.global" --replace ${stdenv'.cc}/bin/ld ld

        if [ -z "''${dontDisableStatic:-}" ]; then
          # Remove static libraries in case dynamic are available.
          for i in $out/lib/*.a $lib/lib/*.a; do
            name="$(basename "$i")"
            ext="${stdenv'.hostPlatform.extensions.sharedLibrary}"
            if [ -e "$lib/lib/''${name%.a}$ext" ] || [ -e "''${i%.a}$ext" ]; then
              rm "$i"
            fi
          done
        fi
      '' + lib.optionalString jitSupport ''
        # Move the bitcode and libllvmjit.so library out of $lib; otherwise, every client that
        # depends on libpq.so will also have libLLVM.so in its closure too, bloating it
        moveToOutput "lib/bitcode" "$out"
        moveToOutput "lib/llvmjit*" "$out"

        # In the case of JIT support, prevent a retained dependency on clang-wrapper
        substituteInPlace "$out/lib/pgxs/src/Makefile.global" --replace ${stdenv'.cc}/bin/clang clang
        nuke-refs $out/lib/llvmjit_types.bc $(find $out/lib/bitcode -type f)

        # Stop out depending on the default output of llvm
        substituteInPlace $out/lib/pgxs/src/Makefile.global \
          --replace ${llvmPackages.llvm.out}/bin "" \
          --replace '$(LLVM_BINPATH)/' ""

        # Stop out depending on the -dev output of llvm
        substituteInPlace $out/lib/pgxs/src/Makefile.global \
          --replace ${llvmPackages.llvm.dev}/bin/llvm-config llvm-config \
          --replace -I${llvmPackages.llvm.dev}/include ""

        ${lib.optionalString (!stdenv'.isDarwin) ''
          # Stop lib depending on the -dev output of llvm
          rpath=$(patchelf --print-rpath $out/lib/llvmjit.so)
          nuke-refs -e $out $out/lib/llvmjit.so
          # Restore the correct rpath
          patchelf $out/lib/llvmjit.so --set-rpath "$rpath"
        ''}
      '';

    postFixup = lib.optionalString (!stdenv'.isDarwin && stdenv'.hostPlatform.libc == "glibc")
      ''
        # initdb needs access to "locale" command from glibc.
        wrapProgram $out/bin/initdb --prefix PATH ":" ${glibc.bin}/bin
      '';

    doCheck = !stdenv'.isDarwin;
    # autodetection doesn't seem to able to find this, but it's there.
    checkTarget = "check";

    disallowedReferences = [ stdenv'.cc ];

    passthru = let
      this = self.callPackage generic args;
      jitToggle = this.override {
        jitSupport = !jitSupport;
      };
    in
    {
      psqlSchema = lib.versions.major version;

      withJIT = if jitSupport then this else jitToggle;
      withoutJIT = if jitSupport then jitToggle else this;

      dlSuffix = if olderThan "16" then ".so" else stdenv.hostPlatform.extensions.sharedLibrary;

      pkgs = let
        scope = {
          inherit jitSupport;
          inherit (llvmPackages) llvm;
          postgresql = this;
          stdenv = stdenv';
        };
        newSelf = self // scope;
        newSuper = { callPackage = newScope (scope // this.pkgs); };
      in import ./ext newSelf newSuper;

      withPackages = postgresqlWithPackages {
                       inherit makeWrapper buildEnv;
                       postgresql = this;
                     }
                     this.pkgs;

      tests = {
        postgresql-wal-receiver = import ../../../../nixos/tests/postgresql-wal-receiver.nix {
          inherit (stdenv) system;
          pkgs = self;
          package = this;
        };
        pkg-config = testers.testMetaPkgConfig finalAttrs.finalPackage;
      } // lib.optionalAttrs jitSupport {
        postgresql-jit = import ../../../../nixos/tests/postgresql-jit.nix {
          inherit (stdenv) system;
          pkgs = self;
          package = this;
        };
      };
    };

    meta = with lib; {
      homepage    = "https://www.postgresql.org";
      description = "Powerful, open source object-relational database system";
      license     = licenses.postgresql;
      changelog   = "https://www.postgresql.org/docs/release/${finalAttrs.version}/";
      maintainers = with maintainers; [ thoughtpolice danbst globin ivan ma27 wolfgangwalther ];
      pkgConfigModules = [ "libecpg" "libecpg_compat" "libpgtypes" "libpq" ];
      platforms   = platforms.unix;

      # JIT support doesn't work with cross-compilation. It is attempted to build LLVM-bytecode
      # (`%.bc` is the corresponding `make(1)`-rule) for each sub-directory in `backend/` for
      # the JIT apparently, but with a $(CLANG) that can produce binaries for the build, not the
      # host-platform.
      #
      # I managed to get a cross-build with JIT support working with
      # `depsBuildBuild = [ llvmPackages.clang ] ++ buildInputs`, but considering that the
      # resulting LLVM IR isn't platform-independent this doesn't give you much.
      # In fact, I tried to test the result in a VM-test, but as soon as JIT was used to optimize
      # a query, postgres would coredump with `Illegal instruction`.
      broken = (jitSupport && stdenv.hostPlatform != stdenv.buildPlatform)
        # Allmost all tests fail FATAL errors for v12 and v13
        || (jitSupport && stdenv.hostPlatform.isMusl && olderThan "14");
    };
  });

  postgresqlWithPackages = { postgresql, makeWrapper, buildEnv }: pkgs: f: buildEnv {
    name = "postgresql-and-plugins-${postgresql.version}";
    paths = f pkgs ++ [
        postgresql
        postgresql.lib
        #TODO RM postgresql.man   # in case user installs this into environment
    ];
    nativeBuildInputs = [ makeWrapper ];


    # We include /bin to ensure the $out/bin directory is created, which is
    # needed because we'll be removing the files from that directory in postBuild
    # below. See #22653
    pathsToLink = ["/" "/bin"];

    # Note: the duplication of executables is about 4MB size.
    # So a nicer solution was patching postgresql to allow setting the
    # libdir explicitly.
    postBuild = ''
      mkdir -p $out/bin
      rm $out/bin/{pg_config,postgres,pg_ctl}
      cp --target-directory=$out/bin ${postgresql}/bin/{postgres,pg_config,pg_ctl}
      wrapProgram $out/bin/postgres --set NIX_PGLIBDIR $out/lib
    '';

    passthru.version = postgresql.version;
    passthru.psqlSchema = postgresql.psqlSchema;
  };

in
# passed by <major>.nix
versionArgs:
# passed by default.nix
{ self, ... } @defaultArgs:
self.callPackage generic (defaultArgs // versionArgs)

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/patches/paths-with-postgresql-suffix.patch ---
Nix outputs put the `name' in each store path like
/nix/store/...-<name>. This was confusing the Postgres make script
because it thought its data directory already had postgresql in its
directory. This lead to Postgres installing all of its fils in
$out/share. To fix this, we just look for postgres or psql in the part
after the / using make's notdir.

---
--- a/src/Makefile.global.in
+++ b/src/Makefile.global.in
@@ -102,15 +102,15 @@ datarootdir := @datarootdir@
 bindir := @bindir@
 
 datadir := @datadir@
-ifeq "$(findstring pgsql, $(datadir))" ""
-ifeq "$(findstring postgres, $(datadir))" ""
+ifeq "$(findstring pgsql, $(notdir $(datadir)))" ""
+ifeq "$(findstring postgres, $(notdir $(datadir)))" ""
 override datadir := $(datadir)/postgresql
 endif
 endif
 
 sysconfdir := @sysconfdir@
-ifeq "$(findstring pgsql, $(sysconfdir))" ""
-ifeq "$(findstring postgres, $(sysconfdir))" ""
+ifeq "$(findstring pgsql, $(notdir $(sysconfdir)))" ""
+ifeq "$(findstring postgres, $(notdir $(sysconfdir)))" ""
 override sysconfdir := $(sysconfdir)/postgresql
 endif
 endif
@@ -136,8 +136,8 @@ endif
 mandir := @mandir@
 
 docdir := @docdir@
-ifeq "$(findstring pgsql, $(docdir))" ""
-ifeq "$(findstring postgres, $(docdir))" ""
+ifeq "$(findstring pgsql, $(notdir $(docdir)))" ""
+ifeq "$(findstring postgres, $(notdir $(docdir)))" ""
 override docdir := $(docdir)/postgresql
 endif
 endif

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/patches/less-is-more.patch ---
--- a/src/include/fe_utils/print.h
+++ b/src/include/fe_utils/print.h
@@ -18,7 +18,7 @@
 
 /* This is not a particularly great place for this ... */
 #ifndef __CYGWIN__
-#define DEFAULT_PAGER "more"
+#define DEFAULT_PAGER "less"
 #else
 #define DEFAULT_PAGER "less"
 #endif

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/patches/paths-for-split-outputs.patch ---
--- a/src/common/config_info.c
+++ b/src/common/config_info.c
@@ -118,7 +118,7 @@
 	i++;

 	configdata[i].name = pstrdup("PGXS");
+	strlcpy(path, "@out@/lib", sizeof(path));
-	get_pkglib_path(my_exec_path, path);
 	strlcat(path, "/pgxs/src/makefiles/pgxs.mk", sizeof(path));
 	cleanup_path(path);
 	configdata[i].setting = pstrdup(path);

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/patches/relative-to-symlinks.patch ---
On NixOS we *want* stuff relative to symlinks.
---
--- a/src/common/exec.c
+++ b/src/common/exec.c
@@ -218,6 +218,8 @@
 static int
 resolve_symlinks(char *path)
 {
+	return 0;
+
 #ifdef HAVE_READLINK
 	struct stat buf;
 	char		orig_wd[MAXPGPATH],

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/patches/socketdir-in-run-13+.patch ---
--- a/src/include/pg_config_manual.h
+++ b/src/include/pg_config_manual.h
@@ -201,7 +201,7 @@
  * support them yet.
  */
 #ifndef WIN32
-#define DEFAULT_PGSOCKET_DIR  "/tmp"
+#define DEFAULT_PGSOCKET_DIR  "/run/postgresql"
 #else
 #define DEFAULT_PGSOCKET_DIR ""
 #endif

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/patches/specify_pkglibdir_at_runtime.patch ---
--- a/src/port/path.c
+++ b/src/port/path.c
@@ -714,7 +714,11 @@
 void
 get_lib_path(const char *my_exec_path, char *ret_path)
 {
-	make_relative_path(ret_path, LIBDIR, PGBINDIR, my_exec_path);
+	char const * const nix_pglibdir = getenv("NIX_PGLIBDIR");
+	if(nix_pglibdir == NULL)
+		make_relative_path(ret_path, LIBDIR, PGBINDIR, my_exec_path);
+	else
+		make_relative_path(ret_path, nix_pglibdir, PGBINDIR, my_exec_path);
 }
 
 /*
@@ -723,7 +727,11 @@
 void
 get_pkglib_path(const char *my_exec_path, char *ret_path)
 {
-	make_relative_path(ret_path, PKGLIBDIR, PGBINDIR, my_exec_path);
+	char const * const nix_pglibdir = getenv("NIX_PGLIBDIR");
+	if(nix_pglibdir == NULL)
+		make_relative_path(ret_path, PKGLIBDIR, PGBINDIR, my_exec_path);
+	else
+		make_relative_path(ret_path, nix_pglibdir, PGBINDIR, my_exec_path);
 }
 
 /*

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/patches/relative-to-symlinks-16+.patch ---
On NixOS we *want* stuff relative to symlinks.
---
--- a/src/common/exec.c
+++ b/src/common/exec.c
@@ -238,6 +238,8 @@
 static int
 normalize_exec_path(char *path)
 {
+	return 0;
+
 	/*
 	 * We used to do a lot of work ourselves here, but now we just let
 	 * realpath(3) do all the heavy lifting.

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/patches/socketdir-in-run.patch ---
--- a/src/include/pg_config_manual.h
+++ b/src/include/pg_config_manual.h
@@ -179,7 +179,7 @@
  * here's where to twiddle it.  You can also override this at runtime
  * with the postmaster's -k switch.
  */
-#define DEFAULT_PGSOCKET_DIR  "/tmp"
+#define DEFAULT_PGSOCKET_DIR  "/run/postgresql"
 
 /*
  * This is the default event source for Windows event log.

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/postgresql/patches/locale-binary-path.patch ---
--- a/src/backend/commands/collationcmds.c
+++ b/src/backend/commands/collationcmds.c
@@ -611,7 +611,7 @@ pg_import_system_collations(PG_FUNCTION_ARGS)
 		aliases = (CollAliasData *) palloc(maxaliases * sizeof(CollAliasData));
 		naliases = 0;
 
-		locale_a_handle = OpenPipeStream("locale -a", "r");
+		locale_a_handle = OpenPipeStream("@locale@ -a", "r");
 		if (locale_a_handle == NULL)
 			ereport(ERROR,
 					(errcode_for_file_access(),

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/tools/run-replica.sh.in ---
#!/usr/bin/env bash
# shellcheck shell=bash

[ ! -z "$DEBUG" ] && set -x

# first argument should be '15' or '16' for the version
if [ "$1" == "15" ]; then
    echo "Starting server for PSQL 15"
    PSQL15=@PSQL15_BINDIR@
    BINDIR="$PSQL15"
elif [ "$1" == "16" ]; then
    echo "Starting server for PSQL 16"
    PSQL16=@PSQL16_BINDIR@
    BINDIR="$PSQL16"
elif [ "$1" == "orioledb-16" ]; then
    echo "Starting server for PSQL ORIOLEDB 16"
    PSQLORIOLEDB16=@PSQLORIOLEDB16_BINDIR@
    BINDIR="$PSQLORIOLEDB16"
else
    echo "Please provide a valid Postgres version (15, 16 or orioledb-16)"
    exit 1
fi

export PATH=$BINDIR/bin:$PATH

PGSQL_SUPERUSER=@PGSQL_SUPERUSER@
MASTER_PORTNO="$2"
REPLICA_PORTNO="$3"
REPLICA_SLOT="replica_$RANDOM"
DATDIR=$(mktemp -d)
mkdir -p "$DATDIR"

echo "NOTE: runing pg_basebackup for server on port $MASTER_PORTNO"
echo "NOTE: using replica slot $REPLICA_SLOT"

pg_basebackup -p "$MASTER_PORTNO" -h localhost -U "${PGSQL_SUPERUSER}" -X stream -C -S "$REPLICA_SLOT" -v -R -D "$DATDIR"

echo "NOTE: using port $REPLICA_PORTNO for replica"
echo "NOTE: using temporary directory $DATDIR for data, which will not be removed"
echo "NOTE: you are free to re-use this data directory at will"
echo

exec postgres -p "$REPLICA_PORTNO" -D "$DATDIR" -k /tmp

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/tools/run-server.sh.in ---
#!@SHELL_PATH@
# shellcheck shell=bash
[ ! -z "$DEBUG" ] && set -x

# Default values
SKIP_MIGRATIONS=false
PSQL_USER="postgres"
MIGRATION_FILE=""
DAEMONIZE=false
GETKEY_SCRIPT=""

# Function to display help
print_help() {
    echo "Usage: start-postgres-server [options] VERSION [PORT]"
    echo
    echo "Options:"
    echo "  --skip-migrations        Skip running migrations and SQL statements"
    echo "  --migration-file FILE    Provide a custom migration script"
    echo "  --user USER             Specify the user/role to use (default: postgres)"
    echo "  --getkey-script SCRIPT   Provide a custom path to the PGSODIUM_GETKEY_SCRIPT"
    echo "  -h, --help              Show this help message"
    echo
    echo "VERSION must be one of: 15, orioledb-17"
    echo "PORT is optional (default: @PGSQL_DEFAULT_PORT@)"
}

start_postgres() {
    local mode=$1
    local LOG_DIR="${DATDIR}_logs"
    mkdir -p "$LOG_DIR"
    local LOG_FILE="$LOG_DIR/postgres.log"
    touch "$LOG_FILE"
    if [ "$mode" = "daemon" ]; then
        # Start the server
        pg_ctl start -D "$DATDIR" -l "$LOG_FILE" \
            -o "--config-file=$DATDIR/postgresql.conf -p $PORTNO -k $DATDIR/tmp"
            
        # Give it a moment to write logs
        sleep 1
        
        # Check server status and logs
        if ! pg_ctl status -D "$DATDIR"; then
            echo "PostgreSQL failed to start. Full logs:"
            cat "$LOG_FILE"
            # You might also want to see the postmaster.pid if it exists
            if [ -f "$DATDIR/postmaster.pid" ]; then
                echo "postmaster.pid contents:"
                cat "$DATDIR/postmaster.pid"
            fi
            return 1
        fi
    else
        # Foreground mode
        exec postgres --config-file="$DATDIR/postgresql.conf" -p "$PORTNO" -D "$DATDIR" -k "/tmp" -F
    fi
}

stop_postgres() {
    pg_ctl stop -D "$DATDIR" -m fast
}

trap 'stop_postgres' SIGINT SIGTERM

# Parse arguments
# Parse arguments
while [[ "$#" -gt 0 ]]; do
    case "$1" in
        --skip-migrations)
            SKIP_MIGRATIONS=true
            shift
            ;;
        --migration-file)
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                MIGRATION_FILE="$2"
                shift 2
            else
                echo "Error: --migration-file requires a filename"
                exit 1
            fi
            ;;
        --user)
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                PSQL_USER="$2"
                shift 2
            else
                echo "Error: --user requires an argument"
                exit 1
            fi
            ;;
        --getkey-script)
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                GETKEY_SCRIPT="$2"
                shift 2
            else
                echo "Error: --getkey-script requires a script path"
                exit 1
            fi
            ;;
        --daemonize)
            DAEMONIZE=true
            shift
            ;;
        -h|--help)
            print_help
            exit 0
            ;;
        *)
            if [[ "$1" =~ ^- ]]; then
                echo "Unknown option: $1"
                print_help
                exit 1
            elif [[ -z "$VERSION" ]]; then
                VERSION="$1"
                shift
            elif [[ -z "$PORTNO" ]]; then
                PORTNO="$1"
                shift
            else
                echo "Error: Unexpected argument: $1"
                print_help
                exit 1
            fi
            ;;
    esac
done
if [[ -n "${GETKEY_SCRIPT:-}" ]]; then
    export PGSODIUM_GETKEY_SCRIPT="$GETKEY_SCRIPT"
else
    PGSODIUM_GETKEY_SCRIPT="${PGSODIUM_GETKEY_SCRIPT:-@PGSODIUM_GETKEY@}"
fi
# Verify version and set binary directory
if [ "$VERSION" == "15" ]; then
    echo "Starting server for PSQL 15"
    PSQL15=@PSQL15_BINDIR@
    BINDIR="$PSQL15"
elif [ "$VERSION" == "orioledb-17" ]; then
    echo "Starting server for PSQL ORIOLEDB 17"
    PSQLORIOLEDB17=@PSQLORIOLEDB17_BINDIR@
    BINDIR="$PSQLORIOLEDB17"
else
    echo "Please provide a valid Postgres version (15, orioledb-17)"
    exit 1
fi

# Set environment variables and paths
export PATH=$BINDIR/bin:$PATH
PGSQL_SUPERUSER=@PGSQL_SUPERUSER@
PSQL_CONF_FILE=@PSQL_CONF_FILE@
PORTNO="${PORTNO:-@PGSQL_DEFAULT_PORT@}"
SUPAUTILS_CONFIG_FILE=@SUPAUTILS_CONF_FILE@
LOGGING_CONFIG_FILE=@LOGGING_CONF_FILE@
READREPL_CONFIG_FILE=@READREPL_CONF_FILE@
PG_HBA_FILE=@PG_HBA@
PG_IDENT_FILE=@PG_IDENT@
EXTENSION_CUSTOM_SCRIPTS=@EXTENSION_CUSTOM_SCRIPTS_DIR@
GROONGA=@GROONGA_DIR@
MIGRATIONS_DIR=@MIGRATIONS_DIR@
POSTGRESQL_SCHEMA_SQL=@POSTGRESQL_SCHEMA_SQL@
PGBOUNCER_AUTH_SCHEMA_SQL=@PGBOUNCER_AUTH_SCHEMA_SQL@
STAT_EXTENSION_SQL=@STAT_EXTENSION_SQL@
MECAB_LIB=@MECAB_LIB@

# Setup directories and locale settings
DATDIR=$(mktemp -d)
LOCALE_ARCHIVE=@LOCALES@
CURRENT_SYSTEM=@CURRENT_SYSTEM@

# Set locale environment
export LOCALE_ARCHIVE
#export LANG=en_US.UTF-8
#export LANGUAGE=en_US.UTF-8
#export LC_ALL=en_US.UTF-8
#export LC_CTYPE=en_US.UTF-8
# Set locale environment
export LOCALE_ARCHIVE
export LANG=C
export LANGUAGE=C
export LC_ALL=C
export LC_CTYPE=C
export KEY_FILE="$DATDIR/pgsodium.key"
echo "KEY_FILE: $KEY_FILE"
echo "KEY_FILE contents:"
cat "$KEY_FILE" 

echo "PGSODIUM_GETKEY_SCRIPT: $PGSODIUM_GETKEY_SCRIPT"
echo "NOTE: using port $PORTNO for server"
echo "NOTE: using temporary directory $DATDIR for data"
echo "NOTE: you are free to re-use this data directory at will"

# Initialize database
if [ "$VERSION" = "orioledb-17" ]; then
    initdb -D "$DATDIR" \
        --allow-group-access \
        --username="$PGSQL_SUPERUSER" \
        #--locale-provider=icu \
        #--encoding=UTF-8 \
        #--icu-locale=en_US.UTF-8
        --locale=C \
        --encoding=UTF-8
else
    #initdb -U "$PGSQL_SUPERUSER" -D "$DATDIR"
    initdb -U "$PGSQL_SUPERUSER" -D "$DATDIR" --locale=C --encoding=UTF8
fi

# Copy configuration files
echo "NOTE: patching postgresql.conf files"
cp "$PG_HBA_FILE" "$DATDIR/pg_hba.conf"
cp "$PG_IDENT_FILE" "$DATDIR/pg_ident.conf"
cp "$READREPL_CONFIG_FILE" "$DATDIR/read-replica.conf"
mkdir -p "$DATDIR/extension-custom-scripts"
cp -r "$EXTENSION_CUSTOM_SCRIPTS"/* "$DATDIR/extension-custom-scripts"

# Configure supautils
sed "s|supautils.privileged_extensions_custom_scripts_path = '/etc/postgresql-custom/extension-custom-scripts'|supautils.privileged_extensions_custom_scripts_path = '$DATDIR/extension-custom-scripts'|" "$SUPAUTILS_CONFIG_FILE" > "$DATDIR/supautils.conf"

# Configure PostgreSQL
sed -e "1i\\
include = '$DATDIR/supautils.conf'" \
-e "\$a\\
pgsodium.getkey_script = '$PGSODIUM_GETKEY_SCRIPT'" \
-e "s|data_directory = '/var/lib/postgresql/data'|data_directory = '$DATDIR'|" \
-e "s|hba_file = '/etc/postgresql/pg_hba.conf'|hba_file = '$DATDIR/pg_hba.conf'|" \
-e "s|ident_file = '/etc/postgresql/pg_ident.conf'|ident_file = '$DATDIR/pg_ident.conf'|" \
-e "s|include = '/etc/postgresql/logging.conf'|#&|" \
-e "s|include = '/etc/postgresql-custom/read-replica.conf'|include = '$DATDIR/read-replica.conf'|" \
-e "\$a\\
session_preload_libraries = 'supautils'" \
"$PSQL_CONF_FILE" > "$DATDIR/postgresql.conf"

# Function to configure OrioleDB specific settings
orioledb_config_items() {
    if [[ "$1" = "orioledb-17" && "$CURRENT_SYSTEM" != "aarch64-darwin" ]]; then
        # Remove items from postgresql.conf
        echo "non-macos oriole conf"
        sed -i 's/ timescaledb,//g;' "$DATDIR/postgresql.conf"
        sed -i 's/db_user_namespace = off/#db_user_namespace = off/g;' "$DATDIR/postgresql.conf"
        sed -i 's/ timescaledb,//g; s/ plv8,//g; s/ postgis,//g; s/ pgrouting,//g' "$DATDIR/supautils.conf"
        sed -i 's/\(shared_preload_libraries.*\)'\''\(.*\)$/\1, orioledb'\''\2/' "$DATDIR/postgresql.conf"
        echo "default_table_access_method = 'orioledb'" >> "$DATDIR/postgresql.conf"
    elif [[ "$1" = "orioledb-17" && "$CURRENT_SYSTEM" = "aarch64-darwin" ]]; then
        # macOS specific configuration
        echo "macOS detected, applying macOS specific configuration"
        ls -la "$DATDIR"
        
        # Use perl instead of sed for macOS
        perl -pi -e 's/ timescaledb,//g' "$DATDIR/postgresql.conf"
        perl -pi -e 's/db_user_namespace = off/#db_user_namespace = off/g' "$DATDIR/postgresql.conf"
        
        perl -pi -e 's/ timescaledb,//g' "$DATDIR/supautils.conf"
        perl -pi -e 's/ plv8,//g' "$DATDIR/supautils.conf"
        perl -pi -e 's/ postgis,//g' "$DATDIR/supautils.conf"
        perl -pi -e 's/ pgrouting,//g' "$DATDIR/supautils.conf"
        
        perl -pi -e 's/(shared_preload_libraries\s*=\s*'\''.*?)'\''/\1, orioledb'\''/' "$DATDIR/postgresql.conf"
        
        echo "default_table_access_method = 'orioledb'" >> "$DATDIR/postgresql.conf"
    fi
}

# Apply OrioleDB configuration if needed
orioledb_config_items "$VERSION"
# Configure Groonga
export GRN_PLUGINS_DIR=$GROONGA/lib/groonga/plugins

# Start postgres
mkdir -p "$DATDIR/tmp"
chmod 1777 "$DATDIR/tmp"  
start_postgres "daemon"

# Wait for PostgreSQL to start
for i in {1..60}; do
    if pg_isready -h localhost -p "$PORTNO" -q; then
        echo "PostgreSQL is ready"
        break
    fi
    sleep 1
    if [ $i -eq 60 ]; then
        echo "PostgreSQL failed to start"
        'stop_postgres' 1
    fi
done

# Create orioledb extension if needed
if [ "$VERSION" = "orioledb-17" ]; then
    psql -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U "$PGSQL_SUPERUSER" -p "$PORTNO" -h localhost -d postgres -c "CREATE EXTENSION IF NOT EXISTS orioledb;"
fi

# Skip migrations if requested
if [ "$SKIP_MIGRATIONS" = false ]; then
    # Create postgres role and set ownership
    if ! psql -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U "$PGSQL_SUPERUSER" -p "$PORTNO" -h localhost -d postgres <<-EOSQL
        create role postgres superuser login password '$PGPASSWORD';
        alter database postgres owner to postgres;
EOSQL
    then
        'stop_postgres' 1
    fi

    if [ -n "$MIGRATION_FILE" ]; then
        echo "Running user-provided migration file $MIGRATION_FILE"
        if ! psql -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U "$PGSQL_SUPERUSER" -p "$PORTNO" -h localhost -f "$MIGRATION_FILE" postgres; then
            'stop_postgres' 1
        fi
    else
        # Run default init scripts
        for sql in "$MIGRATIONS_DIR"/init-scripts/*.sql; do
            echo "Running $sql"
            if ! psql -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U "$PSQL_USER" -p "$PORTNO" -h localhost -f "$sql" postgres; then
                'stop_postgres' 1
            fi
        done

        # Set superuser password
        if ! psql -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U "$PSQL_USER" -p "$PORTNO" -h localhost -c "ALTER USER supabase_admin WITH PASSWORD '$PGPASSWORD'"; then
            'stop_postgres' 1
        fi

        # Run additional schema files
        if ! psql -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U "$PSQL_USER" -p "$PORTNO" -h localhost -d postgres -f "$PGBOUNCER_AUTH_SCHEMA_SQL"; then
            'stop_postgres' 1
        fi
        if ! psql -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U "$PSQL_USER" -p "$PORTNO" -h localhost -d postgres -f "$STAT_EXTENSION_SQL"; then
            'stop_postgres' 1
        fi

        # Run migrations as superuser
        for sql in "$MIGRATIONS_DIR"/migrations/*.sql; do
            echo "Running $sql"
            if ! psql -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U "$PGSQL_SUPERUSER" -p "$PORTNO" -h localhost -f "$sql" postgres; then
                'stop_postgres' 1
            fi
        done

        # Run PostgreSQL schema
        if ! psql -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U "$PGSQL_SUPERUSER" -p "$PORTNO" -h localhost -f "$POSTGRESQL_SCHEMA_SQL" postgres; then
            'stop_postgres' 1
        fi
    fi
fi
echo "Shutting down PostgreSQL..."
stop_postgres

# Step 4: Restart PostgreSQL in the foreground (with log output visible) or as a daemon
if [ "$DAEMONIZE" = true ]; then
    start_postgres "daemon"
else 
    start_postgres "foreground"
fi

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/tools/local-infra-bootstrap.sh.in ---
#!/usr/bin/env bash
# shellcheck shell=bash

[ ! -z "$DEBUG" ] && set -x

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color
BOLD='\033[1m'

INFRA_REPO_DIR=""
SUPABASE_REPO=""
SETUP_FLAG=false
NODE_VERSION="20"  # Default Node.js version

print_help() {
    echo "Usage: nix run .#local-infra-bootstrap -- [options]"
    echo
    echo "Options:"
    echo "  -h, --help                        Show this help message"
    echo "  -s, --setup                       Setup the local infrastructure for development NOTE: Requires --infrastructure-repo and --supabase-repo"
    echo "  --infrastructure-repo <path>           Full path to infrastructure repository directory"
    echo "  --supabase-repo <path>            Full path to Supabase repository directory"
    echo "  --aws-yubikey-setup               Install AWS CLI tools with YubiKey support"
    echo "  --aws-yubikey-setup-no-key        Install AWS CLI tools without YubiKey"
    echo "  --node-version <version>          Specify Node.js version to install/use (default: $NODE_VERSION)"
    echo
    echo "Description:"
    echo "  Bootstrap the local infrastructure for development."
    echo "  This tool wraps homebrew and other tools to install the necessary dependencies."
    echo
    echo "Examples:"
    echo "  nix run .#local-infra-bootstrap -- --setup --infrastructure-repo /path/to/infrastructure --supabase-repo /path/to/supabase"
    echo "  nix run .#local-infra-bootstrap -- --aws-yubikey-setup"
    echo "  nix run .#local-infra-bootstrap -- --setup --node-version 18"
}

check_brew() {
    if command -v brew >/dev/null 2>&1; then
        echo "Homebrew is installed."
        echo "Version: $(brew --version)"
    else
        echo "Homebrew is not installed."
        echo "To install Homebrew, run the following command:"
        echo
        echo '/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"'
        echo
        echo "After installation, you may need to add Homebrew to your PATH:"
        echo
        echo "For Intel Macs:"
        echo 'echo '\''eval "$(/usr/local/bin/brew shellenv)"'\'' >> ~/.zprofile'
        echo 'eval "$(/usr/local/bin/brew shellenv)"'
        echo
        echo "For Apple Silicon Macs (M1/M2/M3):"
        echo 'echo '\''eval "$(/opt/homebrew/bin/brew shellenv)"'\'' >> ~/.zprofile'
        echo 'eval "$(/opt/homebrew/bin/brew shellenv)"'
        exit 1
    fi
}

check_and_setup_node() {
    echo -e "\n${BOLD}Checking Node.js installation...${NC}"
    
    # Check if the specified node version is installed
    if ! brew list "node@$NODE_VERSION" &>/dev/null; then
        echo "Node.js $NODE_VERSION is not installed. Installing..."
        brew install "node@$NODE_VERSION"
    fi
    
    # Unlink any existing node version
    brew unlink node@* 2>/dev/null || true
    
    # Link the desired version with overwrite
    echo "Linking Node.js $NODE_VERSION..."
    brew link --overwrite --force "node@$NODE_VERSION"
    
    # Verify installation
    if ! command -v node &>/dev/null; then
        echo -e "${RED}❌ Failed to install Node.js $NODE_VERSION${NC}"
        return 1
    fi
    
    current_version=$(node -v | cut -d 'v' -f2 | cut -d '.' -f1)
    if [ "$current_version" = "$NODE_VERSION" ]; then
        echo -e "${GREEN}✅ Node.js $NODE_VERSION is now active${NC}"
        return 0
    else
        echo -e "${RED}❌ Failed to switch to Node.js $NODE_VERSION${NC}"
        return 1
    fi
}

configure_ngrok() {
    echo -e "\n${BOLD}Configuring ngrok settings...${NC}"
    
    if [ -z "$INFRA_REPO_DIR" ]; then
        echo -e "${RED}Error: Infrastructure repository directory not specified${NC}"
        return 1
    fi
    
    local env_file="$INFRA_REPO_DIR/.local.env"
    mkdir -p "$INFRA_REPO_DIR"
    
    read -p "Enter your ngrok static domain (example.ngrok-free.app): " static_domain
    read -p "Enter your ngrok auth token: " auth_token
    
    if [[ -z "$static_domain" || -z "$auth_token" ]]; then
        echo -e "${RED}Error: Both static domain and auth token are required${NC}"
        return 1
    fi
    
    cat > "$env_file" << EOF
EXTERNAL_SUPABASE_API_URL=http://${static_domain}
NGROK_AUTHTOKEN=${auth_token}
NGROK_STATIC_DOMAIN=${static_domain}
WARP_ALWAYS_ENABLED=true
SUPABASE_PATH=${SUPABASE_REPO}
EOF
    
    echo -e "${GREEN}✅ ngrok configuration saved to ${env_file}${NC}"
}

check_app() {
    local brew_name=$1
    local check_command=$2

    echo "Checking $brew_name..."
    
    # Special case for OrbStack
    if [ "$brew_name" = "orbstack" ]; then
        if [ -d "/Applications/OrbStack.app" ]; then
            echo "✅ $brew_name is installed"
            return 0
        else
            echo "❌ $brew_name is not installed"
            return 1
        fi
    fi

    # Standard command check
    if command -v "$check_command" >/dev/null 2>&1; then
        echo "✅ $brew_name is installed"
        return 0
    else
        echo "❌ $brew_name is not installed"
        return 1
    fi
}

install_app() {
    local app=$1
    echo "Installing $app..."
    
    case "$app" in
        "orbstack")
            brew install --cask "$app"
            if [ -d "/Applications/OrbStack.app" ]; then
                echo "✅ OrbStack installed successfully"
                echo "⚠️  Important: Please open OrbStack.app to complete the setup"
                return 0
            fi
            ;;
        "aws-vault")
            brew install --cask "$app"
            # Give the system a moment to complete the linking
            sleep 1
            if [ -f "/opt/homebrew/bin/aws-vault" ] || [ -f "/usr/local/bin/aws-vault" ]; then
                echo "✅ aws-vault installed successfully"
                return 0
            fi
            ;;
        "awscli")
            brew install "$app"
            # Reload shell environment to ensure AWS CLI is in PATH
            eval "$(/opt/homebrew/bin/brew shellenv)"
            if command -v aws >/dev/null 2>&1; then
                echo "✅ $app installed successfully"
                return 0
            fi
            ;;
        "dbmate"|*)
            brew install "$app"
            if command -v "$app" >/dev/null 2>&1; then
                echo "✅ $app installed successfully"
                return 0
            fi
            ;;
    esac

    echo "❌ Failed to install $app"
    return 1
}

check_corepack_pnpm() {
    echo -e "\nChecking Corepack PNPM setup..."
    
    # First check if pnpm binary exists in common locations
    if [ -f "$(which pnpm 2>/dev/null)" ]; then
        # Try to get version without executing pnpm
        echo -e "${GREEN}✅ PNPM is enabled${NC}"
        return 0
    else
        echo -e "${RED}❌ PNPM is not installed${NC}"
        return 1
    fi
}

enable_corepack_pnpm() {
    local pnpm_checked=false
    
    if [ "$pnpm_checked" = false ]; then
        if ! check_corepack_pnpm; then
            read -p "Would you like to enable PNPM through Corepack? (y/n) " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                echo "Running corepack enable pnpm..."
                # Remove existing symlinks if present
                sudo rm -f /opt/homebrew/bin/pnpm /opt/homebrew/bin/pnpx
                if NODE_OPTIONS="" corepack enable pnpm; then
                    echo -e "${GREEN}✅ Successfully enabled PNPM through Corepack${NC}"
                    pnpm_checked=true
                    return 0
                else
                    echo -e "${RED}❌ Failed to enable PNPM through Corepack${NC}"
                    pnpm_checked=true
                    return 1
                fi
            else
                echo -e "\n${BOLD}Skipping PNPM setup...${NC}"
                pnpm_checked=true
                return 0
            fi
        else
            pnpm_checked=true
            return 0
        fi
    fi
    return 0
}

install_prerequisites() {
    echo -e "\n${BOLD}Checking Prerequisites ...${NC}"
    echo

    # Define apps and their check commands
    local apps=("awscli" "dbmate" "orbstack" "corepack" "aws-vault" "tmux" "tmuxp" "ngrok")
    local commands=("aws" "dbmate" "orbstack" "corepack" "aws-vault" "tmux" "tmuxp" "ngrok")
    local pnpm_checked=false
    
    # Check each app and prompt for installation if missing
    for i in "${!apps[@]}"; do
        local brew_name="${apps[$i]}"
        local check_command="${commands[$i]}"
        
        check_app "$brew_name" "$check_command"
        if [ $? -eq 1 ]; then
            read -p "Would you like to install $brew_name? (y/n) " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                case "$brew_name" in
                    "tmux"|"tmuxp")
                        echo "Installing $brew_name..."
                        brew install "$brew_name"
                        if command -v "$brew_name" >/dev/null 2>&1; then
                            echo -e "${GREEN}✅ $brew_name installed successfully${NC}"
                        else
                            echo -e "${RED}❌ Failed to install $brew_name${NC}"
                        fi
                        ;;
                    *)
                        install_app "$brew_name"
                        ;;
                esac
                
                # If we just installed corepack, check and enable pnpm
                if [ "$brew_name" = "corepack" ] && [ "$pnpm_checked" = false ]; then
                    NODE_OPTIONS="" enable_corepack_pnpm
                    pnpm_checked=true
                fi
            else
                echo -e "\n${BOLD}Skipping installation of $brew_name ...${NC}"
            fi
        elif [ "$brew_name" = "corepack" ] && [ "$pnpm_checked" = false ]; then
            # If corepack is already installed, check pnpm once
            NODE_OPTIONS="" enable_corepack_pnpm
            pnpm_checked=true
        fi
        echo
    done
    if command -v ngrok >/dev/null 2>&1; then
        configure_ngrok
    fi
    echo -e "\n${BOLD}Prerequisites Check Complete ${NC}"
}

# AWS YubiKey Setup Function - Only installs required tools
install_aws_tools() {
    echo -e "\n${BOLD}Installing required AWS CLI tools...${NC}"
    
    # Check and install AWS CLI
    if ! command -v aws >/dev/null 2>&1; then
        brew install awscli
        echo -e "✅ AWS CLI installed"
    else
        echo -e "✅ AWS CLI already installed"
    fi
    
    # Check and install AWS Vault
    if ! command -v aws-vault >/dev/null 2>&1; then
        brew install homebrew/cask/aws-vault
        echo -e "✅ AWS Vault installed"
    else
        echo -e "✅ AWS Vault already installed"
    fi
    
    if [[ "$1" != "--no-yubikey" ]]; then
        # Check and install YubiKey Manager
        if ! command -v ykman >/dev/null 2>&1; then
            brew install ykman
            echo -e "✅ YubiKey Manager installed"
        else
            echo -e "✅ YubiKey Manager already installed"
        fi
    fi

    echo -e "\n${BOLD}✅ AWS CLI tools installation complete${NC}"
    echo -e "Please follow the AWS CLI MFA+YubiKey setup documentation for next steps."
}

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            print_help
            exit 0
            ;;
        -s|--setup)
            SETUP_FLAG=true
            shift
            ;;
        --node-version)
            if [ -n "$2" ]; then
                NODE_VERSION="$2"
                shift 2
            else
                echo "Error: --node-version requires a version number"
                exit 1
            fi
            ;;
        --infrastructure-repo)
            if [ -n "$2" ]; then
                INFRA_REPO_DIR="$2"
                shift 2
            else
                echo "Error: --infrastructure-repo requires a path argument"
                exit 1
            fi
            ;;
        --supabase-repo)
            if [ -n "$2" ]; then
                SUPABASE_REPO="$2"
                shift 2
            else
                echo "Error: --supabase-repo requires a path argument"
                exit 1
            fi
            ;;
        --aws-yubikey-setup)
            check_brew
            install_aws_tools
            shift
            ;;
        --aws-yubikey-setup-no-key)
            check_brew
            install_aws_tools "--no-yubikey"
            shift
            ;;
        *)
            echo "Unknown argument: $1"
            print_help
            exit 1
            ;;
    esac
done

# Validate setup requirements
if [ "$SETUP_FLAG" = true ]; then
    if [ -z "$INFRA_REPO_DIR" ]; then
        echo -e "${RED}Error: --infrastructure-repo is required when using --setup${NC}"
        print_help
        exit 1
    fi
    if [ -z "$SUPABASE_REPO" ]; then
        echo -e "${RED}Error: --supabase-repo is required when using --setup${NC}"
        print_help
        exit 1
    fi
    check_brew
    check_and_setup_node
    install_prerequisites
fi

# If no arguments provided, show help
if [ "$SETUP_FLAG" = false ] && [ -z "$INFRA_REPO_DIR" ]; then
    print_help
    exit 0
fi
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/tools/migrate-tool.sh.in ---
#!/usr/bin/env bash

[ ! -z "$DEBUG" ] && set -x

# first argument is the old version; a path 15 or 16
if [[ $1 == /nix/store* ]]; then
    if [ ! -L "$1/receipt.json" ] || [ ! -e "$1/receipt.json" ]; then
        echo "ERROR: $1 does not look like a valid Postgres install"
        exit 1
    fi
    OLDVER="$1"
elif [ "$1" == "15" ]; then
    PSQL15=@PSQL15_BINDIR@
    OLDVER="$PSQL15"
elif [ "$1" == "16" ]; then
    PSQL16=@PSQL16_BINDIR@
    OLDVER="$PSQL16"
else
    echo "Please provide a valid Postgres version (15 or 16), or a /nix/store path"
    exit 1
fi

# second argument is the new version; 15 or 16
if [[ $2 == /nix/store* ]]; then
    if [ ! -L "$2/receipt.json" ] || [ ! -e "$2/receipt.json" ]; then
        echo "ERROR: $1 does not look like a valid Postgres install"
        exit 1
    fi
    NEWVER="$2"
elif [ "$2" == "15" ]; then
    PSQL15=@PSQL15_BINDIR@
    NEWVER="$PSQL15"
elif [ "$2" == "16" ]; then
    PSQL16=@PSQL16_BINDIR@
    NEWVER="$PSQL16"
    echo "NEWVER IS $NEWVER"
else
    echo "Please provide a valid Postgres version (15 or 16), or a /nix/store path"
    exit 1
fi

# thid argument is the upgrade method: either pg_dumpall or pg_ugprade
if [ "$3" != "pg_dumpall" ] && [ "$3" != "pg_upgrade" ]; then
    echo "Please provide a valid upgrade method (pg_dumpall or pg_upgrade)"
    exit 1
fi
UPGRADE_METHOD="$3"

echo "Old server build: PSQL $1"
echo "New server build: PSQL $2"
echo "Upgrade method: $UPGRADE_METHOD"

PORTNO="${2:-@PGSQL_DEFAULT_PORT@}"
DATDIR=$(mktemp -d)
NEWDAT=$(mktemp -d)
mkdir -p "$DATDIR" "$NEWDAT"

echo "NOTE: using temporary directory $DATDIR for PSQL $1 data, which will not be removed"
echo "NOTE: you are free to re-use this data directory at will"
echo

$OLDVER/bin/initdb -D "$DATDIR" --locale=C --username=supabase_admin
$NEWVER/bin/initdb -D "$NEWDAT" --locale=C --username=supabase_admin

# NOTE (aseipp): we need to patch postgresql.conf to have the right pgsodium_getkey script
PSQL_CONF_FILE=@PSQL_CONF_FILE@
PGSODIUM_GETKEY_SCRIPT=@PGSODIUM_GETKEY@
echo "NOTE: patching postgresql.conf files"
for x in "$DATDIR" "$NEWDAT"; do
  sed \
    "s#@PGSODIUM_GETKEY_SCRIPT@#$PGSODIUM_GETKEY_SCRIPT#g" \
    $PSQL_CONF_FILE > "$x/postgresql.conf"
done

echo "NOTE: Starting first server (v${1}) to load data into the system"
$OLDVER/bin/pg_ctl start -D "$DATDIR"

PRIMING_SCRIPT=@PRIMING_SCRIPT@
MIGRATION_DATA=@MIGRATION_DATA@

$OLDVER/bin/psql -h localhost -d postgres -Xf "$PRIMING_SCRIPT"
$OLDVER/bin/psql -h localhost -d postgres -Xf "$MIGRATION_DATA"

if [ "$UPGRADE_METHOD" == "pg_upgrade" ]; then
  echo "NOTE: Stopping old server (v${1}) to prepare for migration"
  $OLDVER/bin/pg_ctl stop -D "$DATDIR"

  echo "NOTE: Migrating old data $DATDIR to $NEWDAT using pg_upgrade"

  export PGDATAOLD="$DATDIR"
  export PGDATANEW="$NEWDAT"
  export PGBINOLD="$OLDVER/bin"
  export PGBINNEW="$NEWVER/bin"

  if ! $NEWVER/bin/pg_upgrade --check; then
      echo "ERROR: pg_upgrade check failed"
      exit 1
  fi

  echo "NOTE: pg_upgrade check passed, proceeding with migration"
  $NEWVER/bin/pg_upgrade
  rm -f delete_old_cluster.sh # we don't need this
  exit 0
fi

if [ "$UPGRADE_METHOD" == "pg_dumpall" ]; then
    SQLDAT="$DATDIR/dump.sql"
    echo "NOTE: Exporting data via pg_dumpall ($SQLDAT)"
    $NEWVER/bin/pg_dumpall -h localhost > "$SQLDAT"

    echo "NOTE: Stopping old server (v${1}) to prepare for migration"
    $OLDVER/bin/pg_ctl stop -D "$DATDIR"

    echo "NOTE: Starting second server (v${2}) to load data into the system"
    $NEWVER/bin/pg_ctl start -D "$NEWDAT"

    echo "NOTE: Loading data into new server (v${2}) via 'cat | psql'"
    cat "$SQLDAT" | $NEWVER/bin/psql -h localhost -d postgres

    printf "\n\n\n\n"
    echo "NOTE: Done, check logs. Stopping the server; new database is located at $NEWDAT"
    $NEWVER/bin/pg_ctl stop -D "$NEWDAT"
fi

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/tools/sync-exts-versions.sh.in ---
#!/usr/bin/env bash
# shellcheck shell=bash

[ ! -z "$DEBUG" ] && set -x

#pass in env vars supplied by nix
yq=@YQ@
jq=@JQ@
editor=@NIX_EDITOR@
ansible_vars=$($yq '.' $PWD/ansible/vars.yml) 
prefetchurl=@NIXPREFETCHURL@
_nix=@NIX@
fetch_source_url() {
    local source_url=${1//\"/}  # Remove double quotes
    source_url=${source_url//\'/}  # Remove single quotes
    
    # Check if the source URL is provided
    if [ -z "$source_url" ]; then
        echo "Usage: fetch_nix_url <source_url>"
        return 1
    fi
    
    echo "$source_url"
    
    # Run nix-prefetch-url command
    local initial_hash=$($prefetchurl --type sha256 "$source_url" --unpack | cut -d ' ' -f 2)
    #once we can bump up nix version, we can use nix hash convert --hash-algo sha256
    local final_hash=$($_nix hash to-sri --type sha256 $initial_hash)
    echo "$final_hash"
}

sync_version() {

    local package_name=$1
    local version="\"$2\""
    local hash="\"$3\""


    # Update the version and hash in the Nix expression
    $editor $PWD/nix/ext/$package_name.nix version --inplace -v "$version"
    $editor $PWD/nix/ext/$package_name.nix src.hash --inplace -v $hash
}

run_sync() {
    local varname=$1
    local package_name=$2

    version=$(echo $ansible_vars |  $jq -r '.'$varname'')
    echo "$key: $version"
    url=$($_nix eval .#psql_15/exts/$package_name.src.url)
    hash=$(fetch_source_url $url | tail -n 1)
    $(sync_version $package_name $version $hash)
    echo "synced $package_name to version $version with hash $hash"


}

#for use where nix uses fetchurl 
# instead of fetchFromGithub
fetchurl_source_url() {
    local source_url=${1//\"/}  # Remove double quotes
    source_url=${source_url//\'/}  # Remove single quotes
    
    # Check if the source URL is provided
    if [ -z "$source_url" ]; then
        echo "Usage: fetch_nix_url <source_url>"
        return 1
    fi
    
    echo "$source_url"
    
    # Run nix-prefetch-url command
    local initial_hash=$($prefetchurl --type sha256 "$source_url" | cut -d ' ' -f 2)
    #once we can bump up nix version, we can use nix hash convert --hash-algo sha256
    local final_hash=$($_nix hash to-sri --type sha256 $initial_hash)
    echo "$final_hash"
}

sync_version_fetchurl() {

    local package_name=$1
    local version="\"$2\""
    local hash="\"$3\""


    # Update the version and hash in the Nix expression
    $editor $PWD/nix/ext/$package_name.nix version --inplace -v "$version"
    $editor $PWD/nix/ext/$package_name.nix src.sha256 --inplace -v $hash
}


run_sync_fetchurl() {
    local varname=$1
    local package_name=$2

    version=$(echo $ansible_vars |  $jq -r '.'$varname'')
    echo "$key: $version"
    url=$($_nix eval .#psql_15/exts/$package_name.src.url)
    hash=$(fetchurl_source_url $url | tail -n 1)
    $(sync_version_fetchurl $package_name $version $hash)
    echo "synced $package_name to version $version with hash $hash"


}

#for use on derivations that use cargoHash
update_cargo_vendor_hash() {
    local package_name=$1
    $editor $PWD/nix/ext/$package_name.nix cargoHash --inplace -v ""
    output=$($_nix build .#psql_15/exts/$package_name 2>&1)

    # Check if the command exited with an error
    if [ $? -ne 0 ]; then
        # Extract the hash value after "got: "
        hash_value_scraped=$(echo "$output" | grep "got:" | awk '{for (i=1; i<=NF; i++) if ($i ~ /^sha/) print $i}')
        hash_value="\"$hash_value_scraped\""
        # Continue using the captured hash value
        $editor $PWD/nix/ext/$package_name.nix cargoHash --inplace -v $hash_value
        echo "Updated cargoHash for $package_name to $hash_value"
    else
        echo "$package_name builds successfully, moving on..."
    fi
}

#iterate values in ansible vars, case statement
# to match ansible var to package name
keys=$(echo "$ansible_vars" | $jq -r 'keys[]')

for key in $keys; do
    case $key in
        "pg_hashids_release")
            varname="pg_hashids_release"
            package_name="pg_hashids"
            run_sync $varname $package_name
            ;;
        "hypopg_release")
            varname="hypopg_release"
            package_name="hypopg"
            run_sync $varname $package_name
            ;;
        "pg_graphql_release")
            varname="pg_graphql_release"
            package_name="pg_graphql"
            run_sync $varname $package_name
            update_cargo_vendor_hash $package_name
            ;;
        "pg_cron_release")
            varname="pg_cron_release"
            package_name="pg_cron"
            run_sync $varname $package_name
            ;;
        "pgsql_http_release")
            varname="pgsql_http_release"
            package_name="pgsql-http"
            run_sync $varname $package_name
            ;;
        "pg_jsonschema_release")
            varname="pg_jsonschema_release"
            package_name="pg_jsonschema"
            run_sync $varname $package_name
            update_cargo_vendor_hash $package_name
            ;;
        "pg_net_release")
            varname="pg_net_release"
            package_name="pg_net"
            run_sync $varname $package_name
            ;;
        "pg_plan_filter_release")
            varname="pg_plan_filter_release"
            package_name="pg_plan_filter"
            run_sync $varname $package_name
            ;;
        "pg_safeupdate_release")
            varname="pg_safeupdate_release"
            package_name="pg-safeupdate"
            run_sync $varname $package_name
            ;;
        "pgsodium_release")
            varname="pgsodium_release"
            package_name="pgsodium"
            run_sync $varname $package_name
            ;;
        "pg_repack_release")
            varname="pg_repack_release"
            package_name="pg_repack"
            run_sync $varname $package_name
            ;;
        "pgrouting_release")
            varname="pgrouting_release"
            package_name="pgrouting"
            run_sync $varname $package_name
            ;;
        "ptap_release")
            varname="pgtap_release"
            package_name="pgtap"
            run_sync $varname $package_name
            ;;
        "pg_stat_monitor_release")
            varname="pg_stat_monitor_release"
            package_name="pg_stat_monitor"
            run_sync $varname $package_name
            ;;
        "pg_tle_release")
            varname="pg_tle_release"
            package_name="pg_tle"
            run_sync $varname $package_name
            ;;
        "pgaudit_release")
            varname="pgaudit_release"
            package_name="pgaudit"
            run_sync $varname $package_name
            ;;
        "plpgsql_check_release")
            varname="plpgsql_check_release"
            package_name="plpgsql-check"
            run_sync $varname $package_name
            ;;
        "pgvector_release")
            varname="pgvector_release"
            package_name="pgvector"
            run_sync $varname $package_name
            ;;
        "pgjwt_release")
            varname="pgjwt_release"
            package_name="pgjwt"
            run_sync $varname $package_name
            ;;
        "plv8_release")
            varname="plv8_release"
            package_name="plv8"
            run_sync $varname $package_name
            ;;
        "postgis_release")
            varname="postgis_release"
            package_name="postgis"
            run_sync_fetchurl $varname $package_name
            ;;
        "pgroonga_release")
            varname="pgroonga_release"
            package_name="pgroonga"
            run_sync_fetchurl $varname $package_name
            ;;
        "rum_release")
            varname="rum_release"
            package_name="rum"
            run_sync $varname $package_name
            ;;
        "timescaledb_release")
            varname="timescaledb_release"
            package_name="timescaledb"
            run_sync $varname $package_name
            ;;
        "supautils_release")
            varname="supautils_release"
            package_name="supautils"
            run_sync $varname $package_name
            ;;
        "vault_release")
            varname="vault_release"
            package_name="vault"
            run_sync $varname $package_name
            ;;
        "wal2json_release")
            varname="wal2json_release"
            package_name="wal2json"
            run_sync $varname $package_name
            ;;
        *)
            ;;
    esac
done

# url=$($_nix eval .#psql_16/exts/pgvector.src.url)

# fetch_nix_url "$url"

#res=$editor /home/sam/postgres/nix/ext/pgvector.nix src 
#echo $res
# url=$($_nix eval .#psql_16/exts/pgvector.src.url)
# #echo $url
# hash=$(fetch_source_url $url | tail -n 1)
# echo "$hash"

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/tools/postgresql_schema.sql ---
ALTER DATABASE postgres SET "app.settings.jwt_secret" TO  'my_jwt_secret_which_is_not_so_secret';
ALTER DATABASE postgres SET "app.settings.jwt_exp" TO 3600;
ALTER USER supabase_admin WITH PASSWORD 'postgres';
ALTER USER postgres WITH PASSWORD 'postgres';
ALTER USER authenticator WITH PASSWORD 'postgres';
ALTER USER pgbouncer WITH PASSWORD 'postgres';
ALTER USER supabase_auth_admin WITH PASSWORD 'postgres';
ALTER USER supabase_storage_admin WITH PASSWORD 'postgres';
ALTER USER supabase_replication_admin WITH PASSWORD 'postgres';
ALTER ROLE supabase_read_only_user WITH PASSWORD 'postgres';
ALTER ROLE supabase_admin SET search_path TO "$user",public,auth,extensions;

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/tools/README.md ---
This directory just contains tools, but you can't run them directly. For the
sake of robustness, you should use `nix run` on this repository to do so.

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/tools/update_readme.nu ---
#!/usr/bin/env nu

# Load required data
def load_flake [] {
    nix flake show --json --all-systems | from json
}

def find_index [list: list<any>, value: any] {
    let enumerated = ($list | enumerate)
    let found = ($enumerated | where item == $value | first)
    if ($found | is-empty) {
        -1
    } else {
        $found.index
    }
}

def get_systems [flake_json] {
    $flake_json | get packages | columns
}

def get_postgres_versions [flake_json] {
    let packages = ($flake_json | get packages | get aarch64-linux)
    
    # Get available versions from postgresql packages
    let available_versions = ($packages 
        | columns 
        | where {|col| 
            # Match exact postgresql_<number> or postgresql_orioledb-<number>
            $col =~ "^postgresql_\\d+$" or $col =~ "^postgresql_orioledb-\\d+$"
        }
        | each {|pkg_name|
            let is_orioledb = ($pkg_name =~ "orioledb")
            let pkg_info = ($packages | get $pkg_name)
            let version = if $is_orioledb {
                $pkg_info.name | str replace "postgresql-" "" | split row "_" | first  # Get "17" from "postgresql-17_5"
            } else {
                $pkg_info.name | str replace "postgresql-" "" | split row "." | first  # Get "15" from "postgresql-15.8"
            }
            {
                version: $version,
                is_orioledb: $is_orioledb,
                name: $pkg_info.name
            }
        }
    )

    $available_versions | uniq | sort-by version
}

def get_src_url [pkg_attr] {
    let result = (do { nix eval $".#($pkg_attr).src.url" } | complete)
    if $result.exit_code == 0 {
        $result.stdout | str trim | str replace -a '"' ''  # Remove all quotes
    } else {
        null
    }
}

def get_extension_info [flake_json, pg_info] {
    let major_version = ($pg_info.version | split row "." | first)
    let version_prefix = if $pg_info.is_orioledb {
        "psql_orioledb-" + $major_version + "/exts/"
    } else {
        "psql_" + $major_version + "/exts/"
    }
    
    print $"Looking for extensions with prefix: ($version_prefix)"
    
    let sys_packages = ($flake_json | get packages | get aarch64-linux)
    let ext_names = ($sys_packages 
        | columns 
        | where {|col| $col =~ $"^($version_prefix)"}
    )
    print $"Found extensions: ($ext_names | str join ', ')"
    
    let all_exts = ($ext_names | each {|ext_name| 
        let ext_info = ($sys_packages | get $ext_name)
        let name = ($ext_name | str replace $version_prefix "")
        let version = if $name == "orioledb" {
            $ext_info.name  # Use name directly for orioledb
        } else if ($ext_info.name | str contains "-") {
            $ext_info.name | split row "-" | last
        } else {
            $ext_info.name
        }
        let src_url = (get_src_url $ext_name)
        {
            name: $name,
            version: $version,
            description: $ext_info.description,
            url: $src_url
        }
    })
    
    $all_exts | sort-by name
}

def create_version_link [pg_info] {
    if $pg_info.is_orioledb {
        let display = $"orioledb-($pg_info.name)"
        let url = "https://github.com/orioledb/orioledb"
        $"- ✅ Postgres [($display)]\(($url)\)"
    } else {
        let major_version = ($pg_info.version | split row "." | first)
        let url = $"https://www.postgresql.org/docs/($major_version)/index.html"
        $"- ✅ Postgres [($pg_info.name)]\(($url)\)"  # Use full version number
    }
}

def create_ext_table [extensions, pg_info] {
    let header_version = if $pg_info.is_orioledb {
        $"orioledb-($pg_info.version)"  # Add orioledb prefix for orioledb versions
    } else {
        $pg_info.version
    }
    
    let header = [
        "",  # blank line for spacing
        $"### PostgreSQL ($header_version) Extensions",
        "| Extension | Version | Description |",
        "| ------------- | :-------------: | ------------- |"
    ]
    
    let rows = ($extensions | each {|ext|
        let name = $ext.name
        let version = $ext.version
        let desc = $ext.description
        let url = $ext.url  # Get URL from extension info
        
        $"| [($name)]\(($url)\) | [($version)]\(($url)\) | ($desc) |"
    })
    
    $header | append $rows
}

def update_readme [] {
    let flake_json = (load_flake)
    let readme_path = ([$env.PWD "README.md"] | path join)
    let readme = (open $readme_path | lines)
    let pg_versions = (get_postgres_versions $flake_json)
    
    # Find section indices
    let features_start = ($readme | where $it =~ "^## Primary Features" | first)
    let features_end = ($readme | where $it =~ "^## Extensions" | first)
    let features_start_idx = (find_index $readme $features_start)
    let features_end_idx = (find_index $readme $features_end)
    
    if $features_start_idx == -1 or $features_end_idx == -1 {
        error make {msg: "Could not find Features sections"}
    }
    
    # Update Primary Features section
    let features_content = [
        ($pg_versions | each {|version| create_version_link $version} | str join "\n")
        "- ✅ Ubuntu 20.04 (Focal Fossa)."
        "- ✅ [wal_level](https://www.postgresql.org/docs/current/runtime-config-wal.html) = logical and [max_replication_slots](https://www.postgresql.org/docs/current/runtime-config-replication.html) = 5. Ready for replication."
        "- ✅ [Large Systems Extensions](https://github.com/aws/aws-graviton-getting-started#building-for-graviton-and-graviton2). Enabled for ARM images."
    ]

    # Find extension section indices
    let ext_start = ($readme | where $it =~ "^## Extensions" | first)
    let ext_start_idx = (find_index $readme $ext_start)
    
    # Find next section after Extensions or use end of file
    let next_section_idx = ($readme 
        | enumerate 
        | where {|it| $it.index > $ext_start_idx and ($it.item =~ "^## ")} 
        | first
        | get index
        | default ($readme | length)
    )
    
    if $ext_start_idx == -1 {
        error make {msg: "Could not find Extensions section"}
    }

    # Create extension sections content
    let ext_sections_content = ($pg_versions | each {|version|
        let extensions = (get_extension_info $flake_json $version)
        create_ext_table $extensions $version
    } | flatten)

    # Combine sections, removing duplicate headers
    let before_features = ($readme 
        | range (0)..($features_start_idx)
        | where {|line| not ($line =~ "^## Primary Features")}
    )
    let features_header = ($readme | get $features_start_idx)
    let between_sections = ($readme 
        | range ($features_end_idx)..($ext_start_idx)
        | where {|line| 
            not ($line =~ "^## Primary Features" or $line =~ "^## Extensions")
        }
    )
    let ext_header = ($readme | get $ext_start_idx)
    let after_ext = ($readme | range ($next_section_idx)..($readme | length))

    let output = ($before_features 
        | append $features_header
        | append $features_content
        | append $between_sections
        | append $ext_header
        | append $ext_sections_content
        | append $after_ext
        | str join "\n")
    
    $output | save --force $readme_path
}

# Main execution
update_readme
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/tools/dbmate-tool.sh.in ---
#!/usr/bin/env bash
# shellcheck shell=bash

[ ! -z "$DEBUG" ] && set -x

# Default values
PSQL_VERSION="ALL"
PORTNO="@PGSQL_DEFAULT_PORT@"
PGSQL_SUPERUSER="@PGSQL_SUPERUSER@"
PGPASSWORD="${PGPASSWORD:-postgres}"
PGSQL_USER="postgres"
FLAKE_URL="github:supabase/postgres"
MIGRATIONS_DIR="@MIGRATIONS_DIR@"
CURRENT_SYSTEM="@CURRENT_SYSTEM@"
ANSIBLE_VARS="@ANSIBLE_VARS@"
PGBOUNCER_AUTH_SCHEMA_SQL=@PGBOUNCER_AUTH_SCHEMA_SQL@
STAT_EXTENSION_SQL=@STAT_EXTENSION_SQL@
# Cleanup function
cleanup() {
    echo "Cleaning up..."
    
    # Kill postgres processes first
    if pgrep -f "postgres" >/dev/null; then
        pkill -TERM postgres || true
        sleep 2
    fi

    # Then kill overmind
    if [ -S "./.overmind.sock" ]; then
        overmind kill || true
        sleep 2
    fi

    # Kill tmux sessions explicitly
    pkill -f "tmux.*overmind.*postgresql" || true
    tmux ls 2>/dev/null | grep 'overmind' | cut -d: -f1 | xargs -I{} tmux kill-session -t {} || true

    # Force kill any stragglers
    pkill -9 -f "(postgres|tmux.*overmind.*postgresql)" || true
    
    rm -f .overmind.sock Procfile

    # Final verification
    if ps aux | grep -E "(postgres|overmind|tmux.*postgresql)" | grep -v grep >/dev/null; then
        ps aux | grep -E "(postgres|overmind|tmux.*postgresql)" | grep -v grep
        return 1
    fi
}

# Set up trap for cleanup on script exit

# Function to display help
print_help() {
    echo "Usage: nix run .#dbmate-tool -- [options]"
    echo
    echo "Options:"
    echo "  -v, --version [15|16|orioledb-17|all]  Specify the PostgreSQL version to use (required defaults to --version all)"
    echo "  -p, --port PORT                    Specify the port number to use (default: 5435)"
    echo "  -h, --help                         Show this help message"
    echo
    echo "Description:"
    echo "  Runs 'dbmate up' against a locally running the version of database you specify. Or 'all' to run against all versions."
    echo "  NOTE: To create a migration, you must run 'nix develop' and then 'dbmate new <migration_name>' to create a new migration file."
    echo
    echo "Examples:"
    echo "  nix run .#dbmate-tool"
    echo "  nix run .#dbmate-tool -- --version 15"
    echo "  nix run .#dbmate-tool -- --version 16 --port 5433"
}


# Parse arguments
while [[ "$#" -gt 0 ]]; do
    case "$1" in
        -v|--version)
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                PSQL_VERSION="$2"
                shift 2
            else
                echo "Error: --version requires an argument (15, 16, or orioledb-17)"
                exit 1
            fi
            ;;
        -u|--user)
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                PGSQL_USER="$2"
                shift 2
            else
                echo "Error: --user requires an argument"
                exit 1
            fi
            ;;
        -f|--flake-url)
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                FLAKE_URL="$2"
                shift 2
            else
                echo "Error: --flake-url requires an argument"
                exit 1
            fi
            ;;
        -p|--port)
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                PORTNO="$2"
                shift 2
            else
                echo "Error: --port requires an argument"
                exit 1
            fi
            ;;
        -h|--help)
            print_help
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            print_help
            exit 1
            ;;
    esac
done

# Function to wait for PostgreSQL to be ready
wait_for_postgres() {
    local max_attempts=30  # Increased significantly
    local attempt=1
    
    # Give overmind a moment to actually start the process
    sleep 2
    
    while [ $attempt -le $max_attempts ]; do
        "${PSQLBIN}/pg_isready" -h localhost -p "$PORTNO" -U "$PGSQL_SUPERUSER" -d postgres
        local status=$?
        
        if [ $status -eq 0 ]; then
            echo "PostgreSQL is ready!"
            return 0
        fi
        echo "Waiting for PostgreSQL to start (attempt $attempt/$max_attempts)..."
        sleep 2
        attempt=$((attempt + 1))
    done
    
    echo "PostgreSQL failed to start after $max_attempts attempts"
    overmind echo postgres
    return 1
}

check_orioledb_ready() {
    local max_attempts=30
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        if "${PSQLBIN}/psql" -v ON_ERROR_STOP=1 -U "$PGSQL_SUPERUSER" -p "$PORTNO" -h localhost -d postgres -c "SELECT * FROM pg_am WHERE amname = 'orioledb'" | grep -q orioledb; then
            echo "Orioledb extension is ready!"
            return 0
        fi
        echo "Waiting for orioledb to be ready (attempt $attempt/$max_attempts)..."
        sleep 2
        attempt=$((attempt + 1))
    done
    
    echo "Orioledb failed to initialize after $max_attempts attempts"
    return 1
}

trim_schema() {
    case "$CURRENT_SYSTEM" in
    "x86_64-darwin"|"aarch64-darwin")
        sed -i '' '/INSERT INTO public.schema_migrations/,$d' "./db/schema.sql"
        echo "Matched: $CURRENT_SYSTEM"
        ;;
    *)
        sed -i '/INSERT INTO public.schema_migrations/,$d' "./db/schema.sql"
        ;;
    esac
}
overmind_start() {
        cat > Procfile << EOF
postgres_${PSQL_VERSION}: exec nix run "$FLAKE_URL#start-server" -- "$PSQL_VERSION" --skip-migrations
EOF
    overmind start -D
    echo "Waiting for overmind socket..."
    max_wait=5
    count=0
    while [ $count -lt $max_wait ]; do
        if [ -S "./.overmind.sock" ]; then
            # Found the socket, give it a moment to be ready
            sleep 5
            echo "Socket file found and ready"
            break
        fi
        echo "Waiting for socket file (attempt $count/$max_wait)"
        sleep 1
        count=$((count + 1))
    done
}
perform_dump() {
    local max_attempts=3
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        echo "Attempting dbmate dump (attempt $attempt/$max_attempts)"
        
        if dbmate dump; then
            return 0
        fi
        
        echo "Dump attempt $attempt failed, waiting before retry..."
        sleep 5
        attempt=$((attempt + 1))
    done
    
    echo "All dump attempts failed"
    return 1
}
migrate_version() {
    echo "PSQL_VERSION: $PSQL_VERSION"
    overmind kill || true
    rm -f .overmind.sock Procfile  || true
    PSQLBIN=$(nix build --no-link "$FLAKE_URL#psql_$PSQL_VERSION/bin" --json | jq -r '.[].outputs.out + "/bin"')
    echo "Using PostgreSQL version $PSQL_VERSION from $PSQLBIN"
    
    # Start overmind
    overmind_start
    echo "Waiting for overmind socket..."


    echo "Waiting for PostgreSQL to be ready..."

    #Wait for PostgreSQL to be ready to accept connections
    if ! wait_for_postgres; then
        echo "Failed to connect to PostgreSQL server"
        exit 1
    fi
    
    if [ "$PSQL_VERSION" = "orioledb-17" ]; then
        if ! check_orioledb_ready; then
            echo "Failed to initialize orioledb extension"
            exit 1
        fi
    fi

    echo "PostgreSQL server is ready"

    # Configure PostgreSQL roles and permissions
    if ! "${PSQLBIN}/psql" -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U "$PGSQL_SUPERUSER" -p "$PORTNO" -h localhost -d postgres <<-EOSQL
create role postgres superuser login password '$PGPASSWORD';
alter database postgres owner to postgres;
EOSQL
    then
        echo "Failed to configure PostgreSQL roles and permissions"
        exit 1
    fi
    "${PSQLBIN}/psql" -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U postgres -p "$PORTNO" -h localhost -d postgres -f "$PGBOUNCER_AUTH_SCHEMA_SQL"
    "${PSQLBIN}/psql" -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U postgres -p "$PORTNO" -h localhost -d postgres -f "$STAT_EXTENSION_SQL"

    #set db url to run dbmate
    export DATABASE_URL="postgres://$PGSQL_USER:$PGPASSWORD@localhost:$PORTNO/postgres?sslmode=disable"
    #export path so dbmate can find correct psql and pg_dump
    export PATH="$PSQLBIN:$PATH"
    # run init scripts
    if ! dbmate --migrations-dir "$MIGRATIONS_DIR/init-scripts" up; then
        echo "Error: Initial migration failed"
        exit 1
    fi

    # Password update command
    if ! "${PSQLBIN}/psql" -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U postgres -p "$PORTNO" -h localhost -c "ALTER USER supabase_admin WITH PASSWORD '$PGPASSWORD'"; then
        echo "Error: Failed to update supabase_admin password"
        exit 1
    fi

    # Set up database URL
    export DATABASE_URL="postgres://$PGSQL_SUPERUSER:$PGPASSWORD@localhost:$PORTNO/postgres?sslmode=disable"
    # Run migrations
    if ! dbmate --migrations-dir "$MIGRATIONS_DIR/migrations" up; then
        echo "Error: Final migration failed"
        exit 1
    fi

    echo "Running dbmate dump with $PSQLBIN"
    perform_dump

    echo "CURRENT_SYSTEM: $CURRENT_SYSTEM"
    if [ -f "./db/schema.sql" ]; then
        trim_schema
        cp "./db/schema.sql" "./migrations/schema-$PSQL_VERSION.sql"
        echo "Schema file moved to ./migrations/schema-$PSQL_VERSION.sql"
        echo "PSQLBIN is $PSQLBIN"
    else
        echo "Warning: schema.sql file not found in ./db directory"
        exit 1
    fi

    # If we get here, all commands succeeded
    echo "PostgreSQL migration completed successfully"
    echo "Check migrations are idempotent"
    for sql in ./migrations/db/migrations/*.sql; do
        echo "$0: running $sql"
        "${PSQLBIN}/psql" -v ON_ERROR_STOP=1 --no-password --no-psqlrc -U "$PGSQL_SUPERUSER" -p "$PORTNO" -h localhost -d postgres -f "$sql" || {
            echo "Failed to execute $sql"
            exit 1
        }
    done
}

if [ "$PSQL_VERSION" == "all" ]; then
    VERSIONS=$(yq '.postgres_major[]' "$ANSIBLE_VARS" | tr -d '"')
    echo "$VERSIONS" | while read -r version; do
        PSQL_VERSION="$version"
        echo "Migrating to PostgreSQL version $PSQL_VERSION"
        migrate_version
        cleanup
    done
else
    echo "Migrating to PostgreSQL version $PSQL_VERSION"
    migrate_version
    cleanup
fi

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/tools/run-client.sh.in ---
#!/usr/bin/env bash
# shellcheck shell=bash

[ ! -z "$DEBUG" ] && set -x

# Default values
PSQL_VERSION="15"
MIGRATION_FILE=""
PORTNO="@PGSQL_DEFAULT_PORT@"
PSQL_USER="postgres"

# Function to display help
print_help() {
    echo "Usage: nix run .#start-client -- [options]"
    echo
    echo "Options:"
    echo "  -v, --version [15|16|orioledb-16]  Specify the PostgreSQL version to use (required)"
    echo "  -f, --file FILE                    Provide a custom migration script"
    echo "  -u, --user USER                    Specify the user/role to use (default: postgres)"
    echo "  -h, --help                         Show this help message"
    echo
    echo "Description:"
    echo "  Starts an interactive 'psql' session connecting to a Postgres database started with the"
    echo "  'nix run .#start-server' command. If a migration file is not provided, the client"
    echo "  initializes the database with the default migrations for a new Supabase project."
    echo "  If a migrations file is provided, default migrations are skipped"
    echo "  If no migration file is provided, it runs the default Supabase migrations."
    echo
    echo "Examples:"
    echo "  nix run .#start-client"
    echo "  nix run .#start-client -- --version 15"
    echo "  nix run .#start-client -- --version 16 --file custom_migration.sql"
    echo "  nix run .#start-client -- --version 16 --port 5433"
    echo "  nix run .#start-client -- --version 16 --user supabase_admin"
}

# Parse arguments
while [[ "$#" -gt 0 ]]; do
    case "$1" in
        -v|--version)
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                PSQL_VERSION="$2"
                shift 2
            else
                echo "Error: --version requires an argument (15, 16, or orioledb-16)"
                exit 1
            fi
            ;;
        -f|--file)
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                MIGRATION_FILE="$2"
                shift 2
            else
                echo "Error: --file requires a filename"
                exit 1
            fi
            ;;
        -u|--user)
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                PSQL_USER="$2"
                shift 2
            else
                echo "Error: --user requires an argument"
                exit 1
            fi
            ;;
        -p|--port)
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                PORTNO="$2"
                shift 2
            else
                echo "Error: --port requires an argument"
                exit 1
            fi
            ;;
        -h|--help)
            print_help
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            print_help
            exit 1
            ;;
    esac
done

# Check if version is provided
if [[ -z "$PSQL_VERSION" ]]; then
    echo "Error: PostgreSQL version is required."
    print_help
    exit 1
fi

# Determine PostgreSQL version
if [ "$PSQL_VERSION" == "15" ]; then
    echo "Starting client for PSQL 15"
    PSQL15=@PSQL15_BINDIR@
    BINDIR="$PSQL15"
elif [ "$PSQL_VERSION" == "16" ]; then
    echo "Starting client for PSQL 16"
    PSQL16=@PSQL16_BINDIR@
    BINDIR="$PSQL16"
elif [ "$PSQL_VERSION" == "orioledb-17" ]; then
    echo "Starting client for PSQL ORIOLEDB 17"
    PSQLORIOLEDB16=@PSQLORIOLEDB17_BINDIR@
    BINDIR="$PSQLORIOLEDB16"
else
    echo "Please provide a valid Postgres version (15, 16, or orioledb-16)"
    exit 1
fi

#vars for migration.sh
export PATH=$BINDIR/bin:$PATH
export POSTGRES_DB=postgres
export POSTGRES_HOST=localhost

PGSQL_SUPERUSER=@PGSQL_SUPERUSER@
MIGRATIONS_DIR=@MIGRATIONS_DIR@
POSTGRESQL_SCHEMA_SQL=@POSTGRESQL_SCHEMA_SQL@
PGBOUNCER_AUTH_SCHEMA_SQL=@PGBOUNCER_AUTH_SCHEMA_SQL@
STAT_EXTENSION_SQL=@STAT_EXTENSION_SQL@

# Start interactive psql session
exec psql -U "$PSQL_USER" -p "$PORTNO" -h localhost postgres

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/tools/supabase-groonga.nix ---
{ lib, stdenv, cmake, fetchurl, kytea, msgpack-c, mecab, pkg-config, rapidjson
, testers, xxHash, zstd, postgresqlPackages, makeWrapper, suggestSupport ? false
, zeromq, libevent, openssl, lz4Support ? false, lz4, zlibSupport ? true, zlib
, writeShellScriptBin, callPackage }:
let mecab-naist-jdic = callPackage ./ext/mecab-naist-jdic { };
in stdenv.mkDerivation (finalAttrs: {
  pname = "supabase-groonga";
  version = "14.0.5";
  src = fetchurl {
    url =
      "https://packages.groonga.org/source/groonga/groonga-${finalAttrs.version}.tar.gz";
    hash = "sha256-y4UGnv8kK0z+br8wXpPf57NMXkdEJHcLCuTvYiubnIc=";
  };
  patches =
    [ ./fix-cmake-install-path.patch ./do-not-use-vendored-libraries.patch ];
  nativeBuildInputs = [ cmake pkg-config makeWrapper ];
  buildInputs = [ rapidjson xxHash zstd mecab kytea msgpack-c ]
    ++ lib.optionals lz4Support [ lz4 ] ++ lib.optional zlibSupport [ zlib ]
    ++ lib.optionals suggestSupport [ zeromq libevent ];
  cmakeFlags = [
    "-DWITH_MECAB=ON"
    "-DMECAB_DICDIR=${mecab-naist-jdic}/lib/mecab/dic/naist-jdic"
    "-DMECAB_CONFIG=${mecab}/bin/mecab-config"
    "-DENABLE_MECAB_TOKENIZER=ON"
    "-DMECAB_INCLUDE_DIR=${mecab}/include"
    "-DMECAB_LIBRARY=${mecab}/lib/libmecab.so"
    "-DGROONGA_ENABLE_TOKENIZER_MECAB=YES"
    "-DGRN_WITH_MECAB=YES"
  ];
  preConfigure = ''
    export MECAB_DICDIR=${mecab-naist-jdic}/lib/mecab/dic/naist-jdic
    echo "MeCab dictionary directory is: $MECAB_DICDIR"
  '';
  buildPhase = ''
    cmake --build . -- VERBOSE=1
    grep -i mecab CMakeCache.txt || (echo "MeCab not detected in CMake cache" && exit 1)
    echo "CMake cache contents related to MeCab:"
    grep -i mecab CMakeCache.txt
  '';

  # installPhase = ''
  #   mkdir -p $out/bin $out/lib/groonga/plugins
  #   cp -r lib/groonga/plugins/* $out/lib/groonga/plugins
  #   cp -r bin/* $out/bin
  #   echo "Installed Groonga plugins:"
  #   ls -l $out/lib/groonga/plugins
  # '';

  postInstall = ''
    echo "Searching for MeCab-related files:"
    find $out -name "*mecab*"

    echo "Checking Groonga plugins directory:"
    ls -l $out/lib/groonga/plugins

    echo "Wrapping Groonga binary:"
    wrapProgram $out/bin/groonga \
      --set GRN_PLUGINS_DIR $out/lib/groonga/plugins 

  '';
  env.NIX_CFLAGS_COMPILE =
    lib.optionalString zlibSupport "-I${zlib.dev}/include";

  meta = with lib; {
    homepage = "https://groonga.org/";
    description = "Open-source fulltext search engine and column store";
    license = licenses.lgpl21;
    platforms = platforms.all;
    longDescription = ''
      Groonga is an open-source fulltext search engine and column store.
      It lets you write high-performance applications that requires fulltext search.
    '';
  };
})
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/tools/run-restore.sh.in ---
#!/usr/bin/env bash
# shellcheck shell=bash

set -euo pipefail

# Function to display help message
show_help() {
    echo "Usage: nix run .#pg-restore -- [OPTIONS]"
    echo
    echo "Run pg_restore with the specified parameters."
    echo
    echo "Options:"
    echo "  --version     PostgreSQL version (currently only 15 is supported)"
    echo "  --dbname      Name of the database to restore to"
    echo "  --host        Host of the database server"
    echo "  --user        Database user to connect as"
    echo "  --file        Path to the file to restore from (absolute or relative to current directory)"
    echo "  --port        Port number (default: 5432)"
    echo "  -h, --help    Show this help message and exit"
    echo "Example:"
    echo "nix run .#pg-restore --  --version 15 --dbname postgres --host localhost --user postgres --port 5435 --file my.dump"
}

# Initialize variables
PG_VERSION=""
DBNAME=""
DBHOST=""
DBUSER=""
RESTORE_FILE=""
PORT="5432"

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --version)
            PG_VERSION="$2"
            shift 2
            ;;
        --dbname)
            DBNAME="$2"
            shift 2
            ;;
        --host)
            DBHOST="$2"
            shift 2
            ;;
        --user)
            DBUSER="$2"
            shift 2
            ;;
        --file)
            RESTORE_FILE="$2"
            shift 2
            ;;
        --port)
            PORT="$2"
            shift 2
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
done

# Check if all required arguments are provided
if [ -z "$PG_VERSION" ] || [ -z "$DBNAME" ] || [ -z "$DBHOST" ] || [ -z "$DBUSER" ] || [ -z "$RESTORE_FILE" ]; then
    echo "Error: Missing required arguments."
    show_help
    exit 1
fi

if [ "$PG_VERSION" == "15" ]; then
    echo "Starting restore for PSQL 15"
    PSQL15=@PSQL15_BINDIR@
    PSQL_BINDIR="$PSQL15"
else
    echo "Error: Please provide a valid Postgres version (currently only 15 is supported)"
    show_help
    exit 1
fi

# Convert RESTORE_FILE to an absolute path if it's relative
if [[ "$RESTORE_FILE" != /* ]]; then
    RESTORE_FILE="$(pwd)/$RESTORE_FILE"
fi

# Check if the file exists
if [ ! -f "$RESTORE_FILE" ]; then
    echo "Error: Restore file '$RESTORE_FILE' does not exist."
    exit 1
fi

echo "Using restore file: $RESTORE_FILE"

# Run pg_restore and capture its exit status
"$PSQL_BINDIR/bin/pg_restore" \
    -h "$DBHOST" \
    -p "$PORT" \
    -U "$DBUSER" \
    -d "$DBNAME" \
    -v \
    --no-owner \
    --no-acl \
    "$RESTORE_FILE"

RESTORE_STATUS=$?

# Check the exit status of pg_restore
if [ $RESTORE_STATUS -eq 0 ]; then
    echo "Restore completed successfully."
    exit 0
else
    echo "Restore failed with exit code $RESTORE_STATUS."
    exit $RESTORE_STATUS
fi
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/tools/wal-g.nix ---
{ lib
, buildGoModule
, fetchFromGitHub
, brotli
, libsodium
, installShellFiles
,
}:

let
  walGCommon = { version, vendorHash, sha256, majorVersion }:
    buildGoModule rec {
      pname = "wal-g-${majorVersion}";
      inherit version;

      src = fetchFromGitHub {
        owner = "wal-g";
        repo = "wal-g";
        rev = "v${version}";
        inherit sha256;
      };

      inherit vendorHash;

      nativeBuildInputs = [ installShellFiles ];

      buildInputs = [
        brotli
        libsodium
      ];

      subPackages = [ "main/pg" ];

      tags = [
        "brotli"
        "libsodium"
      ];

      ldflags = [
        "-s"
        "-w"
        "-X github.com/wal-g/wal-g/cmd/pg.walgVersion=${version}"
        "-X github.com/wal-g/wal-g/cmd/pg.gitRevision=${src.rev}"
      ];

      postInstall = ''
        mv $out/bin/pg $out/bin/wal-g-${majorVersion}
        
        # Create version-specific completions
        mkdir -p $out/share/bash-completion/completions
        $out/bin/wal-g-${majorVersion} completion bash > $out/share/bash-completion/completions/wal-g-${majorVersion}
        
        mkdir -p $out/share/zsh/site-functions
        $out/bin/wal-g-${majorVersion} completion zsh > $out/share/zsh/site-functions/_wal-g-${majorVersion}
        
      '';

      meta = with lib; {
        homepage = "https://github.com/wal-g/wal-g";
        license = licenses.asl20;
        description = "Archival restoration tool for PostgreSQL";
        mainProgram = "wal-g-${majorVersion}";
      };
    };
in
{
  # wal-g v2.0.1
  wal-g-2 = walGCommon {
    version = "2.0.1";
    sha256 = "sha256-5mwA55aAHwEFabGZ6c3pi8NLcYofvoe4bb/cFj7NWok=";
    vendorHash = "sha256-BbQuY6r30AkxlCZjY8JizaOrqEBdv7rIQet9KQwYB/g=";
    majorVersion = "2";
  };

  # wal-g v3.0.5
  wal-g-3 = walGCommon {
    version = "3.0.5";
    sha256 = "sha256-wVr0L2ZXMuEo6tc2ajNzPinVQ8ZVzNOSoaHZ4oFsA+U=";
    vendorHash = "sha256-YDLAmRfDl9TgbabXj/1rxVQ052NZDg3IagXVTe5i9dw=";
    majorVersion = "3";
  };
}
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docker/init.sh.in ---
#!/bin/bash
# shellcheck shell=bash
/bin/initdb --locale=C -D /data/postgresql --username=supabase_admin
ln -s /etc/postgresql.conf /data/postgresql/postgresql.conf
/bin/postgres -p @PGSQL_DEFAULT_PORT@ -D /data/postgresql 

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/overlays/psql_16-oriole.nix ---
final: prev: {
  pg_orioledb = prev.postgresql_16.overrideAttrs (old: {
    pname = "postgresql_orioledb";
    version = "16_31";
    src = prev.fetchurl {
      url = "https://github.com/orioledb/postgres/archive/refs/tags/patches16_31.tar.gz";
      sha256 = "sha256-29uHUACwZKh8e4zJ9tWzEhLNjEuh6P31KbpxnMEhtuI=";
    };
    buildInputs = old.buildInputs ++ [
      prev.bison
      prev.docbook5
      prev.docbook_xsl
      prev.docbook_xsl_ns
      prev.docbook_xml_dtd_45
      prev.flex
      prev.libxslt
      prev.perl
    ];
  });
  postgresql_orioledb = final.pg_orioledb;
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/overlays/cargo-pgrx-0-11-3.nix ---
final: prev: {
  #cargo-pgrx_0_11_3 = cargo-pgrx.cargo-pgrx_0_11_3;

  buildPgrxExtension_0_11_3 = prev.buildPgrxExtension.override {
    cargo-pgrx = final.cargo-pgrx_0_11_3;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg_repack.nix ---
{ lib
, stdenv
, fetchFromGitHub
, openssl
, postgresql
, postgresqlTestHook
, readline
, testers
, zlib
}:

stdenv.mkDerivation (finalAttrs: {
  pname = "pg_repack";
  version = "1.5.2";

  buildInputs = postgresql.buildInputs ++ [ postgresql ];

  makeFlags = [ "USE_PGXS=1" ];

  src = fetchFromGitHub {
    owner = "reorg";
    repo = "pg_repack";
    rev = "ver_${finalAttrs.version}";
    hash = "sha256-wfjiLkx+S3zVrAynisX1GdazueVJ3EOwQEPcgUQt7eA=";
  };

  installPhase = ''
    install -D bin/pg_repack -t $out/bin/
    install -D lib/pg_repack${postgresql.dlSuffix} -t $out/lib/
    install -D lib/{pg_repack--${finalAttrs.version}.sql,pg_repack.control} -t $out/share/postgresql/extension
  '';

  passthru.tests = {
    version = testers.testVersion {
      package = finalAttrs.finalPackage;
    };
    extension = stdenv.mkDerivation {
      name = "plpgsql-check-test";
      dontUnpack = true;
      doCheck = true;
      buildInputs = [ postgresqlTestHook ];
      nativeCheckInputs = [ (postgresql.withPackages (ps: [ ps.pg_repack ])) ];
      postgresqlTestUserOptions = "LOGIN SUPERUSER";
      failureHook = "postgresqlStop";
      checkPhase = ''
        runHook preCheck
        psql -a -v ON_ERROR_STOP=1 -c "CREATE EXTENSION pg_repack;"
        runHook postCheck
      '';
      installPhase = "touch $out";
    };
  };

  meta = with lib; {
    description = "Reorganize tables in PostgreSQL databases with minimal locks";
    longDescription = ''
      pg_repack is a PostgreSQL extension which lets you remove bloat from tables and indexes, and optionally restore
      the physical order of clustered indexes. Unlike CLUSTER and VACUUM FULL it works online, without holding an
      exclusive lock on the processed tables during processing. pg_repack is efficient to boot,
      with performance comparable to using CLUSTER directly.
    '';
    homepage = "https://github.com/reorg/pg_repack";
    license = licenses.bsd3;
    inherit (postgresql.meta) platforms;
    mainProgram = "pg_repack";
  };
})

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg_regress.nix ---
{ lib
, stdenv
, postgresql
}:

stdenv.mkDerivation {
  pname = "pg_regress";
  version = postgresql.version;

  phases = [ "installPhase" ];

  installPhase = ''
    mkdir -p $out/bin
    cp ${postgresql}/lib/pgxs/src/test/regress/pg_regress $out/bin/
  '';

  meta = with lib; {
    description = "Regression testing tool for PostgreSQL";
    homepage = "https://www.postgresql.org/";
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/vault.nix ---
{ lib, stdenv, fetchFromGitHub, libsodium, postgresql }:

stdenv.mkDerivation rec {
  pname = "vault";
  version = "0.3.1";

  buildInputs = [ libsodium postgresql ];

  src = fetchFromGitHub {
    owner = "supabase";
    repo = pname;
    rev = "refs/tags/v${version}";
    hash = "sha256-MC87bqgtynnDhmNZAu96jvfCpsGDCPB0g5TZfRQHd30=";
  };

  makeFlags = [ "USE_PGXS=1" ];

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    install -D *${postgresql.dlSuffix} $out/lib
    install -D -t $out/share/postgresql/extension sql/*.sql
    install -D -t $out/share/postgresql/extension *.control
  '';

  meta = with lib; {
    description = "Store encrypted secrets in PostgreSQL";
    homepage = "https://github.com/supabase/${pname}";
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pgjwt.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql, unstableGitUpdater }:

stdenv.mkDerivation rec {
  pname = "pgjwt";
  version = "9742dab1b2f297ad3811120db7b21451bca2d3c9";

  src = fetchFromGitHub {
    owner  = "michelp";
    repo   = "pgjwt";
    rev    = "${version}";
    hash = "sha256-Hw3R9bMGDmh+dMzjmqZSy/rT4mX8cPU969OJiARFg10=";
  };

  dontBuild = true;
  installPhase = ''
    mkdir -p $out/share/postgresql/extension
    cp pg*sql *.control $out/share/postgresql/extension
  '';

  passthru.updateScript = unstableGitUpdater { };

  meta = with lib; {
    description = "PostgreSQL implementation of JSON Web Tokens";
    longDescription = ''
      sign() and verify() functions to create and verify JSON Web Tokens.
    '';
    license = licenses.mit;
    platforms = postgresql.meta.platforms;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg_cron.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "pg_cron";
  version = "1.6.4";

  buildInputs = [ postgresql ];

  src = fetchFromGitHub {
    owner  = "citusdata";
    repo   = pname;
    rev    = "v${version}";
    hash = "sha256-t1DpFkPiSfdoGG2NgNT7g1lkvSooZoRoUrix6cBID40=";
  };

  makeFlags = [ "USE_PGXS=1" ];

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp *${postgresql.dlSuffix}      $out/lib
    cp *.sql     $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Run Cron jobs through PostgreSQL";
    homepage    = "https://github.com/citusdata/pg_cron";
    changelog   = "https://github.com/citusdata/pg_cron/raw/v${version}/CHANGELOG.md";
    platforms   = postgresql.meta.platforms;
    license     = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/plpgsql-check.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql, postgresqlTestHook }:

stdenv.mkDerivation rec {
  pname = "plpgsql-check";
  version = "2.7.11";

  src = fetchFromGitHub {
    owner = "okbob";
    repo = "plpgsql_check";
    rev = "v${version}";
    hash = "sha256-vR3MvfmUP2QEAtXFpq0NCCKck3wZPD+H3QleHtyVQJs=";
  };

  buildInputs = [ postgresql ];

  makeFlags = [ "USE_PGXS=1" ];

  installPhase = ''
    install -D -t $out/lib *${postgresql.dlSuffix}
    install -D -t $out/share/postgresql/extension *.sql
    install -D -t $out/share/postgresql/extension *.control
  '';

  passthru.tests.extension = stdenv.mkDerivation {
    name = "plpgsql-check-test";
    dontUnpack = true;
    doCheck = true;
    buildInputs = [ postgresqlTestHook ];
    nativeCheckInputs = [ (postgresql.withPackages (ps: [ ps.plpgsql_check ])) ];
    postgresqlTestUserOptions = "LOGIN SUPERUSER";
    failureHook = "postgresqlStop";
    checkPhase = ''
      runHook preCheck
      psql -a -v ON_ERROR_STOP=1 -c "CREATE EXTENSION plpgsql_check;"
      runHook postCheck
    '';
    installPhase = "touch $out";
  };

  meta = with lib; {
    description = "Linter tool for language PL/pgSQL";
    homepage = "https://github.com/okbob/plpgsql_check";
    changelog = "https://github.com/okbob/plpgsql_check/releases/tag/v${version}";
    platforms = postgresql.meta.platforms;
    license = licenses.mit;
    maintainers = [ maintainers.marsam ];
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/orioledb.nix ---
{ lib, stdenv, fetchFromGitHub, curl, libkrb5, postgresql, python3, openssl }:

stdenv.mkDerivation rec {
  pname = "orioledb";
  name = pname;
  src = fetchFromGitHub {
    owner = "orioledb";
    repo = "orioledb";
    rev = "beta10";  # Keep original version
    sha256 = "sha256-O4OTi8ickylVXE9FURm5R++A+l15Z22YLna7OVzVMjc=";  
  };
  version = "beta10";  # Keep original version
  buildInputs = [ curl libkrb5 postgresql python3 openssl ];
  buildPhase = "make USE_PGXS=1 ORIOLEDB_PATCHSET_VERSION=6";
  installPhase = ''
    runHook preInstall

    mkdir -p $out/{lib,share/postgresql/extension}

    # Copy the extension library
    cp orioledb${postgresql.dlSuffix} $out/lib/

    # Copy sql files from the sql directory
    cp sql/*.sql $out/share/postgresql/extension/

    # Copy control file
    cp orioledb.control $out/share/postgresql/extension/

    runHook postInstall
  '';
  doCheck = true;
  meta = with lib; {
    description = "OrioleDB storage engine for PostgreSQL";
    homepage = "https://github.com/orioledb/orioledb";
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg_net.nix ---
{ lib, stdenv, fetchFromGitHub, curl, postgresql }:

stdenv.mkDerivation rec {
  pname = "pg_net";
  version = "0.14.0";

  buildInputs = [ curl postgresql ];

  src = fetchFromGitHub {
    owner = "supabase";
    repo = pname;
    rev = "refs/tags/v${version}";
    hash = "sha256-c1pxhTyrE5j6dY+M5eKAboQNofIORS+Dccz+7HKEKQI=";
  };

  makeFlags = [ "USE_PGXS=1" ];
  env.NIX_CFLAGS_COMPILE = "-Wno-error";

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp *${postgresql.dlSuffix}      $out/lib
    cp sql/*.sql $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Async networking for Postgres";
    homepage = "https://github.com/supabase/pg_net";
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/use-system-groonga.patch ---
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 33b34477..f4ffefe5 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -12,7 +12,6 @@ if(MSVC_VERSION LESS 1800)
   message(FATAL_ERROR "PGroonga supports only MSVC 2013 or later")
 endif()
 
-add_subdirectory(vendor/groonga)
 
 set(PGRN_POSTGRESQL_DIR "${CMAKE_INSTALL_PREFIX}"
   CACHE PATH "PostgreSQL binary directory")
@@ -52,8 +51,6 @@ string(REGEX REPLACE "([0-9]+)\\.([0-9]+)\\.([0-9]+)" "\\3"
 string(REGEX REPLACE ".*comment = '([^']+)'.*" "\\1"
   PGRN_DESCRIPTION "${PGRN_CONTROL}")
 
-file(READ "${CMAKE_CURRENT_SOURCE_DIR}/vendor/groonga/bundled_message_pack_version"
-  PGRN_BUNDLED_MESSAGE_PACK_VERSION)
 string(STRIP
   "${PGRN_BUNDLED_MESSAGE_PACK_VERSION}"
   PGRN_BUNDLED_MESSAGE_PACK_VERSION)
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg_backtrace.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "pg_backtrace";
  version = "1.1";

  buildInputs = [ postgresql ];

  src = fetchFromGitHub {
    owner  = "pashkinelfe";
    repo   = pname;
    rev    = "d100bac815a7365e199263f5b3741baf71b14c70";
    hash = "sha256-IVCL4r4oj1Ams03D8y+XCFkckPFER/W9tQ68GkWQQMY=";
  };

  makeFlags = [ "USE_PGXS=1" ];

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp *${postgresql.dlSuffix}      $out/lib
    cp *.sql     $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Updated fork of pg_backtrace";
    homepage    = "https://github.com/pashkinelfe/pg_backtrace";
    platforms   = postgresql.meta.platforms;
    license     = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pljava.nix ---
{ stdenv, lib, fetchFromGitHub, openssl, openjdk, maven, postgresql, libkrb5, makeWrapper, gcc, pkg-config, which }:

maven.buildMavenPackage rec {
  pname = "pljava";

  version = "1.6.7"; 

  src = fetchFromGitHub {
    owner = "tada";
    repo = "pljava";
    rev = "V1_6_7";  
    sha256 = "sha256-M17adSLsw47KZ2BoUwxyWkXKRD8TcexDAy61Yfw4fNU=";  
    
  };

  mvnParameters = "clean install -Dmaven.test.skip -DskipTests -Dmaven.javadoc.skip=true";  
  mvnHash = "sha256-lcxRduh/nKcPL6YQIVTsNH0L4ga0LgJpQKgX5IPkRzs=";
  
  nativeBuildInputs = [ makeWrapper maven openjdk postgresql openssl postgresql gcc libkrb5 pkg-config ];
  buildInputs = [ stdenv.cc.cc.lib which];
  buildPhase = ''
    export PATH=$(lib.makeBinPath [ postgresql ]):$PATH

  '';
  buildOffline = true;

  installPhase = ''
    mkdir -p $out/pljavabuild
    cp -r *   $out/pljavabuild
    mkdir -p $out/share/postgresql/extension/pljava
    mkdir -p $out/share/postgresql/pljava
    mkdir -p $out/lib
    mkdir -p $out/etc
    java -Dpgconfig=${postgresql}/bin/pg_config \
      -Dpgconfig.sharedir=$out/share \
      -Dpgconfig.sysconfdir=$out/etc/pljava.policy \
      -Dpgconfig.pkglibdir=$out/lib \
      -jar $out/pljavabuild/pljava-packaging/target/pljava-pg15.jar
    cp $out/share/pljava/* $out/share/postgresql/extension/pljava
    cp $out/share/pljava/* $out/share/postgresql/pljava
    cp $out/share/extension/*.control $out/share/postgresql/extension
    rm -r $out/pljavabuild
  '';

  meta = with lib; {
    description = "PL/Java extension for PostgreSQL";
    homepage = https://github.com/tada/pljava;
    license = licenses.bsd3;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg_stat_monitor.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

let
  # NOTE (aseipp): the 1.x series of pg_stat_monitor has some non-standard and
  # weird build logic (Percona projects in general seem to have their own
  # strange build harness) where it will try to pick the right .sql file to
  # install into the extension dir based on the postgresql major version. for
  # our purposes, we only need to support v13 and v14+, so just replicate this
  # logic from the makefile and pick the right file here.
  #
  # this seems to all be cleaned up in version 2.0 of the extension, so ideally
  # we could upgrade to it later on and nuke this.
  # DEPRECATED sqlFilename = if lib.versionOlder postgresql.version "14"
  #   then "pg_stat_monitor--1.0.13.sql.in"
  #   else "pg_stat_monitor--1.0.14.sql.in";

in
stdenv.mkDerivation rec {
  pname = "pg_stat_monitor";
  version = "2.1.0";

  buildInputs = [ postgresql ];

  src = fetchFromGitHub {
    owner = "percona";
    repo = pname;
    rev = "refs/tags/${version}";
    hash = "sha256-STJVvvrLVLe1JevNu6u6EftzAWv+X+J8lu66su7Or2s=";
  };

  makeFlags = [ "USE_PGXS=1" ];

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}
  
    cp *${postgresql.dlSuffix}      $out/lib
    cp *.sql     $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Query Performance Monitoring Tool for PostgreSQL";
    homepage = "https://github.com/percona/${pname}";
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
    broken = lib.versionOlder postgresql.version "15";
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg_plan_filter.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "pg_plan_filter";
  version = "5081a7b5cb890876e67d8e7486b6a64c38c9a492";

  buildInputs = [ postgresql ];

  src = fetchFromGitHub {
    owner = "pgexperts";
    repo = pname;
    rev = "${version}";
    hash = "sha256-YNeIfmccT/DtOrwDmpYFCuV2/P6k3Zj23VWBDkOh6sw=";
  };

  makeFlags = [ "USE_PGXS=1" ];  # ADD THIS LINE

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp *${postgresql.dlSuffix}      $out/lib
    cp *.sql     $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Filter PostgreSQL statements by execution plans";
    homepage = "https://github.com/pgexperts/${pname}";
    maintainers = with maintainers; [ samrose ];
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/postgis.nix ---
{ fetchurl
, lib, stdenv
, perl
, libxml2
, postgresql
, geos
, proj
, json_c
, pkg-config
, file
, protobufc
, libiconv
, pcre2
, nixosTests
, callPackage
}:

let
  sfcgal = callPackage ./sfcgal/sfcgal.nix { };
  gdal = callPackage ./gdal.nix { inherit postgresql; };
in
stdenv.mkDerivation rec {
  pname = "postgis";
  version = "3.3.7";

  outputs = [ "out" "doc" ];

  src = fetchurl {
    url = "https://download.osgeo.org/postgis/source/postgis-${version}.tar.gz";
    sha256 = "sha256-UHJKDd5JrcJT5Z4CTYsY/va+ToU0GUPG1eHhuXTkP84=";
  };

  buildInputs = [ libxml2 postgresql geos proj gdal json_c protobufc pcre2.dev sfcgal ]
                ++ lib.optional stdenv.isDarwin libiconv;
  nativeBuildInputs = [ perl pkg-config ];
  dontDisableStatic = true;


  env.NIX_LDFLAGS = "-L${lib.getLib json_c}/lib";

  preConfigure = ''
    sed -i 's@/usr/bin/file@${file}/bin/file@' configure
    configureFlags="--datadir=$out/share/postgresql --datarootdir=$out/share/postgresql --bindir=$out/bin --docdir=$doc/share/doc/${pname} --with-gdalconfig=${gdal}/bin/gdal-config --with-jsondir=${json_c.dev} --disable-extension-upgrades-install --with-sfcgal"

    makeFlags="PERL=${perl}/bin/perl datadir=$out/share/postgresql pkglibdir=$out/lib bindir=$out/bin docdir=$doc/share/doc/${pname}"
  '';

  postConfigure = ''
    sed -i "s|@mkdir -p \$(DESTDIR)\$(PGSQL_BINDIR)||g ;
            s|\$(DESTDIR)\$(PGSQL_BINDIR)|$prefix/bin|g
            " \
        "raster/loader/Makefile";
    sed -i "s|\$(DESTDIR)\$(PGSQL_BINDIR)|$prefix/bin|g
            " \
        "raster/scripts/python/Makefile";
    mkdir -p $out/bin
    ln -s ${postgresql}/bin/postgres $out/bin/postgres
  '';

postInstall = ''
  rm $out/bin/postgres
  for prog in $out/bin/*; do # */
    ln -s $prog $prog-${version}
  done
  # Add function definition and usage to tiger geocoder files
  for file in $out/share/postgresql/extension/postgis_tiger_geocoder*--${version}.sql; do
      sed -i "/SELECT postgis_extension_AddToSearchPath('tiger');/a SELECT postgis_extension_AddToSearchPath('extensions');" "$file"
  done
  # Original topology patching
  for file in $out/share/postgresql/extension/postgis_topology*--${version}.sql; do
    sed -i "/SELECT topology.AddToSearchPath('topology');/i SELECT topology.AddToSearchPath('extensions');" "$file"
  done
  mkdir -p $doc/share/doc/postgis
  mv doc/* $doc/share/doc/postgis/
'';

  passthru.tests.postgis = nixosTests.postgis;

  meta = with lib; {
    description = "Geographic Objects for PostgreSQL";
    homepage = "https://postgis.net/";
    changelog = "https://git.osgeo.org/gitea/postgis/postgis/raw/tag/${version}/NEWS";
    license = licenses.gpl2;
    inherit (postgresql.meta) platforms;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/plv8.nix ---
{ stdenv
, lib
, fetchFromGitHub
, v8
, perl
, postgresql
# For passthru test on various systems, and local development on macos
# not we are not currently using passthru tests but retaining for possible contrib
# to nixpkgs 
, runCommand
, coreutils
, gnugrep
, clang
, xcbuild
, darwin
, patchelf
}:

stdenv.mkDerivation (finalAttrs: {
  pname = "plv8";
  version = "3.1.10";

  src = fetchFromGitHub {
    owner = "plv8";
    repo = "plv8";
    rev = "v${finalAttrs.version}";
    hash = "sha256-g1A/XPC0dX2360Gzvmo9/FSQnM6Wt2K4eR0pH0p9fz4=";
  };

  patches = [
    # Allow building with system v8.
    # https://github.com/plv8/plv8/pull/505 (rejected)
    ./0001-build-Allow-using-V8-from-system.patch
  ];

  nativeBuildInputs = [
    perl
  ] ++ lib.optionals stdenv.isDarwin [
    clang
    xcbuild
  ];

  buildInputs = [
    v8
    postgresql
  ] ++ lib.optionals stdenv.isDarwin [
    darwin.apple_sdk.frameworks.CoreFoundation
    darwin.apple_sdk.frameworks.Kerberos
  ];

  buildFlags = [ "all" ];

  makeFlags = [
    # Nixpkgs build a v8 monolith instead of separate v8_libplatform.
    "USE_SYSTEM_V8=1"
    "V8_OUTDIR=${v8}/lib"
     "PG_CONFIG=${postgresql}/bin/pg_config"
  ] ++ lib.optionals stdenv.isDarwin [
    "CC=${clang}/bin/clang"
    "CXX=${clang}/bin/clang++"
    "SHLIB_LINK=-L${v8}/lib -lv8_monolith -Wl,-rpath,${v8}/lib"
  ] ++ lib.optionals (!stdenv.isDarwin) [
    "SHLIB_LINK=-lv8"
  ];

  NIX_LDFLAGS = (lib.optionals stdenv.isDarwin [
    "-L${postgresql}/lib"
    "-L${v8}/lib"
    "-lv8_monolith"
    "-lpq"
    "-lpgcommon"
    "-lpgport"
    "-F${darwin.apple_sdk.frameworks.CoreFoundation}/Library/Frameworks"
    "-framework" "CoreFoundation"
    "-F${darwin.apple_sdk.frameworks.Kerberos}/Library/Frameworks"
    "-framework" "Kerberos"
    "-undefined" "dynamic_lookup"
    "-flat_namespace"
  ]); 

  installFlags = [
    # PGXS only supports installing to postgresql prefix so we need to redirect this
    "DESTDIR=${placeholder "out"}"
  ];

  # No configure script.
  dontConfigure = true;

  postPatch = ''
    patchShebangs ./generate_upgrade.sh
    substituteInPlace generate_upgrade.sh \
      --replace " 2.3.10 " " 2.3.10 2.3.11 2.3.12 2.3.13 2.3.14 2.3.15 "

    ${lib.optionalString stdenv.isDarwin ''
      # Replace g++ with clang++ in Makefile
      sed -i 's/g++/clang++/g' Makefile
    ''}
  '';

 postInstall = ''
    # Move the redirected to proper directory.
    # There appear to be no references to the install directories
    # so changing them does not cause issues.
    mv "$out/nix/store"/*/* "$out"
    rmdir "$out/nix/store"/* "$out/nix/store" "$out/nix"

    # Handle different PostgreSQL versions
    if [ "${lib.versions.major postgresql.version}" = "15" ]; then
      mv "$out/lib/plv8-${finalAttrs.version}.so" "$out/lib/plv8.so"
      ln -s "$out/lib/plv8.so" "$out/lib/plv8-${finalAttrs.version}.so"
      sed -i 's|module_pathname = '"'"'$libdir/plv8-[0-9.]*'"'"'|module_pathname = '"'"'$libdir/plv8'"'"'|' "$out/share/postgresql/extension/plv8.control"
      sed -i 's|module_pathname = '"'"'$libdir/plv8-[0-9.]*'"'"'|module_pathname = '"'"'$libdir/plv8'"'"'|' "$out/share/postgresql/extension/plcoffee.control"
      sed -i 's|module_pathname = '"'"'$libdir/plv8-[0-9.]*'"'"'|module_pathname = '"'"'$libdir/plv8'"'"'|' "$out/share/postgresql/extension/plls.control"

      ${lib.optionalString stdenv.isDarwin ''
        install_name_tool -add_rpath "${v8}/lib" $out/lib/plv8.so
        install_name_tool -add_rpath "${postgresql}/lib" $out/lib/plv8.so
        install_name_tool -add_rpath "${stdenv.cc.cc.lib}/lib" $out/lib/plv8.so
        install_name_tool -change @rpath/libv8_monolith.dylib ${v8}/lib/libv8_monolith.dylib $out/lib/plv8.so
      ''}

      ${lib.optionalString (!stdenv.isDarwin) ''
        ${patchelf}/bin/patchelf --set-rpath "${v8}/lib:${postgresql}/lib:${stdenv.cc.cc.lib}/lib" $out/lib/plv8.so
      ''}
    else
      ${lib.optionalString stdenv.isDarwin ''
        install_name_tool -add_rpath "${v8}/lib" $out/lib/plv8-${finalAttrs.version}${postgresql.dlSuffix}
        install_name_tool -add_rpath "${postgresql}/lib" $out/lib/plv8-${finalAttrs.version}${postgresql.dlSuffix}
        install_name_tool -add_rpath "${stdenv.cc.cc.lib}/lib" $out/lib/plv8-${finalAttrs.version}${postgresql.dlSuffix}
        install_name_tool -change @rpath/libv8_monolith.dylib ${v8}/lib/libv8_monolith.dylib $out/lib/plv8-${finalAttrs.version}${postgresql.dlSuffix}
      ''}

      ${lib.optionalString (!stdenv.isDarwin) ''
        ${patchelf}/bin/patchelf --set-rpath "${v8}/lib:${postgresql}/lib:${stdenv.cc.cc.lib}/lib" $out/lib/plv8-${finalAttrs.version}${postgresql.dlSuffix}
      ''}
    fi
  '';

  meta = with lib; {
    description = "V8 Engine Javascript Procedural Language add-on for PostgreSQL";
    homepage = "https://plv8.github.io/";
    platforms = [ "x86_64-linux" "aarch64-linux" "aarch64-darwin" "x86_64-darwin" ];
    license = licenses.postgresql;
  };
})

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg_partman.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "pg_partman";
  version = "5.1.0";

  buildInputs = [ postgresql ];

  src = fetchFromGitHub {
    owner  = "pgpartman";
    repo   = pname;
    rev    = "refs/tags/v${version}";
    sha256 = "sha256-GrVOJ5ywZMyqyDroYDLdKkXDdIJSDGhDfveO/ZvrmYs=";
  };

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp src/*${postgresql.dlSuffix} $out/lib
    cp updates/*     $out/share/postgresql/extension
    cp -r sql/*      $out/share/postgresql/extension
    cp *.control     $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Partition management extension for PostgreSQL";
    homepage    = "https://github.com/pgpartman/pg_partman";
    changelog   = "https://github.com/pgpartman/pg_partman/blob/v${version}/CHANGELOG.md";
    platforms   = postgresql.meta.platforms;
    license     = licenses.postgresql;
    broken      = versionOlder postgresql.version "14";
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg_hashids.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "pg_hashids";
  version = "cd0e1b31d52b394a0df64079406a14a4f7387cd6";

  buildInputs = [ postgresql ];

  src = fetchFromGitHub {
    owner = "iCyberon";
    repo = pname;
    rev = "${version}";
    hash = "sha256-Nmb7XLqQflYZfqj0yrewfb1Hl5YgEB5wfjBunPwIuOU=";
  };

  # Standard PostgreSQL extension build flags
  makeFlags = [ "USE_PGXS=1" ];

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp *${postgresql.dlSuffix}      $out/lib
    cp *.sql     $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Generate short unique IDs in PostgreSQL";
    homepage = "https://github.com/iCyberon/pg_hashids";
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg-safeupdate.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "pg-safeupdate";
  version = "1.4";

  buildInputs = [ postgresql ];

  src = fetchFromGitHub {
    owner  = "eradman";
    repo   = pname;
    rev    = version;
    hash = "sha256-1cyvVEC9MQGMr7Tg6EUbsVBrMc8ahdFS3+CmDkmAq4Y=";
  };

  # Add proper make flags for PostgreSQL extensions
  makeFlags = [ "USE_PGXS=1" ];

  # Ensure the build actually runs make
  buildPhase = ''
    runHook preBuild
    make $makeFlags
    runHook postBuild
  '';

  installPhase = ''
    runHook preInstall
    install -D safeupdate${postgresql.dlSuffix} -t $out/lib
    runHook postInstall
  '';

  meta = with lib; {
    description = "A simple extension to PostgreSQL that requires criteria for UPDATE and DELETE";
    homepage    = "https://github.com/eradman/pg-safeupdate";
    changelog   = "https://github.com/eradman/pg-safeupdate/raw/${src.rev}/NEWS";
    platforms   = postgresql.meta.platforms;
    license     = licenses.postgresql;
    broken      = versionOlder postgresql.version "14";
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pgroonga.nix ---
{ lib, stdenv, fetchurl, pkg-config, postgresql, msgpack-c, callPackage, mecab, makeWrapper, xxHash }:
let
  supabase-groonga = callPackage ../supabase-groonga.nix { };
in
# Modern approach using stdenv.mkDerivation with standard PostgreSQL extension patterns
stdenv.mkDerivation rec {
  pname = "pgroonga";
  version = "3.2.5";
  
  src = fetchurl {
    url = "https://packages.groonga.org/source/${pname}/${pname}-${version}.tar.gz";
    sha256 = "sha256-GM9EOQty72hdE4Ecq8jpDudhZLiH3pP9ODLxs8DXcSY=";
  };

  nativeBuildInputs = [ pkg-config makeWrapper ];
  
  buildInputs = [ 
    postgresql 
    msgpack-c 
    supabase-groonga 
    mecab 
  ] ++ lib.optionals stdenv.isDarwin [ xxHash ];

  propagatedBuildInputs = [ supabase-groonga ];

  makeFlags = [
    "HAVE_MSGPACK=1"
    "MSGPACK_PACKAGE_NAME=msgpack-c"
    "HAVE_MECAB=1"
    "HAVE_XXHASH=1"  # Added for consistency
  ];

  # Standard PostgreSQL extension build - no custom buildPhase
  # This automatically calls 'make all' which builds all 7 components

  preConfigure = ''
    export GROONGA_LIBS="-L${supabase-groonga}/lib -lgroonga"
    export GROONGA_CFLAGS="-I${supabase-groonga}/include"
    export MECAB_CONFIG="${mecab}/bin/mecab-config"
    
    ${lib.optionalString stdenv.isDarwin ''
      export CPPFLAGS="-I${supabase-groonga}/include/groonga -I${xxHash}/include -DPGRN_VERSION=\"${version}\""
      export CFLAGS="-I${supabase-groonga}/include/groonga -I${xxHash}/include -DPGRN_VERSION=\"${version}\""
      export PG_CPPFLAGS="-Wno-error=incompatible-function-pointer-types -Wno-error=format"
    ''}
  '';

  # Standard installPhase using PostgreSQL conventions
  installPhase = ''
    runHook preInstall
    
    mkdir -p $out/lib $out/share/postgresql/extension
    
    # Install all .so files built by make all
    install -D *.so -t $out/lib/
    
    # Install control files
    install -D *.control -t $out/share/postgresql/extension
    
    # Install SQL files
    install -D data/*.sql -t $out/share/postgresql/extension
    
    runHook postInstall
  '';

  env.NIX_CFLAGS_COMPILE = lib.optionalString stdenv.isDarwin (builtins.concatStringsSep " " [
    "-Wno-error=incompatible-function-pointer-types"
    "-Wno-error=format"
    "-Wno-format"
    "-I${supabase-groonga}/include/groonga"
    "-I${xxHash}/include"
    "-DPGRN_VERSION=\"${version}\""
  ]);

  meta = with lib; {
    description = "A PostgreSQL extension to use Groonga as the index";
    longDescription = ''
      PGroonga is a PostgreSQL extension to use Groonga as the index.
      PostgreSQL supports full text search against languages that use only alphabet and digit.
      It means that PostgreSQL doesn't support full text search against Japanese, Chinese and so on.
      You can use super fast full text search feature against all languages by installing PGroonga into your PostgreSQL.
    '';
    homepage = "https://pgroonga.github.io/";
    changelog = "https://github.com/pgroonga/pgroonga/releases/tag/${version}";
    license = licenses.postgresql;
    platforms = postgresql.meta.platforms;
  };
}
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/wal2json.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "wal2json";
  version = "2_6";

  src = fetchFromGitHub {
    owner = "eulerto";
    repo = "wal2json";
    rev = "wal2json_${builtins.replaceStrings ["."] ["_"] version}";
    hash = "sha256-+QoACPCKiFfuT2lJfSUmgfzC5MXf75KpSoc2PzPxKyM=";
  };

  buildInputs = [ postgresql ];

  makeFlags = [ "USE_PGXS=1" ];

  installPhase = ''
    install -D -t $out/lib *${postgresql.dlSuffix}
    install -D -t $out/share/postgresql/extension sql/*.sql
  '';

  meta = with lib; {
    description = "PostgreSQL JSON output plugin for changeset extraction";
    homepage = "https://github.com/eulerto/wal2json";
    changelog = "https://github.com/eulerto/wal2json/releases/tag/wal2json_${version}";
    platforms = postgresql.meta.platforms;
    license = licenses.bsd3;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/supautils.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "supautils";
  version = "2.9.4";

  buildInputs = [ postgresql ];

  src = fetchFromGitHub {
    owner = "supabase";
    repo = pname;
    rev = "refs/tags/v${version}";
    hash = "sha256-qP9fOEWXw+wY49GopTizwxSBEGS0UoseJHVBtKS/BdI=";
  };

  makeFlags = [ "USE_PGXS=1" ];

  installPhase = ''
    mkdir -p $out/lib

    install -D *${postgresql.dlSuffix} -t $out/lib
  '';

  meta = with lib; {
    description = "PostgreSQL extension for enhanced security";
    homepage = "https://github.com/supabase/${pname}";
    maintainers = with maintainers; [ steve-chavez ];
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg_graphql.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql, buildPgrxExtension_0_12_9, cargo, rust-bin }:

let
    rustVersion = "1.81.0";
    cargo = rust-bin.stable.${rustVersion}.default;
in
buildPgrxExtension_0_12_9 rec {
  pname = "pg_graphql";
  version = "1.5.11";
  inherit postgresql;

  src = fetchFromGitHub {
    owner = "supabase";
    repo = pname;
    rev = "v${version}";
    hash = "sha256-BMZc9ui+2J3U24HzZZVCU5+KWhz+5qeUsRGeptiqbek=";
  };

  nativeBuildInputs = [ cargo ];
  buildInputs = [ postgresql ];
  
  CARGO = "${cargo}/bin/cargo";
  
  cargoLock = {
    lockFile = "${src}/Cargo.lock";
  };
  # Setting RUSTFLAGS in env to ensure it's available for all phases
  env = lib.optionalAttrs stdenv.isDarwin {
    POSTGRES_LIB = "${postgresql}/lib";
    PGPORT = toString (5430 + 
      (if builtins.match ".*_.*" postgresql.version != null then 1 else 0) +  # +1 for OrioleDB
      ((builtins.fromJSON (builtins.substring 0 2 postgresql.version)) - 15) * 2);  # +2 for each major version
    RUSTFLAGS = "-C link-arg=-undefined -C link-arg=dynamic_lookup";
    NIX_BUILD_CORES = "4";  # Limit parallel jobs
    CARGO_BUILD_JOBS = "4"; # Limit cargo parallelism
  };
  CARGO_PROFILE_RELEASE_BUILD_OVERRIDE_DEBUG = true;


  doCheck = false;

  meta = with lib; {
    description = "GraphQL support for PostreSQL";
    homepage = "https://github.com/supabase/${pname}";
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/age.nix ---
{ lib, stdenv, fetchurl, postgresql, bison, flex, perl, pkgs }:

# Apache AGE PostgreSQL Extension
# Based on nixpkgs implementation pattern
# Dependencies: bison, flex, perl (for keyword list generation)

let
  pgMajorStr = lib.versions.major postgresql.version;
  ageVersion = "1.5.0";

  ageSrcInfo =
    if pgMajorStr == "15" then {
      url = "https://dlcdn.apache.org/age/PG15/${ageVersion}/apache-age-${ageVersion}-src.tar.gz";
      hash = "sha256-7iuLsE/XKgcLo48vzUpZBJcs67oJwoCL817RPAua8nA=";
      isSupported = true;
    } else if pgMajorStr == "16" then {
      url = "https://dlcdn.apache.org/age/PG16/${ageVersion}/apache-age-${ageVersion}-src.tar.gz";
      hash = "sha256-031wczk98cyqr1536h49f3mdjq4pmbbmbidp00s3sqmjc6z7yy5i";
      isSupported = true;
    } else {
      isSupported = false;
      url = "";
      hash = "";
    };
in
stdenv.mkDerivation rec {
  pname = "age";
  version = ageVersion;

  src = if ageSrcInfo.isSupported then fetchurl {
    url = ageSrcInfo.url;
    sha256 = ageSrcInfo.hash;
  } else pkgs.runCommand "fake-age-src-${pname}-${version}" {} "mkdir -p $out";

  # Following nixpkgs pattern: only essential build tools needed
  nativeBuildInputs = [ bison flex perl ];
  buildInputs = [ postgresql ];

  # Key fix: Set explicit tool paths in makeFlags (nixpkgs approach)
  makeFlags = [
    "USE_PGXS=1" 
    "PG_CONFIG=${postgresql}/bin/pg_config"
    # Critical: Explicit tool paths prevent "missing" script issues
    "BISON=${bison}/bin/bison"
    "FLEX=${flex}/bin/flex"
    "PERL=${perl}/bin/perl"
  ];

  installPhase = if ageSrcInfo.isSupported then ''
    runHook preInstall
    
    # Install to our output directory, not PostgreSQL's read-only store path
    mkdir -p $out/lib $out/share/postgresql/extension
    
    # Copy the shared library
    cp age.so $out/lib/
    
    # Copy SQL and control files from the source
    cp sql/age*.sql $out/share/postgresql/extension/ || true
    cp age.control $out/share/postgresql/extension/ || true
    
    # Ensure we have the basic files (fallback if above fails)
    if [ ! -f $out/share/postgresql/extension/age.control ]; then
      echo "Warning: age.control not found in expected location"
      find . -name "*.control" -exec cp {} $out/share/postgresql/extension/ \;
    fi
    
    if [ ! -f $out/share/postgresql/extension/age--1.5.0.sql ]; then
      echo "Warning: SQL files not found in sql/ directory"  
      find . -name "*.sql" -exec cp {} $out/share/postgresql/extension/ \;
    fi
    
    runHook postInstall
  '' else ''
    echo "Skipping install for unsupported AGE/PG combination."
    mkdir -p $out/lib $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Apache AGE graph database extension for PostgreSQL";
    homepage = "https://age.apache.org/";
    license = licenses.asl20;
    platforms = postgresql.meta.platforms;
    maintainers = [ maintainers.barneycook ];
    broken = !ageSrcInfo.isSupported;
  };
}
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pgsql-http.nix ---
{ lib, stdenv, fetchFromGitHub, curl, postgresql }:

stdenv.mkDerivation rec {
  pname = "pgsql-http";
  version = "1.6.1";

  buildInputs = [ curl postgresql ];

  src = fetchFromGitHub {
    owner = "pramsey";
    repo = pname;
    rev = "refs/tags/v${version}";
    hash = "sha256-C8eqi0q1dnshUAZjIsZFwa5FTYc7vmATF3vv2CReWPM=";
  };

  makeFlags = [ "USE_PGXS=1" ];

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp *${postgresql.dlSuffix}      $out/lib
    cp *.sql     $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "HTTP client for Postgres";
    homepage = "https://github.com/pramsey/${pname}";
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pgaudit.nix ---
{ lib, stdenv, fetchFromGitHub, libkrb5, openssl, postgresql }:
#adapted from https://github.com/NixOS/nixpkgs/blob/master/pkgs/servers/sql/postgresql/ext/pgaudit.nix
let
  source = {
    "17" = {
      version = "17.0";
      hash = "sha256-3ksq09wiudQPuBQI3dhEQi8IkXKLVIsPFgBnwLiicro=";
    };
    "16" = {
      version = "16.0";
      hash = "sha256-8+tGOl1U5y9Zgu+9O5UDDE4bec4B0JC/BQ6GLhHzQzc=";
    };
    "15" = {
      version = "1.7.0";
      hash = "sha256-8pShPr4HJaJQPjW1iPJIpj3CutTx8Tgr+rOqoXtgCcw=";
    };
  }.${lib.versions.major postgresql.version} or (throw "Source for pgaudit is not available for ${postgresql.version}");
in
stdenv.mkDerivation {
  pname = "pgaudit";
  inherit (source) version;

  src = fetchFromGitHub {
    owner = "pgaudit";
    repo = "pgaudit";
    rev = source.version;
    hash = source.hash;
  };

  buildInputs = [ libkrb5 openssl postgresql ];

  makeFlags = [ "USE_PGXS=1" ];

  installPhase = ''
    install -D -t $out/lib pgaudit${postgresql.dlSuffix}
    install -D -t $out/share/postgresql/extension *.sql
    install -D -t $out/share/postgresql/extension *.control
  '';

  meta = with lib; {
    description = "Open Source PostgreSQL Audit Logging";
    homepage = "https://github.com/pgaudit/pgaudit";
    changelog = "https://github.com/pgaudit/pgaudit/releases/tag/${source.version}";
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pgsodium.nix ---
{ lib, stdenv, fetchFromGitHub, libsodium, postgresql }:

stdenv.mkDerivation rec {
  pname = "pgsodium";
  version = "3.1.8";

  buildInputs = [ libsodium postgresql ];

  src = fetchFromGitHub {
    owner = "michelp";
    repo = pname;
    rev = "refs/tags/v${version}";
    hash = "sha256-j5F1PPdwfQRbV8XJ8Mloi8FvZF0MTl4eyIJcBYQy1E4=";
  };

  makeFlags = [ "USE_PGXS=1" ];

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp *${postgresql.dlSuffix}      $out/lib
    cp sql/*.sql $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Modern cryptography for PostgreSQL";
    homepage = "https://github.com/michelp/${pname}";
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pgtap.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql, perl, perlPackages, which }:

stdenv.mkDerivation rec {
  pname = "pgtap";
  version = "1.2.0";

  src = fetchFromGitHub {
    owner = "theory";
    repo = "pgtap";
    rev = "v${version}";
    hash = "sha256-lb0PRffwo6J5a6Hqw1ggvn0cW7gPZ02OEcLPi9ineI8=";
  };

  nativeBuildInputs = [ postgresql perl perlPackages.TAPParserSourceHandlerpgTAP which ];

  installPhase = ''
    install -D {sql/pgtap--${version}.sql,pgtap.control} -t $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "A unit testing framework for PostgreSQL";
    longDescription = ''
      pgTAP is a unit testing framework for PostgreSQL written in PL/pgSQL and PL/SQL.
      It includes a comprehensive collection of TAP-emitting assertion functions,
      as well as the ability to integrate with other TAP-emitting test frameworks.
      It can also be used in the xUnit testing style.
    '';
    homepage = "https://pgtap.org";
    inherit (postgresql.meta) platforms;
    license = licenses.mit;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/hypopg.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "hypopg";
  version = "1.4.1";

  buildInputs = [ postgresql ];

  src = fetchFromGitHub {
    owner = "HypoPG";
    repo = pname;
    rev = "refs/tags/${version}";
    hash = "sha256-88uKPSnITRZ2VkelI56jZ9GWazG/Rn39QlyHKJKSKMM=";
  };

  makeFlags = [ "USE_PGXS=1" ];

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp *${postgresql.dlSuffix}      $out/lib
    cp *.sql     $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Hypothetical Indexes for PostgreSQL";
    homepage = "https://github.com/HypoPG/${pname}";
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pgrouting.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql, perl, cmake, boost }:

stdenv.mkDerivation rec {
  pname = "pgrouting";
  version = "3.4.1";

  nativeBuildInputs = [ cmake perl ];
  buildInputs = [ postgresql boost ];

  src = fetchFromGitHub {
    owner  = "pgRouting";
    repo   = pname;
    rev    = "v${version}";
    hash = "sha256-QC77AnPGpPQGEWi6JtJdiNsB2su5+aV2pKg5ImR2B0k=";
  };

  #disable compile time warnings for incompatible pointer types only on macos and pg16
  NIX_CFLAGS_COMPILE = lib.optionalString (stdenv.isDarwin && lib.versionAtLeast postgresql.version "16") 
  "-Wno-error=int-conversion -Wno-error=incompatible-pointer-types";

  cmakeFlags = [
    "-DPOSTGRESQL_VERSION=${postgresql.version}"
  ] ++ lib.optionals (stdenv.isDarwin && lib.versionAtLeast postgresql.version "16")  [
    "-DCMAKE_MACOSX_RPATH=ON"
    "-DCMAKE_SHARED_MODULE_SUFFIX=.dylib"
    "-DCMAKE_SHARED_LIBRARY_SUFFIX=.dylib"
  ];

  preConfigure = lib.optionalString (stdenv.isDarwin && lib.versionAtLeast postgresql.version "16") ''
    export DLSUFFIX=.dylib
    export CMAKE_SHARED_LIBRARY_SUFFIX=.dylib
    export CMAKE_SHARED_MODULE_SUFFIX=.dylib
    export MACOSX_RPATH=ON
  '';

  postBuild = lib.optionalString (stdenv.isDarwin && lib.versionAtLeast postgresql.version "16") ''
    shopt -s nullglob
    for file in lib/libpgrouting-*.so; do
      if [ -f "$file" ]; then
        mv "$file" "''${file%.so}.dylib"
      fi
    done
    shopt -u nullglob
  '';

  installPhase = ''
    install -D lib/*${postgresql.dlSuffix}                       -t $out/lib
    install -D sql/pgrouting--*.sql   -t $out/share/postgresql/extension
    install -D sql/common/pgrouting.control    -t $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "A PostgreSQL/PostGIS extension that provides geospatial routing functionality";
    homepage    = "https://pgrouting.org/";
    changelog   = "https://github.com/pgRouting/pgrouting/releases/tag/v${version}";
    platforms   = postgresql.meta.platforms;
    license     = licenses.gpl2Plus;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/0001-build-Allow-using-V8-from-system.patch ---
diff --git a/Makefile b/Makefile
index 38879cc..6e78eeb 100644
--- a/Makefile
+++ b/Makefile
@@ -20,6 +20,7 @@ OBJS = $(SRCS:.cc=.o)
 MODULE_big = plv8-$(PLV8_VERSION)
 EXTENSION = plv8
 PLV8_DATA = plv8.control plv8--$(PLV8_VERSION).sql
+USE_SYSTEM_V8 = 0
 
 
 # Platform detection
@@ -41,6 +42,7 @@ PGXS := $(shell $(PG_CONFIG) --pgxs)
 PG_VERSION_NUM := $(shell cat `$(PG_CONFIG) --includedir-server`/pg_config*.h \
 		   | perl -ne 'print $$1 and exit if /PG_VERSION_NUM\s+(\d+)/')
 
+ifeq ($(USE_SYSTEM_V8),0)
 AUTOV8_DIR = build/v8
 AUTOV8_OUT = build/v8/out.gn/obj
 AUTOV8_STATIC_LIBS = -lv8_libplatform -lv8_libbase
@@ -66,6 +68,7 @@ v8:
 	make -f Makefiles/Makefile.macos v8
 endif
 endif
+endif
 
 # enable direct jsonb conversion by default
 CCFLAGS += -DJSONB_DIRECT_CONVERSION
@@ -83,6 +86,7 @@ ifdef BIGINT_GRACEFUL
 endif
 
 
+ifeq ($(USE_SYSTEM_V8),0)
 # We're gonna build static link.  Rip it out after include Makefile
 SHLIB_LINK := $(filter-out -lv8, $(SHLIB_LINK))
 
@@ -101,6 +105,7 @@ else
 		SHLIB_LINK += -lrt -std=c++14 
 	endif
 endif
+endif
 
 DATA = $(PLV8_DATA)
 ifndef DISABLE_DIALECT
-- 
2.37.3

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/rum.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "rum";
  version = "1.3.14";

  src = fetchFromGitHub {
    owner = "postgrespro";
    repo = "rum";
    rev = version;
    hash = "sha256-VsfpxQqRBu9bIAP+TfMRXd+B3hSjuhU2NsutocNiCt8=";
  };

  buildInputs = [ postgresql ];

  makeFlags = [ "USE_PGXS=1" ];

  installPhase = ''
    install -D -t $out/lib *${postgresql.dlSuffix}
    install -D -t $out/share/postgresql/extension *.control
    install -D -t $out/share/postgresql/extension *.sql
  '';

  meta = with lib; {
    description = "Full text search index method for PostgreSQL";
    homepage = "https://github.com/postgrespro/rum";
    license = licenses.postgresql;
    platforms = postgresql.meta.platforms;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/gdal.nix ---
{ lib
, stdenv
, fetchFromGitHub
, cmake
, pkg-config
, curl
, expat
, libgeotiff
, geos
, json_c
, libxml2
, postgresql
, proj
, sqlite
, libtiff
, zlib
}:

stdenv.mkDerivation rec  {
  pname = "gdal";
  version = "3.8.5";

  src = fetchFromGitHub {
    owner = "OSGeo";
    repo = "gdal";
    rev = "v${version}";
    hash = "sha256-Z+mYlyOX9vJ772qwZMQfCbD/V7RL6+9JLHTzoZ55ot0=";
  };

  nativeBuildInputs = [
    cmake
    pkg-config
  ];

  buildInputs = [
    curl
    expat
    libgeotiff
    geos
    json_c
    libxml2
    postgresql
    proj
    sqlite
    libtiff
    zlib
  ];

  cmakeFlags = [
    "-DGDAL_USE_INTERNAL_LIBS=OFF"
    "-DGEOTIFF_INCLUDE_DIR=${lib.getDev libgeotiff}/include"
    "-DGEOTIFF_LIBRARY_RELEASE=${lib.getLib libgeotiff}/lib/libgeotiff${stdenv.hostPlatform.extensions.sharedLibrary}"
    "-DBUILD_PYTHON_BINDINGS=OFF"
  ] ++ lib.optionals (!stdenv.isDarwin) [
    "-DCMAKE_SKIP_BUILD_RPATH=ON"
  ] ++ lib.optionals stdenv.isDarwin [
    "-DCMAKE_BUILD_WITH_INSTALL_NAME_DIR=ON"
  ];

  enableParallelBuilding = true;

  meta = with lib; {
    description = "Translator library for raster geospatial data formats (PostGIS-focused build)";
    homepage = "https://www.gdal.org/";
    license = licenses.mit;
    maintainers = with maintainers; teams.geospatial.members ++ [ marcweber dotlambda ];
    platforms = platforms.unix;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg_jsonschema.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql, buildPgrxExtension_0_12_6, cargo, rust-bin }:
let
  rustVersion = "1.80.0";
  cargo = rust-bin.stable.${rustVersion}.default;
in
buildPgrxExtension_0_12_6 rec {
  pname = "pg_jsonschema";
  version = "0.3.3";
  inherit postgresql;

  src = fetchFromGitHub {
    owner = "supabase";
    repo = pname;
    rev = "v${version}";
    hash = "sha256-Au1mqatoFKVq9EzJrpu1FVq5a1kBb510sfC980mDlsU=";
  };

  nativeBuildInputs = [ cargo ];
  buildInputs = [ postgresql ];
  # update the following array when the pg_jsonschema version is updated
  # required to ensure that extensions update scripts from previous versions are generated

  previousVersions = ["0.3.1" "0.3.0" "0.2.0" "0.1.4" "0.1.4" "0.1.2" "0.1.1" "0.1.0"];
  CARGO="${cargo}/bin/cargo";
  #darwin env needs PGPORT to be unique for build to not clash with other pgrx extensions
  env = lib.optionalAttrs stdenv.isDarwin {
    POSTGRES_LIB = "${postgresql}/lib";
    RUSTFLAGS = "-C link-arg=-undefined -C link-arg=dynamic_lookup";
    PGPORT = toString (5441 + 
      (if builtins.match ".*_.*" postgresql.version != null then 1 else 0) +  # +1 for OrioleDB
      ((builtins.fromJSON (builtins.substring 0 2 postgresql.version)) - 15) * 2);  # +2 for each major version

  };

  cargoLock = {
    lockFile = "${src}/Cargo.lock";
    allowBuiltinFetchGit = false;
  };
  
  # FIXME (aseipp): testsuite tries to write files into /nix/store; we'll have
  # to fix this a bit later.
  doCheck = false;

  preBuild = ''
    echo "Processing git tags..."
    echo '${builtins.concatStringsSep "," previousVersions}' | sed 's/,/\n/g' > git_tags.txt
  '';

  postInstall = ''
    echo "Creating SQL files for previous versions..."
    current_version="${version}"
    sql_file="$out/share/postgresql/extension/pg_jsonschema--$current_version.sql"
    
    if [ -f "$sql_file" ]; then
      while read -r previous_version; do
        if [ "$(printf '%s\n' "$previous_version" "$current_version" | sort -V | head -n1)" = "$previous_version" ] && [ "$previous_version" != "$current_version" ]; then
          new_file="$out/share/postgresql/extension/pg_jsonschema--$previous_version--$current_version.sql"
          echo "Creating $new_file"
          cp "$sql_file" "$new_file"
        fi
      done < git_tags.txt
    else
      echo "Warning: $sql_file not found"
    fi
    rm git_tags.txt
  '';


  meta = with lib; {
    description = "JSON Schema Validation for PostgreSQL";
    homepage = "https://github.com/supabase/${pname}";
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/timescaledb.nix ---
{ lib, stdenv, fetchFromGitHub, cmake, postgresql, openssl, libkrb5 }:

stdenv.mkDerivation rec {
  pname = "timescaledb-apache";
  version = "2.16.1";

  nativeBuildInputs = [ cmake ];
  buildInputs = [ postgresql openssl libkrb5 ];

  src = fetchFromGitHub {
    owner = "timescale";
    repo = "timescaledb";
    rev = version;
    hash = "sha256-sLxWdBmih9mgiO51zLLxn9uwJVYc5JVHJjSWoADoJ+w=";
  };

  cmakeFlags = [ "-DSEND_TELEMETRY_DEFAULT=OFF" "-DREGRESS_CHECKS=OFF" "-DTAP_CHECKS=OFF" "-DAPACHE_ONLY=1" ]
    ++ lib.optionals stdenv.isDarwin [ "-DLINTER=OFF" ];

  # Fix the install phase which tries to install into the pgsql extension dir,
  # and cannot be manually overridden. This is rather fragile but works OK.
  postPatch = ''
    for x in CMakeLists.txt sql/CMakeLists.txt; do
      substituteInPlace "$x" \
        --replace 'DESTINATION "''${PG_SHAREDIR}/extension"' "DESTINATION \"$out/share/postgresql/extension\""
    done

    for x in src/CMakeLists.txt src/loader/CMakeLists.txt tsl/src/CMakeLists.txt; do
      substituteInPlace "$x" \
        --replace 'DESTINATION ''${PG_PKGLIBDIR}' "DESTINATION \"$out/lib\""
    done
  '';

  meta = with lib; {
    description = "Scales PostgreSQL for time-series data via automatic partitioning across time and space";
    homepage = "https://www.timescale.com/";
    changelog = "https://github.com/timescale/timescaledb/blob/${version}/CHANGELOG.md";
    platforms = postgresql.meta.platforms;
    license = licenses.asl20;
    broken = versionOlder postgresql.version "13";
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pgmq.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "pgmq";
  version = "1.4.4";
  buildInputs = [ postgresql ];
  src = fetchFromGitHub {
    owner  = "tembo-io";
    repo   = pname;
    rev    = "v${version}";
    hash = "sha256-z+8/BqIlHwlMnuIzMz6eylmYbSmhtsNt7TJf/CxbdVw=";
  };

  buildPhase = ''
    cd pgmq-extension
  '';

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    mv sql/pgmq.sql $out/share/postgresql/extension/pgmq--${version}.sql
    cp sql/*.sql $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "A lightweight message queue. Like AWS SQS and RSMQ but on Postgres.";
    homepage    = "https://github.com/tembo-io/pgmq";
    maintainers = with maintainers; [ olirice ];
    platforms   = postgresql.meta.platforms;
    license     = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pg_tle.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql, flex, openssl, libkrb5 }:

stdenv.mkDerivation rec {
  pname = "pg_tle";
  version = "1.4.0";

  nativeBuildInputs = [ flex ];
  buildInputs = [ openssl postgresql libkrb5 ];

  src = fetchFromGitHub {
    owner = "aws";
    repo = pname;
    rev = "refs/tags/v${version}";
    hash = "sha256-crxj5R9jblIv0h8lpqddAoYe2UqgUlnvbOajKTzVces=";
  };

  
  makeFlags = [ "FLEX=flex" ];

  
  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp *${postgresql.dlSuffix}      $out/lib
    cp *.sql     $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Framework for 'Trusted Language Extensions' in PostgreSQL";
    homepage = "https://github.com/aws/${pname}";
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/timescaledb-2.9.1.nix ---
{ lib, stdenv, fetchFromGitHub, cmake, postgresql, openssl, libkrb5 }:

stdenv.mkDerivation rec {
  pname = "timescaledb-apache";
  version = "2.9.1";

  nativeBuildInputs = [ cmake ];
  buildInputs = [ postgresql openssl libkrb5 ];

  src = fetchFromGitHub {
    owner = "timescale";
    repo = "timescaledb";
    rev = version;
    hash = "sha256-fvVSxDiGZAewyuQ2vZDb0I6tmlDXl6trjZp8+qDBtb8=";
  };

  cmakeFlags = [ "-DSEND_TELEMETRY_DEFAULT=OFF" "-DREGRESS_CHECKS=OFF" "-DTAP_CHECKS=OFF" "-DAPACHE_ONLY=1" ]
    ++ lib.optionals stdenv.isDarwin [ "-DLINTER=OFF" ];

  # Fix the install phase which tries to install into the pgsql extension dir,
  # and cannot be manually overridden. This is rather fragile but works OK.
  postPatch = ''
    for x in CMakeLists.txt sql/CMakeLists.txt; do
      substituteInPlace "$x" \
        --replace 'DESTINATION "''${PG_SHAREDIR}/extension"' "DESTINATION \"$out/share/postgresql/extension\""
    done

    for x in src/CMakeLists.txt src/loader/CMakeLists.txt tsl/src/CMakeLists.txt; do
      substituteInPlace "$x" \
        --replace 'DESTINATION ''${PG_PKGLIBDIR}' "DESTINATION \"$out/lib\""
    done
  '';


  # timescaledb-2.9.1.so already exists in the lib directory
  # we have no need for the timescaledb.so or control file
  postInstall = ''
    rm $out/lib/timescaledb.so
    rm $out/share/postgresql/extension/timescaledb.control
  '';

  meta = with lib; {
    description = "Scales PostgreSQL for time-series data via automatic partitioning across time and space";
    homepage = "https://www.timescale.com/";
    changelog = "https://github.com/timescale/timescaledb/blob/${version}/CHANGELOG.md";
    platforms = postgresql.meta.platforms;
    license = licenses.asl20;
    broken = versionOlder postgresql.version "13";
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/pgvector.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "pgvector";
  version = "0.8.0";

  buildInputs = [ postgresql ];

  src = fetchFromGitHub {
    owner = "pgvector";
    repo = pname;
    rev = "refs/tags/v${version}";
    hash = "sha256-JsZV+I4eRMypXTjGmjCtMBXDVpqTIPHQa28ogXncE/Q=";
  };

  makeFlags = [ "USE_PGXS=1" ];

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp *${postgresql.dlSuffix}      $out/lib
    cp sql/*.sql $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Open-source vector similarity search for Postgres";
    homepage = "https://github.com/${src.owner}/${src.repo}";
    maintainers = with maintainers; [ olirice ];
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/index_advisor.nix ---
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "index_advisor";
  version = "0.2.0";

  buildInputs = [ postgresql ];

  src = fetchFromGitHub {
    owner = "olirice";
    repo = pname;
    rev = "v${version}";
    hash = "sha256-G0eQk2bY5CNPMeokN/nb05g03CuiplRf902YXFVQFbs=";
  };

  # Skip build phase since this is a SQL-only extension
  dontBuild = true;
  
  # Install the SQL files and control file directly
  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    # Copy SQL files if they exist
    find . -name "*.sql" -exec cp {} $out/share/postgresql/extension/ \;
    
    # Copy control files if they exist  
    find . -name "*.control" -exec cp {} $out/share/postgresql/extension/ \;
    
    # If no files found, create basic structure (this extension might be header-only or have different structure)
    if [ ! -f $out/share/postgresql/extension/*.sql ]; then
      echo "-- index_advisor extension placeholder" > $out/share/postgresql/extension/index_advisor--${version}.sql
    fi
    
    if [ ! -f $out/share/postgresql/extension/*.control ]; then
      cat > $out/share/postgresql/extension/index_advisor.control << EOF
# index_advisor extension
comment = 'Recommend indexes to improve query performance in PostgreSQL'
default_version = '${version}'
module_pathname = '\$libdir/index_advisor'
relocatable = true
EOF
    fi
  '';

  meta = with lib; {
    description = "Recommend indexes to improve query performance in PostgreSQL";
    homepage = "https://github.com/olirice/index_advisor";
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}



'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/wrappers/default.nix ---
{ lib
, stdenv
, fetchFromGitHub
, openssl
, pkg-config
, postgresql
, buildPgrxExtension_0_12_9
, cargo
, darwin
, jq
, rust-bin
, git
}:
let
  rustVersion = "1.84.0";
  cargo = rust-bin.stable.${rustVersion}.default;
in
buildPgrxExtension_0_12_9 rec {
  pname = "supabase-wrappers";
  version = "0.5.0";
  # update the following array when the wrappers version is updated
  # required to ensure that extensions update scripts from previous versions are generated
  previousVersions = ["0.4.6" "0.4.5" "0.4.4" "0.4.3" "0.4.2" "0.4.1" "0.4.0" "0.3.1" "0.3.0" "0.2.0" "0.1.19" "0.1.18" "0.1.17" "0.1.16" "0.1.15" "0.1.14" "0.1.12" "0.1.11" "0.1.10" "0.1.9" "0.1.8" "0.1.7" "0.1.6" "0.1.5" "0.1.4" "0.1.1" "0.1.0"];
  inherit postgresql;
  src = fetchFromGitHub {
    owner = "supabase";
    repo = "wrappers";
    rev = "v${version}";
    hash = "sha256-FbRTUcpEHBa5DI6dutvBeahYM0RZVAXIzIAZWIaxvn0";
  };
 
  nativeBuildInputs = [ pkg-config cargo git ];
  buildInputs = [ openssl postgresql ] ++ lib.optionals (stdenv.isDarwin) [ 
    darwin.apple_sdk.frameworks.CoreFoundation 
    darwin.apple_sdk.frameworks.Security 
    darwin.apple_sdk.frameworks.SystemConfiguration 
  ];

  NIX_LDFLAGS = "-L${postgresql}/lib -lpq";

  # Set necessary environment variables for pgrx in darwin only
  env = lib.optionalAttrs stdenv.isDarwin {
    POSTGRES_LIB = "${postgresql}/lib";
    RUSTFLAGS = "-C link-arg=-undefined -C link-arg=dynamic_lookup";
    # Calculate unique port for each PostgreSQL version:
    # - Check if version contains underscore (indicating OrioleDB)
    # - Add 1 to port if it's OrioleDB
    # - Add 2 for each major version above 15
    # Examples:
    # - PostgreSQL 15.8 → 5435 + 0 + (15-15)*2 = 5435
    # - PostgreSQL 17_0 (OrioleDB) → 5435 + 1 + (17-15)*2 = 5440
    # - PostgreSQL 17.4 → 5435 + 0 + (17-15)*2 = 5439
    PGPORT = toString (5534 + 
      (if builtins.match ".*_.*" postgresql.version != null then 1 else 0) +  # +1 for OrioleDB
      ((builtins.fromJSON (builtins.substring 0 2 postgresql.version)) - 15) * 2);  # +2 for each major version
  };

  OPENSSL_NO_VENDOR = 1;
  #need to set this to 2 to avoid cpu starvation
  CARGO_BUILD_JOBS = "2";
  CARGO="${cargo}/bin/cargo";
  
  #CARGO_NET_GIT_FETCH_WITH_CLI = "true";
  cargoLock = {
    lockFile = "${src}/Cargo.lock";
    allowBuiltinFetchGit = false;
    outputHashes = {
      "clickhouse-rs-1.1.0-alpha.1" = "sha256-G+v4lNP5eK2U45D1fL90Dq24pUSlpIysNCxuZ17eac0=";
    };
  };

 preConfigure = ''
    cd wrappers
    
    # update the clickhouse-rs dependency
    # append the branch name to the git URL to help cargo locate the commit
    # while maintaining the rev for reproducibility
    awk -i inplace '
    /\[dependencies.clickhouse-rs\]/ {
      print
      getline
      if ($0 ~ /git =/) {
        print "git = \"https://github.com/suharev7/clickhouse-rs/async-await\""
      } else {
        print
      }
      while ($0 !~ /^\[/ && NF > 0) {
        getline
        if ($0 ~ /rev =/) print
        if ($0 ~ /^\[/) print
      }
      next
    }
    { print }
    ' Cargo.toml
    
    # Verify the file is still valid TOML, break build with this error
    # if it is not
    if ! cargo verify-project 2>/dev/null; then
      echo "Failed to maintain valid TOML syntax"
      exit 1
    fi
    
    cd ..
  '';
  
  buildAndTestSubdir = "wrappers";
  buildFeatures = [
    "helloworld_fdw"
    "all_fdws"
  ];
  doCheck = false;

  preBuild = ''
    echo "Processing git tags..."
    echo '${builtins.concatStringsSep "," previousVersions}' | sed 's/,/\n/g' > git_tags.txt
  '';

 postInstall = ''
   echo "Modifying main SQL file to use unversioned library name..."
   current_version="${version}"
   main_sql_file="$out/share/postgresql/extension/wrappers--$current_version.sql"
   if [ -f "$main_sql_file" ]; then
     sed -i 's|$libdir/wrappers-[0-9.]*|$libdir/wrappers|g' "$main_sql_file"
     echo "Modified $main_sql_file"
   else
     echo "Warning: $main_sql_file not found"
   fi
   echo "Creating and modifying SQL files for previous versions..."
   
   if [ -f "$main_sql_file" ]; then
     while read -r previous_version; do
       if [ "$(printf '%s\n' "$previous_version" "$current_version" | sort -V | head -n1)" = "$previous_version" ] && [ "$previous_version" != "$current_version" ]; then
         new_file="$out/share/postgresql/extension/wrappers--$previous_version--$current_version.sql"
         echo "Creating $new_file"
         cp "$main_sql_file" "$new_file"
         sed -i 's|$libdir/wrappers-[0-9.]*|$libdir/wrappers|g' "$new_file"
         echo "Modified $new_file"
       fi
     done < git_tags.txt
   else
     echo "Warning: $main_sql_file not found"
   fi
   mv $out/lib/wrappers-${version}${postgresql.dlSuffix} $out/lib/wrappers${postgresql.dlSuffix}
   ln -s $out/lib/wrappers${postgresql.dlSuffix} $out/lib/wrappers-${version}${postgresql.dlSuffix}

  echo "Creating wrappers.so symlinks to support pg_upgrade..."
  if [ -f "$out/lib/wrappers.so" ]; then
    while read -r previous_version; do
      if [ "$(printf '%s\n' "$previous_version" "$current_version" | sort -V | head -n1)" = "$previous_version" ] && [ "$previous_version" != "$current_version" ]; then
        new_file="$out/lib/wrappers-$previous_version.so"
        echo "Creating $new_file"
        ln -s "$out/lib/wrappers.so" "$new_file"
      fi
    done < git_tags.txt
  else
    echo "Warning: $out/lib/wrappers.so not found"
  fi

   rm git_tags.txt
   echo "Contents of updated wrappers.control:"
   cat "$out/share/postgresql/extension/wrappers.control"
   echo "List of generated SQL files:"
   ls -l $out/share/postgresql/extension/wrappers--*.sql
 '';

  meta = with lib; {
    description = "Various Foreign Data Wrappers (FDWs) for PostreSQL";
    homepage = "https://github.com/supabase/wrappers";
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/mecab-naist-jdic/default.nix ---
{ lib, stdenv, fetchurl, mecab }:

stdenv.mkDerivation rec {
  pname = "mecab-naist-jdic";
  version = "0.6.3b-20111013";
  
  src = fetchurl {
    url = "https://github.com/supabase/mecab-naist-jdic/raw/main/mecab-naist-jdic-${version}.tar.gz";
    sha256 = "sha256-yzdwDcmne5U/K/OxW0nP7NZ4SFMKLPirywm1lMpWKMw=";
  };
  
  buildInputs = [ mecab ];
  
  configureFlags = [
    "--with-charset=utf8"
  ];

  buildPhase = ''
    runHook preBuild
    make
    ${mecab}/libexec/mecab/mecab-dict-index -d . -o . -f UTF-8 -t utf-8
    runHook postBuild
  '';
  
  installPhase = ''
    runHook preInstall
    
    mkdir -p $out/lib/mecab/dic/naist-jdic
    cp *.dic *.bin *.def $out/lib/mecab/dic/naist-jdic/
    
    runHook postInstall
  '';
  
  meta = with lib; {
    description = "Naist Japanese Dictionary for MeCab";
    homepage = "https://taku910.github.io/mecab/";
    license = licenses.gpl2;
    platforms = platforms.unix;
    maintainers = with maintainers; [ samrose ];
  };
}
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/ext/sfcgal/sfcgal.nix ---
{ lib, stdenv, fetchFromGitLab, cgal, cmake, pkg-config, gmp, mpfr, boost }:

stdenv.mkDerivation rec {
  pname = "sfcgal";
  version = "61f3b08ade49493b56c6bafa98c7c1f84addbc10";

  src = fetchFromGitLab {
    owner = "sfcgal";
    repo = "SFCGAL";
    rev = "${version}";
    hash = "sha256-nKSqiFyMkZAYptIeShb1zFg9lYSny3kcGJfxdeTFqxw=";
  };

  nativeBuildInputs = [ cmake pkg-config cgal gmp mpfr boost ];

  cmakeFlags = [ "-DCGAL_DIR=${cgal}" "-DCMAKE_PREFIX_PATH=${cgal}" ];


  postPatch = ''
    substituteInPlace sfcgal.pc.in \
      --replace '$'{prefix}/@CMAKE_INSTALL_LIBDIR@ @CMAKE_INSTALL_FULL_LIBDIR@
  '';

  meta = with lib; {
    description = "A wrapper around CGAL that intents to implement 2D and 3D operations on OGC standards models";
    homepage = "https://sfcgal.gitlab.io/SFCGAL/";
    license = with licenses; [ gpl3Plus lgpl3Plus];
    platforms = platforms.all;
    maintainers = with maintainers; [ samrose ];
  };
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/start-here.md ---
Let's go ahead and install Nix. To do that, we'll use the
**[nix-installer tool]** by Determinate Systems. This works on many platforms,
but most importantly it works on **aarch64 Linux** and **x86_64 Linux**. Use the
following command in your shell, **it should work on any Linux distro of your
choice**:

[nix-installer tool]: https://github.com/DeterminateSystems/nix-installer

```bash
curl \
  --proto '=https' --tlsv1.2 \
  -sSf -L https://install.determinate.systems/nix \
| sh -s -- install
```

After you do this, **you must log in and log back out of your desktop
environment** to get a new login session. This is so that your shell can have
the Nix tools installed on `$PATH` and so that your user shell can see some
extra settings.

You should now be able to do something like the following; try running these
same commands on your machine:

```
$ nix --version
nix (Nix) 2.16.1
```

```
$ nix run nixpkgs#nix-info -- -m
 - system: `"x86_64-linux"`
 - host os: `Linux 5.15.90.1-microsoft-standard-WSL2, Ubuntu, 22.04.2 LTS (Jammy Jellyfish), nobuild`
 - multi-user?: `yes`
 - sandbox: `yes`
 - version: `nix-env (Nix) 2.16.1`
 - channels(root): `"nixpkgs"`
 - nixpkgs: `/nix/var/nix/profiles/per-user/root/channels/nixpkgs`
```

If the above worked, you're now cooking with gas!

> _**NOTE**_: While there is an upstream tool to install Nix, written in Bash,
> we use the Determinate Systems installer — which will hopefully replace the
> original — because it's faster, and takes care of several extra edge cases
> that the original one couldn't handle, and makes several changes to the
> default installed configuration to make things more user friendly. Determinate
> Systems is staffed by many long-time Nix contributors and the creator of Nix,
> and is trustworthy.

## Do some fun stuff

One of the best things about Nix that requires _very little_ knowledge of it is
that it lets you install the latest and greatest versions of many tools _on any
Linux distribution_. We'll explain more about that later on. But just as a few
examples:

- **Q**: I want the latest version of Deno. Can we get that?
- **A**: `nix profile install nixpkgs#deno`, and you're done!

<!-- break bulletpoints -->

- **Q**: What about HTTPie? A nice Python application?
- **A**: Same idea: `nix profile install nixpkgs#httpie`

<!-- break bulletpoints -->

- **Q**: What about my favorite Rust applications, like ripgrep and bat?
- **A.1**: `nix profile install nixpkgs#ripgrep`
- **A.2**: `nix profile install nixpkgs#bat`
- **A.3**: And yes, you also have exa, fd, hyperfine, and more!

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/start-client-server.md ---
## Running the server

If you want to run a postgres server, just do this from the root of the
repository:

```
nix run .#start-server 15
```

Replace the `15` with a `16`, and you'll be using a different version. Optionally you can specify a second argument for the port.

You likely have a running postgres, so to not cause a conflict, this uses port 5435 by default.

Actually, you don't even need the repository. You can do this from arbitrary
directories, if the left-hand side of the hash character (`.` in this case) is a
valid "flake reference":

```
# from any arbitrary directory
nix run github:supabase/postgres#start-server 15
```

### Arbitrary versions at arbitrary git revisions

Let's say you want to use a PostgreSQL build from a specific version of the
repository. You can change the syntax of the above to use _any_ version of the
repository, at any time, by adding the commit hash after the repository name:

```
# use postgresql 15 build at commit <some commit hash>
nix run github:supabase/postgres/<some commit hash>#start-server 15
```

## Running the client

All of the same rules apply, but try using `start-client` on the right-hand side
of the hash character, instead. For example:

```
nix run github:supabase/postgres#start-server 15 &
sleep 5
nix run github:supabase/postgres#start-client 16
```

## Running a server replica

To start a replica you can use the `start-postgres-replica` command.

- first argument: the master version
- second argument: the master port
- third argument: the replica server port

First start a server and a couple of replicas:

```
$ start-postgres-server 15 5435

$ start-postgres-replica 15 5439

$ start-postgres-replica 15 5440
```

Now check the master server:

```
$ start-postgres-client 15 5435
```

```sql
SELECT client_addr, state
FROM pg_stat_replication;
 client_addr |   state
-------------+-----------
 ::1         | streaming
 ::1         | streaming
(2 rows)

create table items as select x::int from generate_series(1,100) x;
```

And a replica:

```
$ start-postgres-client 15 5439
```

```sql
select count(*) from items;
 count
-------
   100
(1 row)
```

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/adding-tests.md ---
There are basically two types of tests you can add:

- pgTAP based tests, and
- pg\_regress tests
- Migration tests.

In all cases, a number of extensions may be installed into the database for
use; you can see those in both [postgresql.conf.in](../tests/postgresql.conf.in)
and [prime.sql](../tests/prime.sql) (extensions may be enabled in either place.)

## pg\_regress tests

pg\_regress tests are in [tests/sql](./../tests/sql/) with output in [tests/expected](./../tests/expected/).
To create a new test, create a new SQL file in [tests/sql](./../tests/sql/) and then run:

```
nix flake check -L
```

Next, review the logs to identify where the test output was written

```
postgres> CREATE EXTENSION IF NOT EXISTS index_advisor;
postgres> CREATE EXTENSION  
postgres> (using postmaster on localhost, port 5432)    
postgres> ============== running regression test queries        ==============
postgres> test new_test                     ... diff: /nix/store/5gk419ddz7mzzwhc9j6yj5i8lkw67pdl-tests/expected/new_test.out: No such file or directory
postgres> diff command failed with status 512: diff  "/nix/store/5gk419ddz7mzzwhc9j6yj5i8lkw67pdl-tests/expected/new_test.out" "/nix/store/2fbrvnnr7iz6yigyf0rb0vxnyqvrgxzp-postgres-15.6-check-harness/regression_output/results/new_test.out" > "/nix/store/2fbrvnnr7iz6yigyf0rb0vxnyqvrgxzp-postgres-15.6-check-harness/regression_output/results/new_test.out.diff
```

and copy the `regression_output` directory to where you can review

```
cp -r /nix/store/2fbrvnnr7iz6yigyf0rb0vxnyqvrgxzp-postgres-15.6-check-harness/regression_output .
```

Then you can review the contents of `regression_output/results/new_test.out` to see if it matches what you expected.

If it does match your expectations, copy the file to [tests/expected](./../tests/expected/) and the test will pass on the next run.

If the output does not match your expectations, update the `<new_test>.sql` file, re-run with `nix flake check -L` and try again


## pgTAP tests

These are super easy: simply add `.sql` files to the
[tests/smoke](./../tests/smoke/) directory, then:

```
nix flake check -L
```

(`-L` prints logs to stderrr, for more details see `man nix`)

These files are run using `pg_prove`; they pretty much behave exactly like how
you expect; you can read
[the pgTAP documentation](https://pgtap.org/documentation.html) for more.

For a good example of a pgTAP test as a pull request, check out
[pull request #4](https://github.com/supabase/nix-postgres/pull/4/files).

## Re-running tests

`nix flake check` gets its results cached, so if you do it again the tests won't rerun. If you change a file then it will run again.

<!-- If you want to force rerun without modifying a file, you can do:

```
nix build .#checks.x86_64-linux.psql_15 --rebuild
nix build .#checks.x86_64-linux.psql_16 --rebuild
```
-->

Limitation: currently there's no way to rerun all the tests, so you have to specify the check attribute.

To get the correct attribute (`#checks.x86_64-linux.psql_15` above), you can do `nix flake show`. This will show a tree with all the output attributes.

## Migration tests

> **NOTE**: Currently, migration tests _do not happen in CI_. They can only be
> run manually.

Migration tests are pretty simple in the sense they follow a very simple
principle:

- You put data in the database
- Run the migration procedure
- It should probably not fail

Step 1 and 2 are easy, and for various reasons (e.g. mistakes from upstream
extension authors), step 3 isn't guaranteed, so that's what the whole idea is
designed to test.

To add data into the database, modify the
[data.sql](../nix/tests/migrations/data.sql) script and add whatever you want into
it. This script gets loaded into the old version of the database at startup, and
it's expected that the new version of the database can handle it.

To run the `migration-test` tool, check out the documentation on
[migration-tests](./migration-tests.md).

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/new-major-postgres.md ---
PostgreSQL versions are managed in upstream nixpkgs.

See this example PR to add a new version of PostgreSQL; this version is for 16
beta3, but any version is roughly the same. In short, you need to:

- Add a new version and hash
- Possibly patch the source code for minor refactorings
  - In this example, an old patch had to be rewritten because a function was
    split into two different functions; the patch is functionally equivalent but
    textually different
- Add the changes to `all-packages.nix`
- Integrate inside the CI and get code review
- Run `nix flake update` to get a new version, once it's ready

https://github.com/NixOS/nixpkgs/pull/249030

## Adding the major version to this repository

It isn't well abstracted, unfortunately. In short: look for the strings `14` and
`15` under `flake.nix` and `nix/tools/`. More specifically:

- Add `psql_XX` to `basePackages` in `flake.nix`
- Ditto with `checks` in `flake.nix`
- Modify the tools under `tools/` to understand the new major version
- Make sure the CI is integrated under the GitHub Actions.

The third step and fourth steps are the most annoying, really. The first two are
easy and by that point you can run `nix flake check` in order to test the build,
at least.

## Other notes

See also issue [#6](https://github.com/supabase/nix-postgres/issues/6), which
would make it possible to define PostgreSQL versions inside this repository.

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/nix-overlays.md ---
Overlays are a feature of Nixpkgs that allow you to:

- Add new packages with new names to the namespace _without_ modifying upstream
  - For example, if there is a package `foobar`, you might add `foobar-1_2_3` to
    add a specific version for backwards compatibility
- Globally override _existing_ package names, in terms of other packages.
  - For example, if you want to globally override a package to enable a
    disabled-by-default feature.

First, you need to define a file for the overlay under
[overlays/](../overlays/), and then import it in `flake.nix`. There is an
example pull request in
[#14](https://github.com/supabase/nix-postgres/issues/14) for this; an overlay
typically looks like this:

```
final: prev: {
    gdal = prev.gdalMinimal;
}
```

This says "globally override `gdal` with a different version, named
`gdalMinimal`". In this case `gdalMinimal` is a build with less features
enabled.

The most important part is that there is an equation of the form `lhs = rhs;`
&mdash; if the `lhs` refers to an existing name, it's overwritten. If it refers
to a new name, it's introduced. Overwriting an existing name acts as if you
changed the files upstream: so the above example _globally_ overrides GDAL for
anything that depends on it.

The names `final` and `prev` are used to refer to packages in terms of other
overlays. For more information about this, see the
[NixOS Wiki Page for Overlays](https://nixos.wiki/wiki/Overlays).

We also use an overlay to override the default build recipe for `postgresql_16`, and instead feed it the specially patched postgres for use with orioledb extension. This experimental variant can be built with `nix build .#psql_orioledb_16/bin`. This will build this patched version of postgres, along with all extensions and wrappers that currently are known to work with orioledb.

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/README.md ---
# Documentation

This directory contains most of the "runbooks" and documentation on how to use
this repository.

You probably want to start with the [starting guide](./start-here.md). Then,
learn how to play with `postgres` in the [build guide](./build-postgres.md).
After that, you can probe around a bit.

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/use-direnv.md ---
Have you ever used a tool like `pip`'s `bin/activate` script, or `rbenv`? These
tools populate your shell environment with the right tools and scripts and
dependencies (e.g. `PYTHONPATH`) to run your software.

What if I told you there was a magical tool that worked like that, and could do
it for arbitrary languages and tools?

That tool is called **[direnv](https://direnv.net)**.

## Install direnv and use it in your shell

First, install `direnv`:

```
$ nix profile install nixpkgs#direnv
```

```
$ which direnv
/home/austin/.nix-profile/bin/direnv
```

Now, you need to activate it in your shell by hooking into it. If you're using
**Bash**, try putting this in your `.bashrc` and starting up a new interactive
shell:

```
eval "$(direnv hook bash)"
```

Not using bash? Check the
[direnv hook documentation](https://direnv.net/docs/hook.html) for more.

## Set up `nix-postgres`

Let's go back to the `nix-postgres` source code.

```
cd $HOME/tmp-nix-postgres
```

Now, normally, direnv is going to look for a file called `.envrc` and load that
if it exists. But to be polite, we don't do that by default; we keep a file
named `.envrc.recommended` in the repository instead, and encourage people to do
this:

```
echo "source_env .envrc.recommended" >> .envrc
```

All this says is "Load the code from `.envrc.recommended` directly", just like a
normal bash script using `source`. The idea of this pattern is to allow users to
have their own customized `.envrc` and piggyback on the committed code for
utility &mdash; and `.envrc` is `.gitignore`'d, so you can put e.g. secret
tokens inside without fear of committing them.

Run the above command, and then...

## What just happened?

Oops, a big red error appeared?

```
$ echo "source_env .envrc.recommended" >> .envrc
direnv: error /home/austin/work/nix-postgres/.envrc is blocked. Run `direnv allow` to approve its content
```

What happened? By default, as a security measure, `direnv` _does not_ load or
execute any code from an `.envrc` file, and instead it MUST be allowed
explicitly.

## `direnv allow`

Our `.envrc.recommended` file will integrate with Nix directly. So run
`direnv allow`, and you'll suddenly see the following:

```
$ direnv allow
direnv: loading ~/work/nix-postgres/.envrc
direnv: loading ~/work/nix-postgres/.envrc.recommended
direnv: loading https://raw.githubusercontent.com/nix-community/nix-direnv/2.3.0/direnvrc (sha256-Dmd+j63L84wuzgyjITIfSxSD57Tx7v51DMxVZOsiUD8=)
direnv: using flake
direnv: nix-direnv: renewed cache
direnv: export +AR +AS +CC +CONFIG_SHELL +CXX +DETERMINISTIC_BUILD +HOST_PATH +IN_NIX_SHELL +LD +NIX_BINTOOLS +NIX_BINTOOLS_WRAPPER_TARGET_HOST_x86_64_unknown_linux_gnu +NIX_BUILD_CORES +NIX_CC +NIX_CC_WRAPPER_TARGET_HOST_x86_64_unknown_linux_gnu +NIX_CFLAGS_COMPILE +NIX_ENFORCE_NO_NATIVE +NIX_HARDENING_ENABLE +NIX_LDFLAGS +NIX_STORE +NM +OBJCOPY +OBJDUMP +PYTHONHASHSEED +PYTHONNOUSERSITE +PYTHONPATH +RANLIB +READELF +SIZE +SOURCE_DATE_EPOCH +STRINGS +STRIP +_PYTHON_HOST_PLATFORM +_PYTHON_SYSCONFIGDATA_NAME +__structuredAttrs +buildInputs +buildPhase +builder +cmakeFlags +configureFlags +depsBuildBuild +depsBuildBuildPropagated +depsBuildTarget +depsBuildTargetPropagated +depsHostHost +depsHostHostPropagated +depsTargetTarget +depsTargetTargetPropagated +doCheck +doInstallCheck +dontAddDisableDepTrack +mesonFlags +name +nativeBuildInputs +out +outputs +patches +phases +preferLocalBuild +propagatedBuildInputs +propagatedNativeBuildInputs +shell +shellHook +stdenv +strictDeps +system ~PATH ~XDG_DATA_DIRS
```

What just happened is that we populated the ambient shell environment with tools
specified inside of `flake.nix` &mdash; we'll cover Flakes later. But for now,
your tools are provisioned!


## The power of `direnv`

`direnv` with Nix is a frighteningly good development combination for many
purposes. This is its main power: you can use it to create on-demand developer
shells for any language, tool, or environment, and all you need to do is `cd` to
the right directory.

This is the power of `direnv`: your projects always, on demand, will have the
right tools configured and available, no matter if you last worked on them a day
ago or a year ago, or it was done by your teammate, or you have a brand new
computer that you've never programmed on.

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/references.md ---
Nix references and other useful tools:

- **Zero to Nix**: Start here to get your feet wet with how Nix works, and how
  to use Nixpkgs: https://zero-to-nix.com/
- `nix-installer`: My recommended way to install Nix
  - https://github.com/DeterminateSystems/nix-installer
- Nix manual https://nixos.org/manual/nix/stable/
  - Useful primarily for option and command references
- Flake schema reference https://nixos.wiki/wiki/Flakes
  - Useful to know what `flake.nix` is referring to
- Example pull requests for this repo:
  - Adding smoke tests for an extension:
    https://github.com/supabase/nix-postgres/pull/2
  - Extension smoke tests, part 2:
    https://github.com/supabase/nix-postgres/pull/3
  - Adding an extension and a smoke test at once:
    https://github.com/supabase/nix-postgres/pull/4/files
  - Updating an extension to trunk:
    https://github.com/supabase/nix-postgres/pull/7
  - Updating an extension to the latest release:
    https://github.com/supabase/nix-postgres/pull/9
- Contributing to [nixpkgs](https://github.com/nixos/nixpkgs)
  - Adding a PGRX-powered extension:
    https://github.com/NixOS/nixpkgs/pull/246803
  - Adding a normal extension: https://github.com/NixOS/nixpkgs/pull/249000
  - Adding new PostgreSQL versions: https://github.com/NixOS/nixpkgs/pull/249030
- NixOS Discourse: https://discourse.nixos.org/
  - Useful for community feedback, guidance, and help
- `nix-update`: https://github.com/Mic92/nix-update
  - Used in this repository to help update extensions
- pgTAP for testing: https://pgtap.org/documentation.html

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/build-postgres.md ---
# 01 &mdash; Using supabase nix

Let's clone this repo:

```bash
git clone https://github.com/supabase/postgres $HOME/supabase-postgres
cd $HOME/supabase-postgres
```

## Hashes for everyone

But how do we build stuff within it? With `nix build`, of course! For example,
the following command will, when completed, create a symlink named `result` that
points to a path which contains an entire PostgreSQL 15 installation &mdash;
extensions and all:

```
nix build .#psql_15/bin
```

```
$ readlink result
/nix/store/ybf48481x033649mgdzk5dyaqv9dppzx-postgresql-and-plugins-15.3
```

```
$ ls result
bin  include  lib  share
```

```
$ ll result/bin/
total 9928
dr-xr-xr-x 2 root root    4096 Dec 31  1969 ./
dr-xr-xr-x 5 root root    4096 Dec 31  1969 ../
lrwxrwxrwx 1 root root      79 Dec 31  1969 .initdb-wrapped -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/.initdb-wrapped*
-r-xr-xr-x 1 root root 9829624 Dec 31  1969 .postgres-wrapped*
lrwxrwxrwx 1 root root      73 Dec 31  1969 clusterdb -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/clusterdb*
lrwxrwxrwx 1 root root      72 Dec 31  1969 createdb -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/createdb*
lrwxrwxrwx 1 root root      74 Dec 31  1969 createuser -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/createuser*
lrwxrwxrwx 1 root root      70 Dec 31  1969 dropdb -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/dropdb*
lrwxrwxrwx 1 root root      72 Dec 31  1969 dropuser -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/dropuser*
lrwxrwxrwx 1 root root      68 Dec 31  1969 ecpg -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/ecpg*
lrwxrwxrwx 1 root root      70 Dec 31  1969 initdb -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/initdb*
lrwxrwxrwx 1 root root      72 Dec 31  1969 oid2name -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/oid2name*
lrwxrwxrwx 1 root root      74 Dec 31  1969 pg_amcheck -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_amcheck*
lrwxrwxrwx 1 root root      81 Dec 31  1969 pg_archivecleanup -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_archivecleanup*
lrwxrwxrwx 1 root root      77 Dec 31  1969 pg_basebackup -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_basebackup*
lrwxrwxrwx 1 root root      76 Dec 31  1969 pg_checksums -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_checksums*
-r-xr-xr-x 1 root root   53432 Dec 31  1969 pg_config*
lrwxrwxrwx 1 root root      78 Dec 31  1969 pg_controldata -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_controldata*
-r-xr-xr-x 1 root root   82712 Dec 31  1969 pg_ctl*
lrwxrwxrwx 1 root root      71 Dec 31  1969 pg_dump -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_dump*
lrwxrwxrwx 1 root root      74 Dec 31  1969 pg_dumpall -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_dumpall*
lrwxrwxrwx 1 root root      74 Dec 31  1969 pg_isready -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_isready*
lrwxrwxrwx 1 root root      77 Dec 31  1969 pg_receivewal -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_receivewal*
lrwxrwxrwx 1 root root      78 Dec 31  1969 pg_recvlogical -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_recvlogical*
lrwxrwxrwx 1 root root      73 Dec 31  1969 pg_repack -> /nix/store/bi9i5ns4cqxk235qz3srs9p4x1qfxfna-pg_repack-1.4.8/bin/pg_repack*
lrwxrwxrwx 1 root root      75 Dec 31  1969 pg_resetwal -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_resetwal*
lrwxrwxrwx 1 root root      74 Dec 31  1969 pg_restore -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_restore*
lrwxrwxrwx 1 root root      73 Dec 31  1969 pg_rewind -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_rewind*
lrwxrwxrwx 1 root root      77 Dec 31  1969 pg_test_fsync -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_test_fsync*
lrwxrwxrwx 1 root root      78 Dec 31  1969 pg_test_timing -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_test_timing*
lrwxrwxrwx 1 root root      74 Dec 31  1969 pg_upgrade -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_upgrade*
lrwxrwxrwx 1 root root      79 Dec 31  1969 pg_verifybackup -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_verifybackup*
lrwxrwxrwx 1 root root      74 Dec 31  1969 pg_waldump -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pg_waldump*
lrwxrwxrwx 1 root root      71 Dec 31  1969 pgbench -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/pgbench*
lrwxrwxrwx 1 root root      71 Dec 31  1969 pgsql2shp -> /nix/store/4wwzd3c136g6j7aqva2gyiqgwy784qjv-postgis-3.3.3/bin/pgsql2shp*
lrwxrwxrwx 1 root root      77 Dec 31  1969 pgsql2shp-3.3.3 -> /nix/store/4wwzd3c136g6j7aqva2gyiqgwy784qjv-postgis-3.3.3/bin/pgsql2shp-3.3.3*
lrwxrwxrwx 1 root root      75 Dec 31  1969 pgtopo_export -> /nix/store/4wwzd3c136g6j7aqva2gyiqgwy784qjv-postgis-3.3.3/bin/pgtopo_export*
lrwxrwxrwx 1 root root      81 Dec 31  1969 pgtopo_export-3.3.3 -> /nix/store/4wwzd3c136g6j7aqva2gyiqgwy784qjv-postgis-3.3.3/bin/pgtopo_export-3.3.3*
lrwxrwxrwx 1 root root      75 Dec 31  1969 pgtopo_import -> /nix/store/4wwzd3c136g6j7aqva2gyiqgwy784qjv-postgis-3.3.3/bin/pgtopo_import*
lrwxrwxrwx 1 root root      81 Dec 31  1969 pgtopo_import-3.3.3 -> /nix/store/4wwzd3c136g6j7aqva2gyiqgwy784qjv-postgis-3.3.3/bin/pgtopo_import-3.3.3*
-r-xr-xr-x 1 root root     286 Dec 31  1969 postgres*
lrwxrwxrwx 1 root root      74 Dec 31  1969 postmaster -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/postmaster*
lrwxrwxrwx 1 root root      68 Dec 31  1969 psql -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/psql*
lrwxrwxrwx 1 root root      74 Dec 31  1969 raster2pgsql -> /nix/store/4wwzd3c136g6j7aqva2gyiqgwy784qjv-postgis-3.3.3/bin/raster2pgsql*
lrwxrwxrwx 1 root root      80 Dec 31  1969 raster2pgsql-3.3.3 -> /nix/store/4wwzd3c136g6j7aqva2gyiqgwy784qjv-postgis-3.3.3/bin/raster2pgsql-3.3.3*
lrwxrwxrwx 1 root root      73 Dec 31  1969 reindexdb -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/reindexdb*
lrwxrwxrwx 1 root root      71 Dec 31  1969 shp2pgsql -> /nix/store/4wwzd3c136g6j7aqva2gyiqgwy784qjv-postgis-3.3.3/bin/shp2pgsql*
lrwxrwxrwx 1 root root      77 Dec 31  1969 shp2pgsql-3.3.3 -> /nix/store/4wwzd3c136g6j7aqva2gyiqgwy784qjv-postgis-3.3.3/bin/shp2pgsql-3.3.3*
lrwxrwxrwx 1 root root      72 Dec 31  1969 vacuumdb -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/vacuumdb*
lrwxrwxrwx 1 root root      72 Dec 31  1969 vacuumlo -> /nix/store/kdjdxnyhpwpvb11da8s99ylqilspcmzl-postgresql-15.3/bin/vacuumlo*
```

As we can see, these files all point to paths under `/nix/store`. We're actually
looking at a "farm" of symlinks to various paths, but collectively they form an
entire installation directory we can reuse as much as we want.

The path
`/nix/store/ybf48481x033649mgdzk5dyaqv9dppzx-postgresql-and-plugins-15.3`
ultimately is a cryptographically hashed, unique name for our installation of
PostgreSQL with those plugins. This hash includes _everything_ used to build it,
so even a single change anywhere to any extension or version would result in a
_new_ hash.

The ability to refer to a piece of data by its hash, by some notion of
_content_, is a very powerful primitive, as we'll see later.

## Build a different version: v16

What if we wanted PostgreSQL 16 and plugins? Just replace `_15` with `_16`:

```
nix build .#psql_16/bin
```

You're done:

```
$ readlink result
/nix/store/p7ziflx0000s28bfb213jsghrczknkc4-postgresql-and-plugins-14.8
```


## Using `nix develop`


`nix develop .` will just drop you in a subshell with
tools you need _ready to go instantly_. That's all you need to do! And once that
shell goes away, nix installed tools will be removed from your `$PATH` as well.

There's an even easier way to do this
[that is completely transparent to you, as well](./use-direnv.md).

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/receipt-files.md ---
Every time you run `nix build` on this repository to build PostgreSQL, the
installation directory comes with a _receipt_ file that tells you what's inside
of it. Primarily, this tells you:

- The version of PostgreSQL,
- The installed extensions, and
- The version of nixpkgs.

The intent of the receipt file is to provide a mechanism for tooling to
understand installation directories and provide things like upgrade paths or
upgrade mechanisms.

## Example receipt

For example:

```
nix build .#psql_15/bin
```

```
austin@GANON:~/work/nix-postgres$ nix build .#psql_15/bin
austin@GANON:~/work/nix-postgres$ ls result
bin  include  lib  receipt.json  share
```

The receipt is in JSON format, under `receipt.json`. Here's an example of what
it would look like:

```json
{
  "extensions": [
    {
      "name": "pgsql-http",
      "version": "1.5.0"
    },
    {
      "name": "pg_plan_filter",
      "version": "unstable-2021-09-23"
    },
    {
      "name": "pg_net",
      "version": "0.7.2"
    },
    {
      "name": "pg_hashids",
      "version": "unstable-2022-09-17"
    },
    {
      "name": "pgsodium",
      "version": "3.1.8"
    },
    {
      "name": "pg_graphql",
      "version": "unstable-2023-08-01"
    },
    {
      "name": "pg_stat_monitor",
      "version": "1.0.1"
    },
    {
      "name": "pg_jsonschema",
      "version": "unstable-2023-07-23"
    },
    {
      "name": "vault",
      "version": "0.2.9"
    },
    {
      "name": "hypopg",
      "version": "1.3.1"
    },
    {
      "name": "pg_tle",
      "version": "1.0.4"
    },
    {
      "name": "supabase-wrappers",
      "version": "unstable-2023-07-31"
    },
    {
      "name": "supautils",
      "version": "1.7.3"
    }
  ],
  "nixpkgs": {
    "extensions": [
      {
        "name": "postgis",
        "version": "3.3.3"
      },
      {
        "name": "pgrouting",
        "version": "3.5.0"
      },
      {
        "name": "pgtap",
        "version": "1.2.0"
      },
      {
        "name": "pg_cron",
        "version": "1.5.2"
      },
      {
        "name": "pgaudit",
        "version": "1.7.0"
      },
      {
        "name": "pgjwt",
        "version": "unstable-2021-11-13"
      },
      {
        "name": "plpgsql_check",
        "version": "2.3.4"
      },
      {
        "name": "pg-safeupdate",
        "version": "1.4"
      },
      {
        "name": "timescaledb",
        "version": "2.11.1"
      },
      {
        "name": "wal2json",
        "version": "2.5"
      },
      {
        "name": "plv8",
        "version": "3.1.5"
      },
      {
        "name": "rum",
        "version": "1.3.13"
      },
      {
        "name": "pgvector",
        "version": "0.4.4"
      },
      {
        "name": "pg_repack",
        "version": "1.4.8"
      },
      {
        "name": "pgroonga",
        "version": "3.0.8"
      }
    ],
    "revision": "750fc50bfd132a44972aa15bb21937ae26303bc4"
  },
  "psql-version": "15.3",
  "receipt-version": "1",
  "revision": "vcs=d250647+20230814"
}
```

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/adding-new-package.md ---
# Adding a new extension package


## Pre-packaging steps
1. Make sure you have nix installed [Nix installer](https://github.com/DeterminateSystems/nix-installer)
2. Create a branch off of `develop`


## C/C++ postgres extensions

If you are creating a C/C++ extension, the pattern found in https://github.com/supabase/postgres/blob/develop/nix/ext/pgvector.nix will work well.

```
{ lib, stdenv, fetchFromGitHub, postgresql }:

stdenv.mkDerivation rec {
  pname = "pgvector";
  version = "0.7.4";

  buildInputs = [ postgresql ];

  src = fetchFromGitHub {
    owner = "pgvector";
    repo = pname;
    rev = "refs/tags/v${version}";
    hash = "sha256-qwPaguQUdDHV8q6GDneLq5MuhVroPizpbqt7f08gKJI=";
  };

  installPhase = ''
    mkdir -p $out/{lib,share/postgresql/extension}

    cp *.so      $out/lib
    cp sql/*.sql $out/share/postgresql/extension
    cp *.control $out/share/postgresql/extension
  '';

  meta = with lib; {
    description = "Open-source vector similarity search for Postgres";
    homepage = "https://github.com/${src.owner}/${src.repo}";
    maintainers = with maintainers; [ olirice ];
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}
```

This uses `stdenv.mkDerivation` which is a general nix builder for C and C++ projects (and others). It can auto detect the Makefile, and attempt to use it. ***It's a good practice to not have steps in the Makefile of your project that try to deal with OS specific system paths, or make calls out to the internet, as Nix cannot use these steps to build your project.*** 

Your build should produce all of the sql and control files needed for the install phase.

1. Once you have created this file, you can add it to `nix/ext/<yourname>.nix` and edit `flake.nix` and add it to the `ourExtensions` list.
2. `git add .` as nix uses git to track changes 
3. In your package file, temporarily empty the `hash = "sha256<...>=";` to `hash = "";` and save and `git add .`
4. Run `nix build .#psql_15/exts/<yourname>`  to try to trigger a build, nix will print the calculated sha256 value that you can add back the the `hash` variable, save the file again, and re-run `nix build .#psql_15/exts/<yourname>`. 
5. Add any needed migrations into the `supabase/postgres` migrations directory.
6. You can then run tests locally to verify that the update of the package succeeded. 
7. Now it's ready for PR review!

## Extensions written in Rust that use `buildPgrxExtension` builder

Extensions like:

* https://github.com/supabase/postgres/blob/develop/nix/ext/wrappers/default.nix
* https://github.com/supabase/postgres/blob/develop/nix/ext/pg_graphql.nix
* https://github.com/supabase/postgres/blob/develop/nix/ext/pg_jsonschema.nix

Are written in Rust, built with `cargo`, and need to use https://github.com/pgcentralfoundation/pgrx to build the extension.

We in turn have a special nix package `builder` which is sourced from `nixpkgs` and called `buildPgrxExtension` 

A simple example is found in `pg_jsonschema`


```
{ lib, stdenv, fetchFromGitHub, postgresql, buildPgrxExtension_0_11_3, cargo }:

buildPgrxExtension_0_11_3 rec {
  pname = "pg_jsonschema";
  version = "0.3.1";
  inherit postgresql;

  src = fetchFromGitHub {
    owner = "supabase";
    repo = pname;
    rev = "v${version}";
    hash = "sha256-YdKpOEiDIz60xE7C+EzpYjBcH0HabnDbtZl23CYls6g=";
  };

  nativeBuildInputs = [ cargo ];
  buildInputs = [ postgresql ];
  # update the following array when the pg_jsonschema version is updated
  # required to ensure that extensions update scripts from previous versions are generated

  previousVersions = ["0.3.0" "0.2.0" "0.1.4" "0.1.4" "0.1.2" "0.1.1" "0.1.0"];
  CARGO="${cargo}/bin/cargo";
  env = lib.optionalAttrs stdenv.isDarwin {
    POSTGRES_LIB = "${postgresql}/lib";
    RUSTFLAGS = "-C link-arg=-undefined -C link-arg=dynamic_lookup";
  };
  cargoHash = "sha256-VcS+efMDppofuFW2zNrhhsbC28By3lYekDFquHPta2g=";

  # FIXME (aseipp): testsuite tries to write files into /nix/store; we'll have
  # to fix this a bit later.
  doCheck = false;

  preBuild = ''
    echo "Processing git tags..."
    echo '${builtins.concatStringsSep "," previousVersions}' | sed 's/,/\n/g' > git_tags.txt
  '';

  postInstall = ''
    echo "Creating SQL files for previous versions..."
    current_version="${version}"
    sql_file="$out/share/postgresql/extension/pg_jsonschema--$current_version.sql"
    
    if [ -f "$sql_file" ]; then
      while read -r previous_version; do
        if [ "$(printf '%s\n' "$previous_version" "$current_version" | sort -V | head -n1)" = "$previous_version" ] && [ "$previous_version" != "$current_version" ]; then
          new_file="$out/share/postgresql/extension/pg_jsonschema--$previous_version--$current_version.sql"
          echo "Creating $new_file"
          cp "$sql_file" "$new_file"
        fi
      done < git_tags.txt
    else
      echo "Warning: $sql_file not found"
    fi
    rm git_tags.txt
  '';


  meta = with lib; {
    description = "JSON Schema Validation for PostgreSQL";
    homepage = "https://github.com/supabase/${pname}";
    maintainers = with maintainers; [ samrose ];
    platforms = postgresql.meta.platforms;
    license = licenses.postgresql;
  };
}
```

Here we have built support in our overlay to specify and pin the version of `buildPgrxExtension` to a specific version (in this case `buildPgrxExtension_0_11_3`). This is currently the only version we can support, but this can be extended in our overlay https://github.com/supabase/postgres/blob/develop/nix/overlays/cargo-pgrx-0-11-3.nix to support other versions.

A few things about `buildPgrxExtension_x`:

* It doesn't support `buildPhase`, `installPhase` and those are implemented directly in the builder already
* It mostly just allows `cargo build` to do it's thing, but you may need to set env vars for the build process as seen above 
* It caclulates a special `cargoHash` that will be generated after the first in `src` is generated, when running `nix build .#psql_15/exts/<yourname>` to build the extension


## Post Nix derivation release steps


1. You can add and run tests as described in https://github.com/supabase/postgres/blob/develop/nix/docs/adding-tests.md 
2. You may need to add tests to our test.yml gh action workflow as well.
3. You can add the package and name and version to `ansible/vars.yml` it is not necessary to add the sha256 hash here, as the package is already built and cached in our release process before these vars are ever run.
4. to check that all your files will land in the overall build correctly, you can run `nix profile install .#psql_15/bin` on your machine, and check in `~/.nix-profile/bin, ~/.nix-profile/lib, ~/.nix-profile/share/postgresql/*` and you should see your lib, .control and sql files there. 
5. You can also run `nix run .#start-server 15` and in a new terminal window run `nix run .#star-client-and-migrate 15` and try to `CREATE EXTENSION <yourname>` and work with it there
6. Check that your extension works with the `pg_upgrade` process (TODO documentation forthcoming)
7. Now you are ready to PR the extension
8. From here, the release process should typically take care of the rest. 
'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/docker.md ---
Docker images are pushed to `ghcr.io` on every commit. Try the following:

```
docker run --rm -it ghcr.io/supabase/nix-postgres-15:latest
```

Every Docker image that is built on every push is given a tag that exactly
corresponds to a Git commit in the repository &mdash; for example commit
[d3e0c39d34e1bb4d37e058175a7bc376620f6868](https://github.com/supabase/nix-postgres/commit/d3e0c39d34e1bb4d37e058175a7bc376620f6868)
in this repository has a tag in the container registry which can be used to pull
exactly that version.

This just starts the server. Client container images are not provided; you can
use `nix run` for that, as outlined [here](./start-client-server.md).

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/update-extension.md ---

# Update an existing nix extension


1. Create a branch off of `develop`
2. For instance, if we were updating https://github.com/supabase/postgres/blob/develop/nix/ext/supautils.nix we would:
   1. change the `version = "2.2.1";` to whatever our git tag release version is that we want to update to
   2. temporarily empty the `hash = "sha256-wSUEG0at00TPAoHv6+NMzuUE8mfW6fnHH0MNxvBdUiE=";` to `hash = "";` and save `supautils.nix` and `git add  .`
   3. run `nix build .#psql_15/exts/supautils` or the name of the extension to update, nix will print the calculated sha256 value that you can add back the the `hash` variable, save the file again, and re-run nix build .#psql_15/exts/supautils.
   4. NOTE: This step is only necessary for `buildPgrxExtension` packages, which includes supabase-wrappers, pg_jsonschema, and pg_graphql. Otherwise you can skip this step. For our packages that are build with `buildPgrxExtension` you will need to prepend the previous version to the `previousVersions` variable before updating the version in the package (for instance if you are updating `supabase-wrappers` extension from `0.4.1` to `0.4.2` then you would prepend `0.4.1` to this line https://github.com/supabase/postgres/blob/develop/nix/ext/wrappers/default.nix#L18 ). 
   5. Add any needed migrations into the `supabase/postgres` migrations directory
   6. update the version in `ansible/vars.yml` as usual
   7. You can then run the `nix flake check -L` tests locally to verify that the update of the package succeeded. 
   8. Now it's ready for PR review.
   9. Once the PR is approved, if you want the change to go out in a release, update the common-nix.vars.yml file with the new version prior to merging.
  


'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/docs/migration-tests.md ---
Migration tests are run similar to running the client and server; see
[more on that here](./start-client-server.md).

Instead, you use the following format to specify the upgrade:

```
nix run .#migration-test <from> <to> [pg_dumpall|pg_upgrade]
```

The arguments are:

- The version to upgrade from
- The version to upgrade to
- The upgrade mechanism: either `pg_dumpall` or `pg_upgrade`

## Specifying the version

The versions for upgrading can be one of two forms:

- A major version number, e.g. `14` or `15`
- A path to `/nix/store`, which points to _any_ version of PostgreSQL, as long
  as it has the "expected" layout and is a postgresql install.

## Always use the latest version of the migration tool

Unlike the method for starting the client or server, you probably always want to
use the latest version of the `migration-test` tool from the repository. This is
because it can ensure forwards and backwards compatibility if necessary.

## Upgrading between arbitrary `/nix/store` versions

If you want to test migrations from arbitrary versions built by the repository,
you can combine `nix build` and `nix run` to do so. You can use the syntax from
the runbook on [running the server & client](./start-client-server.md) to refer
to arbitrary git revisions.

For example, if you updated an extension in this repository, and you want to
test a migration from PostgreSQL 14 to PostgreSQL 14 + (updated extension),
using `pg_upgrade` &mdash; simply record the two git commits you want to
compare, and you could do something like the following:

```
OLD_GIT_VERSION=...
NEW_GIT_VERSION=...

nix run github:supabase/nix-postgres#migration-test \
  $(nix build "github:supabase/nix-postgres/$OLD_GIT_VERSION#psql_14/bin") \
  $(nix build "github:supabase/nix-postgres/$NEW_GIT_VERSION#psql_14/bin") \
  pg_upgrade
```

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/cargo-pgrx/default.nix ---
{ lib
, darwin
, fetchCrate
, openssl
, pkg-config
, makeRustPlatform
, stdenv
, rust-bin
}:
let
  rustVersion = "1.85.1";
  rustPlatform = makeRustPlatform {
    cargo = rust-bin.stable.${rustVersion}.default;
    rustc = rust-bin.stable.${rustVersion}.default;
  };
  generic =
    { version
    , hash
    , cargoHash
    }:
    rustPlatform.buildRustPackage rec {
      # rust-overlay uses 'cargo-auditable' wrapper for 'cargo' command, but it
      # is using older version 0.18.1 of 'cargo_metadata' which doesn't support
      # rust edition 2024, so we disable the 'cargo-auditable' just for now.
      # ref: https://github.com/oxalica/rust-overlay/issues/153
      auditable = false;
      pname = "cargo-pgrx";
      inherit version;
      src = fetchCrate {
        inherit version pname hash;
      };
      inherit cargoHash;
      nativeBuildInputs = lib.optionals stdenv.hostPlatform.isLinux [
        pkg-config
      ];
      buildInputs = lib.optionals stdenv.hostPlatform.isLinux [
        openssl
      ] ++ lib.optionals stdenv.hostPlatform.isDarwin [
        darwin.apple_sdk.frameworks.Security
      ];
      
      OPENSSL_DIR = "${openssl.dev}";
      OPENSSL_INCLUDE_DIR = "${openssl.dev}/include";
      OPENSSL_LIB_DIR = "${openssl.out}/lib";
      PKG_CONFIG_PATH = "${openssl.dev}/lib/pkgconfig";
      preCheck = ''
        export PGRX_HOME=$(mktemp -d)
      '';
      checkFlags = [
        # requires pgrx to be properly initialized with cargo pgrx init
        "--skip=command::schema::tests::test_parse_managed_postmasters"
      ];
      meta = with lib; {
        description = "Build Postgres Extensions with Rust";
        homepage = "https://github.com/pgcentralfoundation/pgrx";
        changelog = "https://github.com/pgcentralfoundation/pgrx/releases/tag/v${version}";
        license = licenses.mit;
        maintainers = with maintainers; [ happysalada ];
        mainProgram = "cargo-pgrx";
      };
    };
in
{
  cargo-pgrx_0_11_3 = generic {
    version = "0.11.3";
    hash = "sha256-UHIfwOdXoJvR4Svha6ud0FxahP1wPwUtviUwUnTmLXU=";
    cargoHash = "sha256-j4HnD8Zt9uhlV5N7ldIy9564o9qFEqs5KfXHmnQ1WEw=";
  };
  cargo-pgrx_0_12_6 = generic {
    version = "0.12.6";
    hash = "sha256-7aQkrApALZe6EoQGVShGBj0UIATnfOy2DytFj9IWdEA=";
    cargoHash = "sha256-Di4UldQwAt3xVyvgQT1gUhdvYUVp7n/a72pnX45kP0w=";
  };
  cargo-pgrx_0_12_9 = generic {
    version = "0.12.9";
    hash = "sha256-aR3DZAjeEEAjLQfZ0ZxkjLqTVMIEbU0UiZ62T4BkQq8=";
    cargoHash = "sha256-KTKcol9qSNLQZGW32e6fBb6cPkUGItknyVpLdBYqrBY=";
  };
  cargo-pgrx_0_14_3 = generic {
    version = "0.14.3";
    hash = "sha256-3TsNpEqNm3Uol5XPW1i0XEbP2fF2+RKB2d7lO6BDnvQ=";
    cargoHash = "sha256-Ny7j56pwB+2eEK62X0nWfFKQy5fBz+Q1oyvecivxLkk=";
  };
  inherit rustPlatform;
}

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/nix/cargo-pgrx/buildPgrxExtension.nix ---
# preBuildAndTest and some small other bits
# taken from https://github.com/tcdi/pgrx/blob/v0.9.4/nix/extension.nix
# (but now heavily modified)
# which uses MIT License with the following license file
#
# MIT License
#
# Portions Copyright 2019-2021 ZomboDB, LLC.
# Portions Copyright 2021-2022 Technology Concepts & Design, Inc. <support@tcdi.com>.
# All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

{ lib
, cargo-pgrx
, pkg-config
, rustPlatform
, stdenv
, Security
, writeShellScriptBin
}:

# The idea behind: Use it mostly like rustPlatform.buildRustPackage and so
# we hand most of the arguments down.
#
# Additional arguments are:
#   - `postgresql` postgresql package of the version of postgresql this extension should be build for.
#                  Needs to be the build platform variant.
#   - `useFakeRustfmt` Whether to use a noop fake command as rustfmt. cargo-pgrx tries to call rustfmt.
#                      If the generated rust bindings aren't needed to use the extension, its a
#                      unnecessary and heavy dependency. If you set this to true, you also
#                      have to add `rustfmt` to `nativeBuildInputs`.

{ buildAndTestSubdir ? null
, buildType ? "release"
, buildFeatures ? [ ]
, cargoBuildFlags ? [ ]
, postgresql
# cargo-pgrx calls rustfmt on generated bindings, this is not strictly necessary, so we avoid the
# dependency here. Set to false and provide rustfmt in nativeBuildInputs, if you need it, e.g.
# if you include the generated code in the output via postInstall.
, useFakeRustfmt ? true
, usePgTestCheckFeature ? true
, ...
} @ args:
let
  rustfmtInNativeBuildInputs = lib.lists.any (dep: lib.getName dep == "rustfmt") (args.nativeBuildInputs or []);
in

assert lib.asserts.assertMsg ((args.installPhase or "") == "")
  "buildPgrxExtensions overwrites the installPhase, so providing one does nothing";
assert lib.asserts.assertMsg ((args.buildPhase or "") == "")
  "buildPgrxExtensions overwrites the buildPhase, so providing one does nothing";
assert lib.asserts.assertMsg (useFakeRustfmt -> !rustfmtInNativeBuildInputs)
  "The parameter useFakeRustfmt is set to true, but rustfmt is included in nativeBuildInputs. Either set useFakeRustfmt to false or remove rustfmt from nativeBuildInputs.";
assert lib.asserts.assertMsg (!useFakeRustfmt -> rustfmtInNativeBuildInputs)
  "The parameter useFakeRustfmt is set to false, but rustfmt is not included in nativeBuildInputs. Either set useFakeRustfmt to true or add rustfmt from nativeBuildInputs.";

let
  fakeRustfmt = writeShellScriptBin "rustfmt" ''
    exit 0
    '';
  maybeDebugFlag = lib.optionalString (buildType != "release") "--debug";
  maybeEnterBuildAndTestSubdir = lib.optionalString (buildAndTestSubdir != null) ''
    export CARGO_TARGET_DIR="$(pwd)/target"
    pushd "${buildAndTestSubdir}"
  '';
  maybeLeaveBuildAndTestSubdir = lib.optionalString (buildAndTestSubdir != null) "popd";

  pgrxPostgresMajor = lib.versions.major postgresql.version;
  preBuildAndTest = ''
    export PGRX_HOME=$(mktemp -d)
    export PGDATA="$PGRX_HOME/data-${pgrxPostgresMajor}/"
    cargo-pgrx pgrx init "--pg${pgrxPostgresMajor}" ${lib.getDev postgresql}/bin/pg_config
    echo "unix_socket_directories = '$(mktemp -d)'" > "$PGDATA/postgresql.conf"

    # This is primarily for Mac or other Nix systems that don't use the nixbld user.
    export USER="$(whoami)"
    pg_ctl start
    createuser -h localhost --superuser --createdb "$USER" || true
    pg_ctl stop
  '';

  argsForBuildRustPackage = builtins.removeAttrs args [ "postgresql" "useFakeRustfmt" "usePgTestCheckFeature" ];

  # so we don't accidentally `(rustPlatform.buildRustPackage argsForBuildRustPackage) // { ... }` because
  # we forgot parentheses
  finalArgs = argsForBuildRustPackage // {
    buildInputs = (args.buildInputs or [ ]) ++ lib.optionals stdenv.hostPlatform.isDarwin [ Security ];

    nativeBuildInputs = (args.nativeBuildInputs or [ ]) ++ [
      cargo-pgrx
      postgresql
      pkg-config
      rustPlatform.bindgenHook
    ] ++ lib.optionals useFakeRustfmt [ fakeRustfmt ];

    buildPhase = ''
      runHook preBuild

      echo "Executing cargo-pgrx buildPhase"
      ${preBuildAndTest}
      ${maybeEnterBuildAndTestSubdir}

      PGRX_BUILD_FLAGS="--frozen -j $NIX_BUILD_CORES ${builtins.concatStringsSep " " cargoBuildFlags}" \
      ${lib.optionalString stdenv.hostPlatform.isDarwin ''RUSTFLAGS="''${RUSTFLAGS:+''${RUSTFLAGS} }-Clink-args=-Wl,-undefined,dynamic_lookup"''} \
      cargo pgrx package \
        --pg-config ${lib.getDev postgresql}/bin/pg_config \
        ${maybeDebugFlag} \
        --features "${builtins.concatStringsSep " " buildFeatures}" \
        --out-dir "$out"

      ${maybeLeaveBuildAndTestSubdir}

      runHook postBuild
    '';

    preCheck = preBuildAndTest + args.preCheck or "";

    installPhase = ''
      runHook preInstall

      echo "Executing buildPgrxExtension install"

      ${maybeEnterBuildAndTestSubdir}

      cargo-pgrx pgrx stop all

      mv $out/${postgresql}/* $out
      rm -rf $out/nix

      ${maybeLeaveBuildAndTestSubdir}

      runHook postInstall
    '';

    PGRX_PG_SYS_SKIP_BINDING_REWRITE = "1";
    CARGO_BUILD_INCREMENTAL = "false";
    RUST_BACKTRACE = "full";

    checkNoDefaultFeatures = true;
    checkFeatures = (args.checkFeatures or [ ]) ++ (lib.optionals usePgTestCheckFeature [ "pg_test" ]) ++ [ "pg${pgrxPostgresMajor}" ];
  };
in
rustPlatform.buildRustPackage finalArgs

'''

'''--- /Users/barneycook/Desktop/code/ProjectRef/postgres/flake.nix ---
{
  description = "Prototype tooling for deploying PostgreSQL";

  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs/nixpkgs-unstable";
    flake-utils.url = "github:numtide/flake-utils";
    nix2container.url = "github:nlewo/nix2container";
    nix-editor.url = "github:snowfallorg/nix-editor";
    rust-overlay.url = "github:oxalica/rust-overlay";
  };

  outputs = { self, nixpkgs, flake-utils, nix-editor, rust-overlay, nix2container, ... }:
    let
      gitRev = "vcs=${self.shortRev or "dirty"}+${builtins.substring 0 8 (self.lastModifiedDate or self.lastModified or "19700101")}";

      ourSystems = with flake-utils.lib; [
        system.x86_64-linux
        system.aarch64-linux
        system.aarch64-darwin
      ];
    in
    flake-utils.lib.eachSystem ourSystems (system:
      let
        pgsqlDefaultPort = "5435";
        pgsqlDefaultHost = "localhost";
        pgsqlSuperuser = "supabase_admin";

        pkgs = import nixpkgs {
          config = {
            allowUnfree = true;
            permittedInsecurePackages = [
              "v8-9.7.106.18"
            ];
          };
          inherit system;
          overlays = [
            # NOTE: add any needed overlays here. in theory we could
            # pull them from the overlays/ directory automatically, but we don't
            # want to have an arbitrary order, since it might matter. being
            # explicit is better.
            (final: prev: {
              xmrig = throw "The xmrig package has been explicitly disabled in this flake.";
            })
            (import rust-overlay)
            (final: prev: {
              cargo-pgrx = final.callPackage ./nix/cargo-pgrx/default.nix {
                inherit (final) lib;
                inherit (final) darwin;
                inherit (final) fetchCrate;
                inherit (final) openssl;
                inherit (final) pkg-config;
                inherit (final) makeRustPlatform;
                inherit (final) stdenv;
                inherit (final) rust-bin;
              };

              buildPgrxExtension = final.callPackage ./nix/cargo-pgrx/buildPgrxExtension.nix {
                inherit (final) cargo-pgrx;
                inherit (final) lib;
                inherit (final) Security;
                inherit (final) pkg-config;
                inherit (final) makeRustPlatform;
                inherit (final) stdenv;
                inherit (final) writeShellScriptBin;
              };

              buildPgrxExtension_0_11_3 = prev.buildPgrxExtension.override {
                cargo-pgrx = final.cargo-pgrx.cargo-pgrx_0_11_3;
              };

              buildPgrxExtension_0_12_6 = prev.buildPgrxExtension.override {
                cargo-pgrx = final.cargo-pgrx.cargo-pgrx_0_12_6;
              };

              buildPgrxExtension_0_12_9 = prev.buildPgrxExtension.override {
                cargo-pgrx = final.cargo-pgrx.cargo-pgrx_0_12_9;
              };

              buildPgrxExtension_0_14_3 = prev.buildPgrxExtension.override {
                cargo-pgrx = final.cargo-pgrx.cargo-pgrx_0_14_3;
              };

            })
            (final: prev: {
              postgresql = final.callPackage ./nix/postgresql/default.nix {
                inherit (final) lib stdenv fetchurl makeWrapper callPackage buildEnv newScope;
              };
            })
          ];
        };
        # Define pythonEnv here
        pythonEnv = pkgs.python3.withPackages (ps: with ps; [
          boto3
          docker
          pytest
          pytest-testinfra
          requests
          ec2instanceconnectcli
          paramiko
        ]);

        # Add this new definition
        nixFastBuild = pkgs.nix-fast-build or null;

        sfcgal = pkgs.callPackage ./nix/ext/sfcgal/sfcgal.nix { };
        supabase-groonga = pkgs.callPackage ./nix/supabase-groonga.nix { };
        mecab-naist-jdic = pkgs.callPackage ./nix/ext/mecab-naist-jdic/default.nix { };
        inherit (pkgs.callPackage ./nix/wal-g.nix { }) wal-g-2 wal-g-3;
        # Our list of PostgreSQL extensions which come from upstream Nixpkgs.
        # These are maintained upstream and can easily be used here just by
        # listing their name. Anytime the version of nixpkgs is upgraded, these
        # may also bring in new versions of the extensions.
        psqlExtensions = [
          /* pljava */
          /*"postgis"*/
        ];

        #FIXME for now, timescaledb is not included in the orioledb version of supabase extensions, as there is an issue
        # with building timescaledb with the orioledb patched version of postgresql
        orioledbPsqlExtensions = [
          /* pljava */
          /*"timescaledb"*/
        ];

        # Custom extensions that exist in our repository. These aren't upstream
        # either because nobody has done the work, maintaining them here is
        # easier and more expedient, or because they may not be suitable, or are
        # too niche/one-off.
        #
        # Ideally, most of these should have copies upstream for third party
        # use, but even if they did, keeping our own copies means that we can
        # rollout new versions of these critical things easier without having to
        # go through the upstream release engineering process.
        ourExtensions = [
          ./nix/ext/rum.nix
          ./nix/ext/timescaledb.nix
          ./nix/ext/timescaledb-2.9.1.nix
          ./nix/ext/pgroonga.nix
          ./nix/ext/index_advisor.nix
          ./nix/ext/wal2json.nix
          ./nix/ext/pgmq.nix
          ./nix/ext/pg_repack.nix
          # ./nix/ext/pg-safeupdate.nix
          ./nix/ext/plpgsql-check.nix
          ./nix/ext/pgjwt.nix
          ./nix/ext/pgaudit.nix
          ./nix/ext/postgis.nix
          ./nix/ext/pgrouting.nix
          ./nix/ext/pgtap.nix
          ./nix/ext/pg_cron.nix
          ./nix/ext/pgsql-http.nix
          ./nix/ext/pg_plan_filter.nix
          ./nix/ext/pg_net.nix
          ./nix/ext/pg_hashids.nix
          ./nix/ext/pgsodium.nix
          ./nix/ext/pg_graphql.nix
          ./nix/ext/pg_stat_monitor.nix
          ./nix/ext/pg_jsonschema.nix
          ./nix/ext/pgvector.nix
          ./nix/ext/vault.nix
          ./nix/ext/hypopg.nix
          ./nix/ext/pg_tle.nix
          ./nix/ext/wrappers/default.nix
          ./nix/ext/supautils.nix
          ./nix/ext/plv8.nix
          ./nix/ext/age.nix
          ./nix/ext/pg_backtrace.nix 
        ];

        #Where we import and build the orioledb extension, we add on our custom extensions
        # plus the orioledb option
        #we're not using timescaledb or plv8 in the orioledb-17 version or pg 17 of supabase extensions
        orioleFilteredExtensions = builtins.filter
          (
            x:
            x != ./nix/ext/timescaledb.nix &&
            x != ./nix/ext/timescaledb-2.9.1.nix &&
            x != ./nix/ext/plv8.nix &&
            x != ./nix/ext/age.nix &&
            x != ./nix/ext/pgroonga.nix
        ) ourExtensions;

        orioledbExtensions = orioleFilteredExtensions ++ [ ./nix/ext/orioledb.nix ];
        dbExtensions17 = orioleFilteredExtensions;
        getPostgresqlPackage = version:
          pkgs.postgresql."postgresql_${version}";
        # Create a 'receipt' file for a given postgresql package. This is a way
        # of adding a bit of metadata to the package, which can be used by other
        # tools to inspect what the contents of the install are: the PSQL
        # version, the installed extensions, et cetera.
        #
        # This takes two arguments:
        #  - pgbin: the postgresql package we are building on top of
        #    not a list of packages, but an attrset containing extension names
        #    mapped to versions.
        #  - ourExts: the list of extensions from upstream nixpkgs. This is not
        #    a list of packages, but an attrset containing extension names
        #    mapped to versions.
        #
        # The output is a package containing the receipt.json file, which can be
        # merged with the PostgreSQL installation using 'symlinkJoin'.
        makeReceipt = pgbin: ourExts: pkgs.writeTextFile {
          name = "receipt";
          destination = "/receipt.json";
          text = builtins.toJSON {
            revision = gitRev;
            psql-version = pgbin.version;
            nixpkgs = {
              revision = nixpkgs.rev;
            };
            extensions = ourExts;

            # NOTE this field can be used to do cache busting (e.g.
            # force a rebuild of the psql packages) but also to helpfully inform
            # tools what version of the schema is being used, for forwards and
            # backwards compatibility
            receipt-version = "1";
          };
        };

        makeOurPostgresPkgs = version:
          let
            postgresql = getPostgresqlPackage version;
            extensionsToUse =
              if (builtins.elem version [ "orioledb-17" ])
              then orioledbExtensions
             else if (builtins.elem version [ "17" ])
             then dbExtensions17
              else ourExtensions;
          in
         map (path: pkgs.callPackage path { inherit postgresql; }) extensionsToUse;


        # Create an attrset that contains all the extensions included in a server.
        makeOurPostgresPkgsSet = version:
          (builtins.listToAttrs (map
            (drv:
              { name = drv.pname; value = drv; }
            )
            (makeOurPostgresPkgs version)))
          // { recurseForDerivations = true; };


        # Create a binary distribution of PostgreSQL, given a version.
        #
        # NOTE: The version here does NOT refer to the exact PostgreSQL version;
        # it refers to the *major number only*, which is used to select the
        # correct version of the package from nixpkgs. This is because we want
        # to be able to do so in an open ended way. As an example, the version
        # "15" passed in will use the nixpkgs package "postgresql_15" as the
        # basis for building extensions, etc.
        makePostgresBin = version:
          let
            postgresql = getPostgresqlPackage version;
            ourExts = map (ext: { name = ext.pname; version = ext.version; }) (makeOurPostgresPkgs version);

            pgbin = postgresql.withPackages (ps:
              makeOurPostgresPkgs version
            );
          in
          pkgs.symlinkJoin {
            inherit (pgbin) name version;
            paths = [ pgbin (makeReceipt pgbin ourExts) ];
          };

        # Create an attribute set, containing all the relevant packages for a
        # PostgreSQL install, wrapped up with a bow on top. There are three
        # packages:
        #
        #  - bin: the postgresql package itself, with all the extensions
        #    installed, and a receipt.json file containing metadata about the
        #    install.
        #  - exts: an attrset containing all the extensions, mapped to their
        #    package names.
        makePostgres = version: rec {
          bin = makePostgresBin version;
          exts = makeOurPostgresPkgsSet version;
          recurseForDerivations = true;
        };

        makePostgresDevSetup = { pkgs, name, extraSubstitutions ? { } }:
          let
            paths = {
              migrationsDir = builtins.path {
                name = "migrations";
                path = ./migrations/db;
              };
              postgresqlSchemaSql = builtins.path {
                name = "postgresql-schema";
                path = ./nix/tools/postgresql_schema.sql;
              };
              pgbouncerAuthSchemaSql = builtins.path {
                name = "pgbouncer-auth-schema";
                path = ./ansible/files/pgbouncer_config/pgbouncer_auth_schema.sql;
              };
              statExtensionSql = builtins.path {
                name = "stat-extension";
                path = ./ansible/files/stat_extension.sql;
              };
              pgconfigFile = builtins.path {
                name = "postgresql.conf";
                path = ./ansible/files/postgresql_config/postgresql.conf.j2;
              };
              supautilsConfigFile = builtins.path {
                name = "supautils.conf";
                path = ./ansible/files/postgresql_config/supautils.conf.j2;
              };
              loggingConfigFile = builtins.path {
                name = "logging.conf";
                path = ./ansible/files/postgresql_config/postgresql-csvlog.conf;
              };
              readReplicaConfigFile = builtins.path {
                name = "readreplica.conf";
                path = ./ansible/files/postgresql_config/custom_read_replica.conf.j2;
              };
              pgHbaConfigFile = builtins.path {
                name = "pg_hba.conf";
                path = ./ansible/files/postgresql_config/pg_hba.conf.j2;
              };
              pgIdentConfigFile = builtins.path {
                name = "pg_ident.conf";
                path = ./ansible/files/postgresql_config/pg_ident.conf.j2;
              };
              postgresqlExtensionCustomScriptsPath = builtins.path {
                name = "extension-custom-scripts";
                path = ./ansible/files/postgresql_extension_custom_scripts;
              };
              getkeyScript = builtins.path {
                name = "pgsodium_getkey.sh";
                path = ./nix/tests/util/pgsodium_getkey.sh;
              };
            };

            localeArchive =
              if pkgs.stdenv.isDarwin
              then "${pkgs.darwin.locale}/share/locale"
              else "${pkgs.glibcLocales}/lib/locale/locale-archive";

            substitutions = {
              SHELL_PATH = "${pkgs.bash}/bin/bash";
              PGSQL_DEFAULT_PORT = "${pgsqlDefaultPort}";
              PGSQL_SUPERUSER = "${pgsqlSuperuser}";
              PSQL15_BINDIR = "${basePackages.psql_15.bin}";
              PSQL17_BINDIR = "${basePackages.psql_17.bin}";
              PSQL_CONF_FILE = "${paths.pgconfigFile}";
              PSQLORIOLEDB17_BINDIR = "${basePackages.psql_orioledb-17.bin}";
              PGSODIUM_GETKEY = "${paths.getkeyScript}";
              READREPL_CONF_FILE = "${paths.readReplicaConfigFile}";
              LOGGING_CONF_FILE = "${paths.loggingConfigFile}";
              SUPAUTILS_CONF_FILE = "${paths.supautilsConfigFile}";
              PG_HBA = "${paths.pgHbaConfigFile}";
              PG_IDENT = "${paths.pgIdentConfigFile}";
              LOCALES = "${localeArchive}";
              EXTENSION_CUSTOM_SCRIPTS_DIR = "${paths.postgresqlExtensionCustomScriptsPath}";
              MECAB_LIB = "${basePackages.psql_15.exts.pgroonga}/lib/groonga/plugins/tokenizers/tokenizer_mecab.so";
              GROONGA_DIR = "${supabase-groonga}";
              MIGRATIONS_DIR = "${paths.migrationsDir}";
              POSTGRESQL_SCHEMA_SQL = "${paths.postgresqlSchemaSql}";
              PGBOUNCER_AUTH_SCHEMA_SQL = "${paths.pgbouncerAuthSchemaSql}";
              STAT_EXTENSION_SQL = "${paths.statExtensionSql}";
              CURRENT_SYSTEM = "${system}";
            } // extraSubstitutions; # Merge in any extra substitutions
          in
          pkgs.runCommand name
            {
              inherit (paths) migrationsDir postgresqlSchemaSql pgbouncerAuthSchemaSql statExtensionSql;
            } ''
            mkdir -p $out/bin $out/etc/postgresql-custom $out/etc/postgresql $out/extension-custom-scripts

            # Copy config files with error handling
            cp ${paths.supautilsConfigFile} $out/etc/postgresql-custom/supautils.conf || { echo "Failed to copy supautils.conf"; exit 1; }
            cp ${paths.pgconfigFile} $out/etc/postgresql/postgresql.conf || { echo "Failed to copy postgresql.conf"; exit 1; }
            cp ${paths.loggingConfigFile} $out/etc/postgresql-custom/logging.conf || { echo "Failed to copy logging.conf"; exit 1; }
            cp ${paths.readReplicaConfigFile} $out/etc/postgresql-custom/read-replica.conf || { echo "Failed to copy read-replica.conf"; exit 1; }
            cp ${paths.pgHbaConfigFile} $out/etc/postgresql/pg_hba.conf || { echo "Failed to copy pg_hba.conf"; exit 1; }
            cp ${paths.pgIdentConfigFile} $out/etc/postgresql/pg_ident.conf || { echo "Failed to copy pg_ident.conf"; exit 1; }
            cp -r ${paths.postgresqlExtensionCustomScriptsPath}/* $out/extension-custom-scripts/ || { echo "Failed to copy custom scripts"; exit 1; }

            echo "Copy operation completed"
            chmod 644 $out/etc/postgresql-custom/supautils.conf
            chmod 644 $out/etc/postgresql/postgresql.conf
            chmod 644 $out/etc/postgresql-custom/logging.conf
            chmod 644 $out/etc/postgresql/pg_hba.conf

            substitute ${./nix/tools/run-server.sh.in} $out/bin/start-postgres-server \
              ${builtins.concatStringsSep " " (builtins.attrValues (builtins.mapAttrs
                (name: value: "--subst-var-by '${name}' '${value}'")
                substitutions
              ))}
            chmod +x $out/bin/start-postgres-server
          '';

        # The base set of packages that we export from this Nix Flake, that can
        # be used with 'nix build'. Don't use the names listed below; check the
        # name in 'nix flake show' in order to make sure exactly what name you
        # want.
        basePackages =
          let
            # Function to get the PostgreSQL version from the attribute name
            getVersion = name:
              let
                match = builtins.match "psql_([0-9]+)" name;
              in
              if match == null then null else builtins.head match;

            # Define the available PostgreSQL versions
            postgresVersions = {
              psql_15 = makePostgres "15";
              psql_17 = makePostgres "17";
              psql_orioledb-17 = makePostgres "orioledb-17";
            };

            # Find the active PostgreSQL version
            activeVersion = getVersion (builtins.head (builtins.attrNames postgresVersions));

            # Function to create the pg_regress package
            makePgRegress = version:
              let
                postgresqlPackage = pkgs."postgresql_${version}";
              in
              pkgs.callPackage ./nix/ext/pg_regress.nix {
                postgresql = postgresqlPackage;
              };
            postgresql_15 = getPostgresqlPackage "15";
            postgresql_17 = getPostgresqlPackage "17";
            postgresql_orioledb-17 = getPostgresqlPackage "orioledb-17";
          in
          postgresVersions // {
            supabase-groonga = supabase-groonga;
            cargo-pgrx_0_11_3 = pkgs.cargo-pgrx.cargo-pgrx_0_11_3;
            cargo-pgrx_0_12_6 = pkgs.cargo-pgrx.cargo-pgrx_0_12_6;
            cargo-pgrx_0_12_9 = pkgs.cargo-pgrx.cargo-pgrx_0_12_9;
            cargo-pgrx_0_14_3 = pkgs.cargo-pgrx.cargo-pgrx_0_14_3;
            # PostgreSQL versions.
            psql_15 = postgresVersions.psql_15;
            psql_17 = postgresVersions.psql_17;
            psql_orioledb-17 = postgresVersions.psql_orioledb-17;
            wal-g-2 = wal-g-2;
            wal-g-3 = wal-g-3;
            sfcgal = sfcgal;
            pg_prove = pkgs.perlPackages.TAPParserSourceHandlerpgTAP;
            inherit postgresql_15 postgresql_17 postgresql_orioledb-17;
            postgresql_15_debug = if pkgs.stdenv.isLinux then postgresql_15.debug else null;
            postgresql_17_debug = if pkgs.stdenv.isLinux then postgresql_17.debug else null;
            postgresql_orioledb-17_debug = if pkgs.stdenv.isLinux then postgresql_orioledb-17.debug else null;
            postgresql_15_src = pkgs.stdenv.mkDerivation {
              pname = "postgresql-15-src";
              version = postgresql_15.version;

              src = postgresql_15.src;

              nativeBuildInputs = [ pkgs.bzip2 ];

              phases = [ "unpackPhase" "installPhase" ];

              installPhase = ''
                mkdir -p $out
                cp -r . $out
              '';

              meta = with pkgs.lib; {
                description = "PostgreSQL 15 source files";
                homepage = "https://www.postgresql.org/";
                license = licenses.postgresql;
                platforms = platforms.all;
              };
            };
            postgresql_17_src = pkgs.stdenv.mkDerivation {
              pname = "postgresql-17-src";
              version = postgresql_17.version;
              src = postgresql_17.src;

              nativeBuildInputs = [ pkgs.bzip2 ];

              phases = [ "unpackPhase" "installPhase" ];

              installPhase = ''
                mkdir -p $out
                cp -r . $out
              '';
              meta = with pkgs.lib; {
                description = "PostgreSQL 17 source files";
                homepage = "https://www.postgresql.org/";
                license = licenses.postgresql;
                platforms = platforms.all;
              };
            };
            postgresql_orioledb-17_src = pkgs.stdenv.mkDerivation {
              pname = "postgresql-17-src";
              version = postgresql_orioledb-17.version;

              src = postgresql_orioledb-17.src;

              nativeBuildInputs = [ pkgs.bzip2 ];

              phases = [ "unpackPhase" "installPhase" ];

              installPhase = ''
                mkdir -p $out
                cp -r . $out
              '';

              meta = with pkgs.lib; {
                description = "PostgreSQL 15 source files";
                homepage = "https://www.postgresql.org/";
                license = licenses.postgresql;
                platforms = platforms.all;
              };
            };
            mecab_naist_jdic = mecab-naist-jdic;
            supabase_groonga = supabase-groonga;
            pg_regress = makePgRegress activeVersion;
            # Start a version of the server.
            start-server = makePostgresDevSetup {
              inherit pkgs;
              name = "start-postgres-server";
            };

            # Start a version of the client and runs migrations script on server.
            start-client =
              let
                migrationsDir = ./migrations/db;
                postgresqlSchemaSql = ./nix/tools/postgresql_schema.sql;
                pgbouncerAuthSchemaSql = ./ansible/files/pgbouncer_config/pgbouncer_auth_schema.sql;
                statExtensionSql = ./ansible/files/stat_extension.sql;
              in
              pkgs.runCommand "start-postgres-client" { } ''
                mkdir -p $out/bin
                substitute ${./nix/tools/run-client.sh.in} $out/bin/start-postgres-client \
                  --subst-var-by 'PGSQL_DEFAULT_PORT' '${pgsqlDefaultPort}' \
                  --subst-var-by 'PGSQL_SUPERUSER' '${pgsqlSuperuser}' \
                  --subst-var-by 'PSQL15_BINDIR' '${basePackages.psql_15.bin}' \
                  --subst-var-by 'PSQL17_BINDIR' '${basePackages.psql_17.bin}' \
                  --subst-var-by 'PSQLORIOLEDB17_BINDIR' '${basePackages.psql_orioledb-17.bin}' \
                  --subst-var-by 'MIGRATIONS_DIR' '${migrationsDir}' \
                  --subst-var-by 'POSTGRESQL_SCHEMA_SQL' '${postgresqlSchemaSql}' \
                  --subst-var-by 'PGBOUNCER_AUTH_SCHEMA_SQL' '${pgbouncerAuthSchemaSql}' \
                  --subst-var-by 'STAT_EXTENSION_SQL' '${statExtensionSql}'
                chmod +x $out/bin/start-postgres-client
              '';

            # Migrate between two data directories.
            migrate-tool =
              let
                configFile = ./nix/tests/postgresql.conf.in;
                getkeyScript = ./nix/tests/util/pgsodium_getkey.sh;
                primingScript = ./nix/tests/prime.sql;
                migrationData = ./nix/tests/migrations/data.sql;
              in
              pkgs.runCommand "migrate-postgres" { } ''
                mkdir -p $out/bin
                substitute ${./nix/tools/migrate-tool.sh.in} $out/bin/migrate-postgres \
                  --subst-var-by 'PSQL15_BINDIR' '${basePackages.psql_15.bin}' \
                  --subst-var-by 'PSQL_CONF_FILE' '${configFile}' \
                  --subst-var-by 'PGSODIUM_GETKEY' '${getkeyScript}' \
                  --subst-var-by 'PRIMING_SCRIPT' '${primingScript}' \
                  --subst-var-by 'MIGRATION_DATA' '${migrationData}'

                chmod +x $out/bin/migrate-postgres
              '';

            start-replica = pkgs.runCommand "start-postgres-replica" { } ''
              mkdir -p $out/bin
              substitute ${./nix/tools/run-replica.sh.in} $out/bin/start-postgres-replica \
                --subst-var-by 'PGSQL_SUPERUSER' '${pgsqlSuperuser}' \
                --subst-var-by 'PSQL15_BINDIR' '${basePackages.psql_15.bin}'
              chmod +x $out/bin/start-postgres-replica
            '';
            pg-restore =
              pkgs.runCommand "run-pg-restore" { } ''
                mkdir -p $out/bin
                substitute ${./nix/tools/run-restore.sh.in} $out/bin/pg-restore \
                  --subst-var-by PSQL15_BINDIR '${basePackages.psql_15.bin}'
                chmod +x $out/bin/pg-restore
              '';
            sync-exts-versions = pkgs.runCommand "sync-exts-versions" { } ''
              mkdir -p $out/bin
              substitute ${./nix/tools/sync-exts-versions.sh.in} $out/bin/sync-exts-versions \
                --subst-var-by 'YQ' '${pkgs.yq}/bin/yq' \
                --subst-var-by 'JQ' '${pkgs.jq}/bin/jq' \
                --subst-var-by 'NIX_EDITOR' '${nix-editor.packages.${system}.nix-editor}/bin/nix-editor' \
                --subst-var-by 'NIXPREFETCHURL' '${pkgs.nixVersions.nix_2_20}/bin/nix-prefetch-url' \
                --subst-var-by 'NIX' '${pkgs.nixVersions.nix_2_20}/bin/nix'
              chmod +x $out/bin/sync-exts-versions
            '';

            local-infra-bootstrap = pkgs.runCommand "local-infra-bootstrap" { } ''
              mkdir -p $out/bin
              substitute ${./nix/tools/local-infra-bootstrap.sh.in} $out/bin/local-infra-bootstrap
              chmod +x $out/bin/local-infra-bootstrap
            '';
            dbmate-tool =
              let
                migrationsDir = ./migrations/db;
                ansibleVars = ./ansible/vars.yml;
                pgbouncerAuthSchemaSql = ./ansible/files/pgbouncer_config/pgbouncer_auth_schema.sql;
                statExtensionSql = ./ansible/files/stat_extension.sql;
              in
              pkgs.runCommand "dbmate-tool"
                {
                  buildInputs = with pkgs; [
                    overmind
                    dbmate
                    nix
                    jq
                    yq
                  ];
                  nativeBuildInputs = with pkgs; [
                    makeWrapper
                  ];
                } ''
                mkdir -p $out/bin $out/migrations
                cp -r ${migrationsDir}/* $out
                substitute ${./nix/tools/dbmate-tool.sh.in} $out/bin/dbmate-tool \
                  --subst-var-by 'PGSQL_DEFAULT_PORT' '${pgsqlDefaultPort}' \
                  --subst-var-by 'MIGRATIONS_DIR' $out \
                  --subst-var-by 'PGSQL_SUPERUSER' '${pgsqlSuperuser}' \
                  --subst-var-by 'ANSIBLE_VARS' ${ansibleVars} \
                  --subst-var-by 'CURRENT_SYSTEM' '${system}' \
                  --subst-var-by 'PGBOUNCER_AUTH_SCHEMA_SQL' '${pgbouncerAuthSchemaSql}' \
                  --subst-var-by 'STAT_EXTENSION_SQL' '${statExtensionSql}'
                chmod +x $out/bin/dbmate-tool
                wrapProgram $out/bin/dbmate-tool \
                  --prefix PATH : ${pkgs.lib.makeBinPath [ pkgs.overmind pkgs.dbmate pkgs.nix pkgs.jq pkgs.yq ]}
              '';
            show-commands = pkgs.runCommand "show-commands"
              {
                nativeBuildInputs = [ pkgs.makeWrapper ];
                buildInputs = [ pkgs.nushell ];
              } ''
              mkdir -p $out/bin
              cat > $out/bin/show-commands << 'EOF'
              #!${pkgs.nushell}/bin/nu
              let json_output = (nix flake show --json --quiet --all-systems | from json)
              let apps = ($json_output | get apps.${system})
              $apps | transpose name info | select name | each { |it| echo $"Run this app with: nix run .#($it.name)" }
              EOF
              chmod +x $out/bin/show-commands
              wrapProgram $out/bin/show-commands \
                --prefix PATH : ${pkgs.nushell}/bin
            '';
            update-readme = pkgs.runCommand "update-readme"
              {
                nativeBuildInputs = [ pkgs.makeWrapper ];
                buildInputs = [ pkgs.nushell ];
              } ''
              mkdir -p $out/bin
              cp ${./nix/tools/update_readme.nu} $out/bin/update-readme
              chmod +x $out/bin/update-readme
              wrapProgram $out/bin/update-readme \
                --prefix PATH : ${pkgs.nushell}/bin
            '';
            # Script to run the AMI build and tests locally
            build-test-ami = pkgs.runCommand "build-test-ami"
              {
                buildInputs = with pkgs; [
                  packer
                  awscli2
                  yq
                  jq
                  openssl
                  git
                  coreutils
                  aws-vault
                ];
              } ''
                mkdir -p $out/bin
                cat > $out/bin/build-test-ami << 'EOL'
                #!/usr/bin/env bash
                set -euo pipefail

                show_help() {
                  cat << EOF
                Usage: build-test-ami [--help] <postgres-version>

                Build AMI images for PostgreSQL testing.

                This script will:
                1. Check for required tools and AWS authentication
                2. Build two AMI stages using Packer
                3. Clean up any temporary instances
                4. Output the final AMI name for use with run-testinfra

                Arguments:
                  postgres-version    PostgreSQL major version to build (required)

                Options:
                  --help    Show this help message and exit

                Requirements:
                  - AWS Vault profile must be set in AWS_VAULT environment variable
                  - Packer, AWS CLI, yq, jq, and OpenSSL must be installed
                  - Must be run from a git repository

                Example:
                  aws-vault exec <profile-name> -- nix run .#build-test-ami 15
                EOF
                }

                # Handle help flag
                if [[ "$#" -gt 0 && "$1" == "--help" ]]; then
                  show_help
                  exit 0
                fi

                export PATH="${pkgs.lib.makeBinPath (with pkgs; [
                  packer
                  awscli2
                  yq
                  jq
                  openssl
                  git
                  coreutils
                  aws-vault
                ])}:$PATH"

                # Check for required tools
                for cmd in packer aws-vault yq jq openssl; do
                  if ! command -v $cmd &> /dev/null; then
                    echo "Error: $cmd is required but not found"
                    exit 1
                  fi
                done

                # Check AWS Vault profile
                if [ -z "''${AWS_VAULT:-}" ]; then
                  echo "Error: AWS_VAULT environment variable must be set with the profile name"
                  echo "Usage: aws-vault exec <profile-name> -- nix run .#build-test-ami <postgres-version>"
                  exit 1
                fi

                # Set values
                REGION="ap-southeast-1"
                POSTGRES_VERSION="$1"
                RANDOM_STRING=$(openssl rand -hex 8)
                GIT_SHA=$(git rev-parse HEAD)
                RUN_ID=$(date +%s)

                # Generate common-nix.vars.pkr.hcl
                PG_VERSION=$(yq -r ".postgres_release[\"postgres$POSTGRES_VERSION\"]" ansible/vars.yml)
                echo "postgres-version = \"$PG_VERSION\"" > common-nix.vars.pkr.hcl

                # Build AMI Stage 1
                packer init amazon-arm64-nix.pkr.hcl
                packer build \
                  -var "git-head-version=$GIT_SHA" \
                  -var "packer-execution-id=$RUN_ID" \
                  -var-file="development-arm.vars.pkr.hcl" \
                  -var-file="common-nix.vars.pkr.hcl" \
                  -var "ansible_arguments=" \
                  -var "postgres-version=$RANDOM_STRING" \
                  -var "region=$REGION" \
                  -var 'ami_regions=["'"$REGION"'"]' \
                  -var "force-deregister=true" \
                  -var "ansible_arguments=-e postgresql_major=$POSTGRES_VERSION" \
                  amazon-arm64-nix.pkr.hcl

                # Build AMI Stage 2
                packer init stage2-nix-psql.pkr.hcl
                packer build \
                  -var "git-head-version=$GIT_SHA" \
                  -var "packer-execution-id=$RUN_ID" \
                  -var "postgres_major_version=$POSTGRES_VERSION" \
                  -var-file="development-arm.vars.pkr.hcl" \
                  -var-file="common-nix.vars.pkr.hcl" \
                  -var "postgres-version=$RANDOM_STRING" \
                  -var "region=$REGION" \
                  -var 'ami_regions=["'"$REGION"'"]' \
                  -var "force-deregister=true" \
                  -var "git_sha=$GIT_SHA" \
                  stage2-nix-psql.pkr.hcl

                # Cleanup instances from AMI builds
                cleanup_instances() {
                  echo "Terminating EC2 instances with tag testinfra-run-id=$RUN_ID..."
                  aws ec2 --region $REGION describe-instances \
                    --filters "Name=tag:testinfra-run-id,Values=$RUN_ID" \
                    --query "Reservations[].Instances[].InstanceId" \
                    --output text | xargs -r aws ec2 terminate-instances \
                    --region $REGION --instance-ids || true
                }

                # Set up traps for various signals to ensure cleanup
                trap cleanup_instances EXIT HUP INT QUIT TERM

                # Create and activate virtual environment
                VENV_DIR=$(mktemp -d)
                trap 'rm -rf "$VENV_DIR"' EXIT HUP INT QUIT TERM
                python3 -m venv "$VENV_DIR"
                source "$VENV_DIR/bin/activate"

                # Install required Python packages
                echo "Installing required Python packages..."
                pip install boto3 boto3-stubs[essential] docker ec2instanceconnectcli pytest paramiko requests

                # Run the tests with aws-vault
                echo "Running tests for AMI: $RANDOM_STRING using AWS Vault profile: $AWS_VAULT_PROFILE"
                aws-vault exec $AWS_VAULT_PROFILE -- pytest -vv -s testinfra/test_ami_nix.py

                # Deactivate virtual environment (cleanup is handled by trap)
                deactivate
                EOL
                chmod +x $out/bin/build-test-ami
              '';

            run-testinfra = pkgs.runCommand "run-testinfra"
              {
                buildInputs = with pkgs; [
                  aws-vault
                  python3
                  python3Packages.pip
                  coreutils
                ];
              } ''
                mkdir -p $out/bin
                cat > $out/bin/run-testinfra << 'EOL'
                #!/usr/bin/env bash
                set -euo pipefail

                show_help() {
                  cat << EOF
                Usage: run-testinfra --ami-name NAME [--aws-vault-profile PROFILE]

                Run the testinfra tests locally against a specific AMI.

                This script will:
                1. Check if aws-vault is installed and configured
                2. Set up the required environment variables
                3. Create and activate a virtual environment
                4. Install required Python packages from pip
                5. Run the tests with aws-vault credentials
                6. Clean up the virtual environment

                Required flags:
                  --ami-name NAME              The name of the AMI to test

                Optional flags:
                  --aws-vault-profile PROFILE  AWS Vault profile to use (default: staging)
                  --help                       Show this help message and exit

                Requirements:
                  - aws-vault installed and configured
                  - Python 3 with pip
                  - Must be run from the repository root

                Examples:
                  run-testinfra --ami-name supabase-postgres-abc123
                  run-testinfra --ami-name supabase-postgres-abc123 --aws-vault-profile production
                EOF
                }

                # Default values
                AWS_VAULT_PROFILE="staging"
                AMI_NAME=""

                # Parse arguments
                while [[ $# -gt 0 ]]; do
                  case $1 in
                    --aws-vault-profile)
                      AWS_VAULT_PROFILE="$2"
                      shift 2
                      ;;
                    --ami-name)
                      AMI_NAME="$2"
                      shift 2
                      ;;
                    --help)
                      show_help
                      exit 0
                      ;;
                    *)
                      echo "Error: Unexpected argument: $1"
                      show_help
                      exit 1
                      ;;
                  esac
                done

                # Check for required tools
                if ! command -v aws-vault &> /dev/null; then
                  echo "Error: aws-vault is required but not found"
                  exit 1
                fi

                # Check for AMI name argument
                if [ -z "$AMI_NAME" ]; then
                  echo "Error: --ami-name is required"
                  show_help
                  exit 1
                fi

                # Set environment variables
                export AWS_REGION="ap-southeast-1"
                export AWS_DEFAULT_REGION="ap-southeast-1"
                export AMI_NAME="$AMI_NAME"  # Export AMI_NAME for pytest
                export RUN_ID="local-$(date +%s)"  # Generate a unique RUN_ID

                # Function to terminate EC2 instances
                terminate_instances() {
                  echo "Terminating EC2 instances with tag testinfra-run-id=$RUN_ID..."
                  aws-vault exec $AWS_VAULT_PROFILE -- aws ec2 --region ap-southeast-1 describe-instances \
                    --filters "Name=tag:testinfra-run-id,Values=$RUN_ID" \
                    --query "Reservations[].Instances[].InstanceId" \
                    --output text | xargs -r aws-vault exec $AWS_VAULT_PROFILE -- aws ec2 terminate-instances \
                    --region ap-southeast-1 --instance-ids || true
                }

                # Set up traps for various signals to ensure cleanup
                trap terminate_instances EXIT HUP INT QUIT TERM

                # Create and activate virtual environment
                VENV_DIR=$(mktemp -d)
                trap 'rm -rf "$VENV_DIR"' EXIT HUP INT QUIT TERM
                python3 -m venv "$VENV_DIR"
                source "$VENV_DIR/bin/activate"

                # Install required Python packages
                echo "Installing required Python packages..."
                pip install boto3 boto3-stubs[essential] docker ec2instanceconnectcli pytest paramiko requests

                # Function to run tests and ensure cleanup
                run_tests() {
                  local exit_code=0
                  echo "Running tests for AMI: $AMI_NAME using AWS Vault profile: $AWS_VAULT_PROFILE"
                  aws-vault exec "$AWS_VAULT_PROFILE" -- pytest -vv -s testinfra/test_ami_nix.py || exit_code=$?
                  return $exit_code
                }

                # Run tests and capture exit code
                run_tests
                test_exit_code=$?

                # Deactivate virtual environment
                deactivate

                # Explicitly call cleanup
                terminate_instances

                # Exit with the test exit code
                exit $test_exit_code
                EOL
                chmod +x $out/bin/run-testinfra
              '';

            cleanup-ami = pkgs.runCommand "cleanup-ami"
              {
                buildInputs = with pkgs; [
                  awscli2
                  aws-vault
                ];
              } ''
                mkdir -p $out/bin
                cat > $out/bin/cleanup-ami << 'EOL'
                #!/usr/bin/env bash
                set -euo pipefail

                export PATH="${pkgs.lib.makeBinPath (with pkgs; [
                  awscli2
                  aws-vault
                ])}:$PATH"

                # Check for required tools
                for cmd in aws-vault; do
                  if ! command -v $cmd &> /dev/null; then
                    echo "Error: $cmd is required but not found"
                    exit 1
                  fi
                done

                # Check AWS Vault profile
                if [ -z "''${AWS_VAULT:-}" ]; then
                  echo "Error: AWS_VAULT environment variable must be set with the profile name"
                  echo "Usage: aws-vault exec <profile-name> -- nix run .#cleanup-ami <ami-name>"
                  exit 1
                fi

                # Check for AMI name argument
                if [ -z "''${1:-}" ]; then
                  echo "Error: AMI name must be provided"
                  echo "Usage: aws-vault exec <profile-name> -- nix run .#cleanup-ami <ami-name>"
                  exit 1
                fi

                AMI_NAME="$1"
                REGION="ap-southeast-1"

                # Deregister AMIs
                for AMI_PATTERN in "supabase-postgres-ci-ami-test-stage-1" "$AMI_NAME"; do
                  aws ec2 describe-images --region $REGION --owners self \
                    --filters "Name=name,Values=$AMI_PATTERN" \
                    --query 'Images[*].ImageId' --output text | while read -r ami_id; do
                      echo "Deregistering AMI: $ami_id"
                      aws ec2 deregister-image --region $REGION --image-id "$ami_id" || true
                    done
                done
                EOL
                chmod +x $out/bin/cleanup-ami
              '';

            trigger-nix-build = pkgs.runCommand "trigger-nix-build"
              {
                buildInputs = with pkgs; [
                  gh
                  git
                  coreutils
                ];
              } ''
                mkdir -p $out/bin
                cat > $out/bin/trigger-nix-build << 'EOL'
                #!/usr/bin/env bash
                set -euo pipefail

                show_help() {
                  cat << EOF
                Usage: trigger-nix-build [--help]

                Trigger the nix-build workflow for the current branch and watch its progress.

                This script will:
                1. Check if you're authenticated with GitHub
                2. Get the current branch and commit
                3. Verify you're on a standard branch (develop or release/*) or prompt for confirmation
                4. Trigger the nix-build workflow
                5. Watch the workflow progress until completion

                Options:
                  --help    Show this help message and exit

                Requirements:
                  - GitHub CLI (gh) installed and authenticated
                  - Git installed
                  - Must be run from a git repository

                Example:
                  trigger-nix-build
                EOF
                }

                # Handle help flag
                if [[ "$#" -gt 0 && "$1" == "--help" ]]; then
                  show_help
                  exit 0
                fi

                export PATH="${pkgs.lib.makeBinPath (with pkgs; [
                  gh
                  git
                  coreutils
                ])}:$PATH"

                # Check for required tools
                for cmd in gh git; do
                  if ! command -v $cmd &> /dev/null; then
                    echo "Error: $cmd is required but not found"
                    exit 1
                  fi
                done

                # Check if user is authenticated with GitHub
                if ! gh auth status &>/dev/null; then
                  echo "Error: Not authenticated with GitHub. Please run 'gh auth login' first."
                  exit 1
                fi

                # Get current branch and commit
                BRANCH=$(git rev-parse --abbrev-ref HEAD)
                COMMIT=$(git rev-parse HEAD)

                # Check if we're on a standard branch
                if [[ "$BRANCH" != "develop" && ! "$BRANCH" =~ ^release/ ]]; then
                  echo "Warning: Running workflow from non-standard branch: $BRANCH"
                  echo "This is supported for testing purposes."
                  read -p "Continue? [y/N] " -n 1 -r
                  echo
                  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                    echo "Aborted."
                    exit 1
                  fi
                fi

                # Trigger the workflow
                echo "Triggering nix-build workflow for branch $BRANCH (commit: $COMMIT)"
                gh workflow run nix-build.yml --ref "$BRANCH"

                # Wait for workflow to start and get the run ID
                echo "Waiting for workflow to start..."
                sleep 5

                # Get the latest run ID for this workflow
                RUN_ID=$(gh run list --workflow=nix-build.yml --limit 1 --json databaseId --jq '.[0].databaseId')

                if [ -z "$RUN_ID" ]; then
                  echo "Error: Could not find workflow run ID"
                  exit 1
                fi

                echo "Watching workflow run $RUN_ID..."
                echo "The script will automatically exit when the workflow completes."
                echo "Press Ctrl+C to stop watching (workflow will continue running)"
                echo "----------------------------------------"

                # Try to watch the run, but handle network errors gracefully
                while true; do
                  if gh run watch "$RUN_ID" --exit-status; then
                    break
                  else
                    echo "Network error while watching workflow. Retrying in 5 seconds..."
                    echo "You can also check the status manually with: gh run view $RUN_ID"
                    sleep 5
                  fi
                done
                EOL
                chmod +x $out/bin/trigger-nix-build
              '';
          };


        # Create a testing harness for a PostgreSQL package. This is used for
        # 'nix flake check', and works with any PostgreSQL package you hand it.

        makeCheckHarness = pgpkg:
          let
            sqlTests = ./nix/tests/smoke;
            pg_prove = pkgs.perlPackages.TAPParserSourceHandlerpgTAP;
            pg_regress = basePackages.pg_regress;
            getkey-script = pkgs.stdenv.mkDerivation {
              name = "pgsodium-getkey";
              buildCommand = ''
                mkdir -p $out/bin
                cat > $out/bin/pgsodium-getkey << 'EOF'
                #!${pkgs.bash}/bin/bash
                set -euo pipefail

                TMPDIR_BASE=$(mktemp -d)

                KEY_DIR="''${PGSODIUM_KEY_DIR:-$TMPDIR_BASE/pgsodium}"
                KEY_FILE="$KEY_DIR/pgsodium.key"

                if ! mkdir -p "$KEY_DIR" 2>/dev/null; then
                  echo "Error: Could not create key directory $KEY_DIR" >&2
                  exit 1
                fi
                chmod 1777 "$KEY_DIR"

                if [[ ! -f "$KEY_FILE" ]]; then
                  if ! (dd if=/dev/urandom bs=32 count=1 2>/dev/null | od -A n -t x1 | tr -d ' \n' > "$KEY_FILE"); then
                    if ! (openssl rand -hex 32 > "$KEY_FILE"); then
                      echo "00000000000000000000000000000000" > "$KEY_FILE"
                      echo "Warning: Using fallback key" >&2
                    fi
                  fi
                  chmod 644 "$KEY_FILE"
                fi

                if [[ -f "$KEY_FILE" && -r "$KEY_FILE" ]]; then
                  cat "$KEY_FILE"
                else
                  echo "Error: Cannot read key file $KEY_FILE" >&2
                  exit 1
                fi
                EOF
                chmod +x $out/bin/pgsodium-getkey
              '';
            };

            # Use the shared setup but with a test-specific name
            start-postgres-server-bin = makePostgresDevSetup {
              inherit pkgs;
              name = "start-postgres-server-test";
              extraSubstitutions = {
                PGSODIUM_GETKEY = "${getkey-script}/bin/pgsodium-getkey";
                PGSQL_DEFAULT_PORT = pgPort;
              };
            };

            getVersionArg = pkg:
              let
                name = pkg.version;
              in
              if builtins.match "15.*" name != null then "15"
              else if builtins.match "17.*" name != null then "17"
              else if builtins.match "orioledb-17.*" name != null then "orioledb-17"
              else throw "Unsupported PostgreSQL version: ${name}";

            # Helper function to filter SQL files based on version
            filterTestFiles = version: dir:
              let
                files = builtins.readDir dir;
                isValidFile = name:
                  let
                    isVersionSpecific = builtins.match "z_.*" name != null;
                    matchesVersion =
                      if isVersionSpecific
                      then
                        if version == "orioledb-17"
                        then builtins.match "z_orioledb-17_.*" name != null
                        else if version == "17"
                        then builtins.match "z_17_.*" name != null
                        else builtins.match "z_15_.*" name != null
                      else true;
                  in
                  pkgs.lib.hasSuffix ".sql" name && matchesVersion;
              in
              pkgs.lib.filterAttrs (name: _: isValidFile name) files;

            # Get the major version for filtering
            majorVersion =
              let
                version = builtins.trace "pgpkg.version is: ${pgpkg.version}" pgpkg.version;
                _ = builtins.trace "Entering majorVersion logic";
                isOrioledbMatch = builtins.match "^17_[0-9]+$" version != null;
                isSeventeenMatch = builtins.match "^17[.][0-9]+$" version != null;
                result =
                  if isOrioledbMatch
                  then "orioledb-17"
                  else if isSeventeenMatch
                  then "17"
                  else "15";
              in
              builtins.trace "Major version result: ${result}" result; # Trace the result                                             # For "15.8"

            # Filter SQL test files
            filteredSqlTests = filterTestFiles majorVersion ./nix/tests/sql;

            pgPort = if (majorVersion == "17") then
                "5535"
                else if (majorVersion == "15") then
                "5536"
                else "5537";

            # Convert filtered tests to a sorted list of basenames (without extension)
            testList = pkgs.lib.mapAttrsToList
              (name: _:
                builtins.substring 0 (pkgs.lib.stringLength name - 4) name
              )
              filteredSqlTests;
            sortedTestList = builtins.sort (a: b: a < b) testList;

          in
          pkgs.runCommand "postgres-${pgpkg.version}-check-harness"
            {
              nativeBuildInputs = with pkgs; [
                coreutils
                bash
                perl
                pgpkg
                pg_prove
                pg_regress
                procps
                start-postgres-server-bin
                which
                getkey-script
                supabase-groonga
              ];
            } ''
            set -e

            #First we need to create a generic pg cluster for pgtap tests and run those
            export GRN_PLUGINS_DIR=${supabase-groonga}/lib/groonga/plugins
            PGTAP_CLUSTER=$(mktemp -d)
            initdb --locale=C --username=supabase_admin -D "$PGTAP_CLUSTER"
            substitute ${./nix/tests/postgresql.conf.in} "$PGTAP_CLUSTER"/postgresql.conf \
              --subst-var-by PGSODIUM_GETKEY_SCRIPT "${getkey-script}/bin/pgsodium-getkey"
            echo "listen_addresses = '*'" >> "$PGTAP_CLUSTER"/postgresql.conf
            echo "port = ${pgPort}" >> "$PGTAP_CLUSTER"/postgresql.conf
            echo "host all all 127.0.0.1/32 trust" >> $PGTAP_CLUSTER/pg_hba.conf
            echo "Checking shared_preload_libraries setting:"
            grep -rn "shared_preload_libraries" "$PGTAP_CLUSTER"/postgresql.conf
            # Remove timescaledb if running orioledb-17 check
            echo "I AM ${pgpkg.version}===================================================="
            if [[ "${pgpkg.version}" == *"17"* ]]; then
              perl -pi -e 's/ timescaledb,//g' "$PGTAP_CLUSTER/postgresql.conf"
            fi
            #NOTE in the future we may also need to add the orioledb extension to the cluster when cluster is oriole
            echo "PGTAP_CLUSTER directory contents:"
            ls -la "$PGTAP_CLUSTER"

            # Check if postgresql.conf exists
            if [ ! -f "$PGTAP_CLUSTER/postgresql.conf" ]; then
                echo "postgresql.conf is missing!"
                exit 1
            fi

            # PostgreSQL startup
            if [[ "$(uname)" == "Darwin" ]]; then
            pg_ctl -D "$PGTAP_CLUSTER" -l "$PGTAP_CLUSTER"/postgresql.log -o "-k "$PGTAP_CLUSTER" -p ${pgPort} -d 5" start 2>&1
            else
            mkdir -p "$PGTAP_CLUSTER/sockets"
            pg_ctl -D "$PGTAP_CLUSTER" -l "$PGTAP_CLUSTER"/postgresql.log -o "-k $PGTAP_CLUSTER/sockets -p ${pgPort} -d 5" start 2>&1
            fi || {
            echo "pg_ctl failed to start PostgreSQL"
            echo "Contents of postgresql.log:"
            cat "$PGTAP_CLUSTER"/postgresql.log
            exit 1
            }
            for i in {1..60}; do
              if pg_isready -h ${pgsqlDefaultHost} -p ${pgPort}; then
                echo "PostgreSQL is ready"
                break
              fi
              sleep 1
              if [ $i -eq 60 ]; then
                echo "PostgreSQL is not ready after 60 seconds"
                echo "PostgreSQL status:"
                pg_ctl -D "$PGTAP_CLUSTER" status
                echo "PostgreSQL log content:"
                cat "$PGTAP_CLUSTER"/postgresql.log
                exit 1
              fi
            done
            createdb -p ${pgPort} -h ${pgsqlDefaultHost} --username=supabase_admin testing
            if ! psql -p ${pgPort} -h ${pgsqlDefaultHost} --username=supabase_admin -d testing -v ON_ERROR_STOP=1 -Xf ${./nix/tests/prime.sql}; then
              echo "Error executing SQL file. PostgreSQL log content:"
              cat "$PGTAP_CLUSTER"/postgresql.log
              pg_ctl -D "$PGTAP_CLUSTER" stop
              exit 1
            fi
            SORTED_DIR=$(mktemp -d)
            for t in $(printf "%s\n" ${builtins.concatStringsSep " " sortedTestList}); do
              psql -p ${pgPort} -h ${pgsqlDefaultHost} --username=supabase_admin -d testing -f "${./nix/tests/sql}/$t.sql" || true
            done
            rm -rf "$SORTED_DIR"
            pg_ctl -D "$PGTAP_CLUSTER" stop
            rm -rf $PGTAP_CLUSTER

            # End of pgtap tests
            # from here on out we are running pg_regress tests, we use a different cluster for this
            # which is start by the start-postgres-server-bin script
            # start-postgres-server-bin script closely matches our AMI setup, configurations and migrations

            unset GRN_PLUGINS_DIR
            ${start-postgres-server-bin}/bin/start-postgres-server ${getVersionArg pgpkg} --daemonize

            for i in {1..60}; do
                if pg_isready -h ${pgsqlDefaultHost} -p ${pgPort} -U supabase_admin -q; then
                    echo "PostgreSQL is ready"
                    break
                fi
                sleep 1
                if [ $i -eq 60 ]; then
                    echo "PostgreSQL failed to start"
                    exit 1
                fi
            done

            if ! psql -p ${pgPort} -h ${pgsqlDefaultHost} --no-password --username=supabase_admin -d postgres -v ON_ERROR_STOP=1 -Xf ${./nix/tests/prime.sql}; then
              echo "Error executing SQL file"
              exit 1
            fi

            mkdir -p $out/regression_output
            if ! pg_regress \
              --use-existing \
              --dbname=postgres \
              --inputdir=${./nix/tests} \
              --outputdir=$out/regression_output \
              --host=${pgsqlDefaultHost} \
              --port=${pgPort} \
              --user=supabase_admin \
              ${builtins.concatStringsSep " " sortedTestList}; then
              echo "pg_regress tests failed"
              cat $out/regression_output/regression.diffs
              exit 1
            fi

            echo "Running migrations tests"
            pg_prove -p ${pgPort} -U supabase_admin -h ${pgsqlDefaultHost} -d postgres -v ${./migrations/tests}/test.sql

            # Copy logs to output
            for logfile in $(find /tmp -name postgresql.log -type f); do
              cp "$logfile" $out/postgresql.log
            done
            exit 0
          '';
      in
      rec {
        # The list of all packages that can be built with 'nix build'. The list
        # of names that can be used can be shown with 'nix flake show'
        packages = flake-utils.lib.flattenTree basePackages // {
          # Any extra packages we might want to include in our package
          # set can go here.
          inherit (pkgs);
        };

        # The list of exported 'checks' that are run with every run of 'nix
        # flake check'. This is run in the CI system, as well.
        checks = {
          psql_15 = makeCheckHarness basePackages.psql_15.bin;
          psql_17 = makeCheckHarness basePackages.psql_17.bin;
          psql_orioledb-17 = makeCheckHarness basePackages.psql_orioledb-17.bin;
          inherit (basePackages) wal-g-2 wal-g-3 dbmate-tool pg_regress;
        } // pkgs.lib.optionalAttrs (system == "aarch64-linux") {
          inherit (basePackages) postgresql_15_debug postgresql_15_src postgresql_orioledb-17_debug postgresql_orioledb-17_src postgresql_17_debug postgresql_17_src;
        };

        # Apps is a list of names of things that can be executed with 'nix run';
        # these are distinct from the things that can be built with 'nix build',
        # so they need to be listed here too.
        apps =
          let
            mkApp = attrName: binName: {
              type = "app";
              program = "${basePackages."${attrName}"}/bin/${binName}";
            };
          in
          {
            start-server = mkApp "start-server" "start-postgres-server";
            start-client = mkApp "start-client" "start-postgres-client";
            start-replica = mkApp "start-replica" "start-postgres-replica";
            # migrate-postgres = mkApp "migrate-tool" "migrate-postgres";
            # sync-exts-versions = mkApp "sync-exts-versions" "sync-exts-versions";
            pg-restore = mkApp "pg-restore" "pg-restore";
            local-infra-bootstrap = mkApp "local-infra-bootstrap" "local-infra-bootstrap";
            dbmate-tool = mkApp "dbmate-tool" "dbmate-tool";
            update-readme = mkApp "update-readme" "update-readme";
            show-commands = mkApp "show-commands" "show-commands";
            build-test-ami = mkApp "build-test-ami" "build-test-ami";
            run-testinfra = mkApp "run-testinfra" "run-testinfra";
            cleanup-ami = mkApp "cleanup-ami" "cleanup-ami";
            trigger-nix-build = mkApp "trigger-nix-build" "trigger-nix-build";
          };

        # 'devShells.default' lists the set of packages that are included in the
        # ambient $PATH environment when you run 'nix develop'. This is useful
        # for development and puts many convenient devtools instantly within
        # reach.

        devShells =
          let
            mkCargoPgrxDevShell = { pgrxVersion, rustVersion }: pkgs.mkShell {
              packages = with pkgs; [
                basePackages."cargo-pgrx_${pgrxVersion}"
                (rust-bin.stable.${rustVersion}.default.override {
                  extensions = [ "rust-src" ];
                })
              ];
              shellHook = ''
                export HISTFILE=.history
              '';
            };
          in
          {
            default = pkgs.mkShell {
              packages = with pkgs; [
                coreutils
                just
                nix-update
                #pg_prove
                shellcheck
                ansible
                ansible-lint
                (packer.overrideAttrs (oldAttrs: {
                  version = "1.7.8";
                }))

                basePackages.start-server
                basePackages.start-client
                basePackages.start-replica
                basePackages.migrate-tool
                basePackages.sync-exts-versions
                basePackages.build-test-ami
                basePackages.run-testinfra
                basePackages.cleanup-ami
                dbmate
                nushell
                pythonEnv
                ] ++ pkgs.lib.optionals (nixFastBuild != null) [
                nixFastBuild
                ];
              shellHook = ''
                export HISTFILE=.history
              '';
            };
            cargo-pgrx_0_11_3 = mkCargoPgrxDevShell {
              pgrxVersion = "0_11_3";
              rustVersion = "1.80.0";
            };
            cargo-pgrx_0_12_6 = mkCargoPgrxDevShell {
              pgrxVersion = "0_12_6";
              rustVersion = "1.80.0";
            };
          };
      }
    );
}

'''

